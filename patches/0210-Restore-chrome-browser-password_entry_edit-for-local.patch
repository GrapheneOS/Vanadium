From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: quh4gko8 <88831734+quh4gko8@users.noreply.github.com>
Date: Tue, 5 Aug 2025 09:45:20 +0000
Subject: [PATCH] Restore //chrome/browser/password_entry_edit for local
 password manager

Partially revert "[passwords/android] Remove unused password checkup UI"

This partially reverts commit 6875d2ce472e7f2097617525feec45313602e225.
---
 chrome/android/BUILD.gn                       |   4 +
 chrome/android/java/res/values/dimens.xml     |   6 +
 .../settings/FragmentDependencyProvider.java  |   7 +
 chrome/browser/BUILD.gn                       |   1 +
 .../android/java/res/values/strings.xml       |   2 +
 chrome/browser/password_entry_edit/BUILD.gn   |  11 +
 .../browser/password_entry_edit/DIR_METADATA  |   7 +
 chrome/browser/password_entry_edit/OWNERS     |   3 +
 .../password_entry_edit/android/BUILD.gn      |  77 ++++
 .../android/credential_edit_bridge.cc         | 139 ++++++
 .../android/credential_edit_bridge.h          |  96 ++++
 .../android/internal/BUILD.gn                 |  98 +++++
 .../BlockedCredentialViewBinder.java          |  44 ++
 .../CredentialEditBridge.java                 | 143 ++++++
 .../CredentialEditControllerTest.java         | 410 ++++++++++++++++++
 .../CredentialEditCoordinator.java            | 142 ++++++
 .../CredentialEditMediator.java               | 328 ++++++++++++++
 .../CredentialEditProperties.java             |  48 ++
 .../CredentialEditUiFactory.java              |  52 +++
 .../CredentialEditViewBinder.java             |  52 +++
 .../CredentialEditViewTest.java               | 237 ++++++++++
 .../FederatedCredentialViewBinder.java        |  45 ++
 .../res/layout/blocked_credential_view.xml    |  18 +
 .../java/res/layout/credential_edit_view.xml  | 141 ++++++
 .../res/layout/federated_credential_view.xml  |  86 ++++
 .../android/java/res/layout/site_or_app.xml   |  27 ++
 .../menu/credential_edit_action_bar_menu.xml  |  25 ++
 .../android/java/res/values/dimens.xml        |  17 +
 .../BlockedCredentialFragmentView.java        |  56 +++
 .../CredentialEditFragmentView.java           | 226 ++++++++++
 .../CredentialEntryFragmentViewBase.java      | 135 ++++++
 .../FederatedCredentialFragmentView.java      | 116 +++++
 .../browser/password_manager/android/BUILD.gn |   5 +
 .../PasswordAccessReauthenticationHelper.java | 143 ++++++
 .../PasswordReauthenticationFragment.java     | 111 +++++
 .../settings/ReauthenticationManager.java     | 198 +++++++++
 .../PasswordReauthenticationFragmentTest.java | 121 ++++++
 .../settings/ReauthenticationManagerTest.java | 214 +++++++++
 .../strings/android_chrome_strings.grd        |  83 ++++
 .../IDS_LOCKSCREEN_DESCRIPTION_EDIT.png.sha1  |   1 +
 .../IDS_PASSWORDS_CHECK_TITLE.png.sha1        |   1 +
 ...ECK_DELETE_CREDENTIAL_DIALOG_BODY.png.sha1 |   1 +
 .../IDS_PASSWORD_EDIT_HINT.png.sha1           |   1 +
 ...SSWORD_ENTRY_COPY_SET_SCREEN_LOCK.png.sha1 |   1 +
 ..._DELETE_CREDENTIAL_DIALOG_CONFIRM.png.sha1 |   1 +
 ...IT_DELETE_CREDENTIAL_DIALOG_TITLE.png.sha1 |   1 +
 ...D_ENTRY_EDIT_DELETION_DIALOG_BODY.png.sha1 |   1 +
 ...TRY_EDIT_DUPLICATE_USERNAME_ERROR.png.sha1 |   1 +
 ...ENTRY_VIEWER_SHOW_STORED_PASSWORD.png.sha1 |   1 +
 ...SSWORD_ENTRY_VIEW_SET_SCREEN_LOCK.png.sha1 |   1 +
 .../IDS_PASSWORD_VIA_FEDERATION.png.sha1      |   1 +
 51 files changed, 3686 insertions(+)
 create mode 100644 chrome/browser/password_entry_edit/BUILD.gn
 create mode 100644 chrome/browser/password_entry_edit/DIR_METADATA
 create mode 100644 chrome/browser/password_entry_edit/OWNERS
 create mode 100644 chrome/browser/password_entry_edit/android/BUILD.gn
 create mode 100644 chrome/browser/password_entry_edit/android/credential_edit_bridge.cc
 create mode 100644 chrome/browser/password_entry_edit/android/credential_edit_bridge.h
 create mode 100644 chrome/browser/password_entry_edit/android/internal/BUILD.gn
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialViewBinder.java
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditBridge.java
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditControllerTest.java
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditCoordinator.java
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditMediator.java
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditProperties.java
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditUiFactory.java
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewBinder.java
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewTest.java
 create mode 100644 chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialViewBinder.java
 create mode 100644 chrome/browser/password_entry_edit/android/java/res/layout/blocked_credential_view.xml
 create mode 100644 chrome/browser/password_entry_edit/android/java/res/layout/credential_edit_view.xml
 create mode 100644 chrome/browser/password_entry_edit/android/java/res/layout/federated_credential_view.xml
 create mode 100644 chrome/browser/password_entry_edit/android/java/res/layout/site_or_app.xml
 create mode 100644 chrome/browser/password_entry_edit/android/java/res/menu/credential_edit_action_bar_menu.xml
 create mode 100644 chrome/browser/password_entry_edit/android/java/res/values/dimens.xml
 create mode 100644 chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialFragmentView.java
 create mode 100644 chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditFragmentView.java
 create mode 100644 chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEntryFragmentViewBase.java
 create mode 100644 chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialFragmentView.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordAccessReauthenticationHelper.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragment.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManager.java
 create mode 100644 chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragmentTest.java
 create mode 100644 chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManagerTest.java
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_LOCKSCREEN_DESCRIPTION_EDIT.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORDS_CHECK_TITLE.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_CHECK_DELETE_CREDENTIAL_DIALOG_BODY.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_EDIT_HINT.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_COPY_SET_SCREEN_LOCK.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_CONFIRM.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_TITLE.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETION_DIALOG_BODY.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DUPLICATE_USERNAME_ERROR.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_VIEWER_SHOW_STORED_PASSWORD.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_VIEW_SET_SCREEN_LOCK.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_VIA_FEDERATION.png.sha1

diff --git a/chrome/android/BUILD.gn b/chrome/android/BUILD.gn
index fc38c26abab9e..d957f88bfda0b 100644
--- a/chrome/android/BUILD.gn
+++ b/chrome/android/BUILD.gn
@@ -446,6 +446,7 @@ if (_is_default_toolchain) {
       "//chrome/browser/partnercustomizations:delegate_java",
       "//chrome/browser/partnercustomizations:helper_java",
       "//chrome/browser/partnercustomizations:java",
+      "//chrome/browser/password_entry_edit:public_java",
       "//chrome/browser/password_manager/android:java",
       "//chrome/browser/password_manager/android:settings_interface_java",
       "//chrome/browser/password_manager/android:utils_java",
@@ -929,6 +930,7 @@ if (_is_default_toolchain) {
       "//chrome/browser/mandatory_reauth/android/internal:java",
       "//chrome/browser/partnerbookmarks:java",
       "//chrome/browser/password_edit_dialog/android:java",
+      "//chrome/browser/password_entry_edit/android/internal:java",
       "//chrome/browser/password_manager/android/add_username_dialog:java",
       "//chrome/browser/recent_tabs/internal:java",
       "//chrome/browser/settings:internal_java",
@@ -1137,6 +1139,7 @@ if (_is_default_toolchain) {
       "//chrome/browser/partnerbookmarks:junit",
       "//chrome/browser/partnercustomizations:junit",
       "//chrome/browser/password_edit_dialog/android:junit",
+      "//chrome/browser/password_entry_edit/android/internal:junit",
       "//chrome/browser/password_manager/android/pwd_check_wrapper:junit",
       "//chrome/browser/payments/android:junit",
       "//chrome/browser/policy/android:junit",
@@ -1434,6 +1437,7 @@ if (_is_default_toolchain) {
       "//chrome/browser/language/android:javatests",
       "//chrome/browser/notifications:javatests",
       "//chrome/browser/optimization_guide/android:javatests",
+      "//chrome/browser/password_entry_edit/android/internal:javatests",
       "//chrome/browser/prefetch/android:javatests",
       "//chrome/browser/privacy_guide/android:javatests",
       "//chrome/browser/privacy_sandbox/android:javatests",
diff --git a/chrome/android/java/res/values/dimens.xml b/chrome/android/java/res/values/dimens.xml
index d0e5d79f9de41..355336937a03d 100644
--- a/chrome/android/java/res/values/dimens.xml
+++ b/chrome/android/java/res/values/dimens.xml
@@ -76,6 +76,12 @@ found in the LICENSE file.
     <dimen name="keyboard_accessory_height_with_shadow">56dp</dimen>
     <dimen name="keyboard_accessory_sheet_height">330dp</dimen>
 
+    <!-- Password entry editor dimensions -->
+    <dimen name="password_entry_editor_content_spacing">12dp</dimen>
+    <dimen name="password_entry_editor_field_bottom_margin">8dp</dimen>
+    <dimen name="password_entry_editor_field_large_top_margin">16dp</dimen>
+    <dimen name="password_entry_editor_field_top_margin">8dp</dimen>
+
     <!-- Password manager illustration dialogs -->
     <dimen name="password_manager_dialog_padding">8dp</dimen>
     <dimen name="password_manager_dialog_illustration_height">156dp</dimen>
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/settings/FragmentDependencyProvider.java b/chrome/android/java/src/org/chromium/chrome/browser/settings/FragmentDependencyProvider.java
index c04a6e21aed79..f56a7a0baf288 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/settings/FragmentDependencyProvider.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/settings/FragmentDependencyProvider.java
@@ -10,8 +10,10 @@ import android.os.Bundle;
 import androidx.fragment.app.Fragment;
 import androidx.fragment.app.FragmentManager;
 
+import org.chromium.base.IntentUtils;
 import org.chromium.base.supplier.ObservableSupplier;
 import org.chromium.base.supplier.OneshotSupplier;
+import org.chromium.chrome.browser.LaunchIntentDispatcher;
 import org.chromium.build.annotations.NullMarked;
 import org.chromium.build.annotations.Nullable;
 import org.chromium.chrome.browser.accessibility.settings.ChromeAccessibilitySettingsDelegate;
@@ -25,6 +27,8 @@ import org.chromium.chrome.browser.language.settings.LanguageSettings;
 import org.chromium.chrome.browser.lifetime.ApplicationLifetime;
 import org.chromium.chrome.browser.locale.LocaleManager;
 import org.chromium.chrome.browser.page_info.SiteSettingsHelper;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEditUiFactory;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEntryFragmentViewBase;
 import org.chromium.chrome.browser.password_manager.PasswordManagerHelper;
 import org.chromium.chrome.browser.password_manager.PasswordStoreBridge;
 import org.chromium.chrome.browser.privacy_guide.PrivacyGuideFragment;
@@ -126,6 +130,9 @@ public class FragmentDependencyProvider extends FragmentManager.FragmentLifecycl
                     PasswordManagerHelper.getForProfile(mProfile),
                     new SettingsCustomTabLauncherImpl());
         }
+        if (fragment instanceof CredentialEntryFragmentViewBase) {
+            CredentialEditUiFactory.create((CredentialEntryFragmentViewBase) fragment, mProfile);
+        }
         if (fragment instanceof SearchEngineSettings) {
             SearchEngineSettings settings = (SearchEngineSettings) fragment;
             settings.setDisableAutoSwitchRunnable(
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 481efdcf19c13..8c6bf8c64559b 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -3410,6 +3410,7 @@ static_library("browser") {
       "//chrome/browser/partnerbookmarks:android_impl",
       "//chrome/browser/partnercustomizations:jni_headers",
       "//chrome/browser/password_edit_dialog/android",
+      "//chrome/browser/password_entry_edit/android",
       "//chrome/browser/password_manager/android:password_manager_android",
       "//chrome/browser/policy/android",
       "//chrome/browser/policy/android:jni_headers",
diff --git a/chrome/browser/feedback/android/java/res/values/strings.xml b/chrome/browser/feedback/android/java/res/values/strings.xml
index dd83b3c17aed6..a03fb3c554226 100644
--- a/chrome/browser/feedback/android/java/res/values/strings.xml
+++ b/chrome/browser/feedback/android/java/res/values/strings.xml
@@ -22,7 +22,9 @@ found in the LICENSE file.
     <string name="help_context_sad_tab">mobile_awsnap</string>
     <string name="help_context_clear_browsing_data">clear_browsing_data</string>
     <string name="help_context_sync_and_services">syncgoogleservices</string>
+    <string name="help_context_passwords">passwords</string>
     <string name="help_context_password_leak_detection">leak_detection_android</string>
+    <string name="help_context_check_passwords">check_passwords</string>
     <string name="help_context_safe_browsing">safebrowsing_android</string>
     <!-- TODO(peconn): Add help section. -->
     <!-- <string name="help_context_suggestions">mobile_content_suggestions</string> -->
diff --git a/chrome/browser/password_entry_edit/BUILD.gn b/chrome/browser/password_entry_edit/BUILD.gn
new file mode 100644
index 0000000000000..0fc6129fb9920
--- /dev/null
+++ b/chrome/browser/password_entry_edit/BUILD.gn
@@ -0,0 +1,11 @@
+# Copyright 2021 The Chromium Authors
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/android/rules.gni")
+java_group("public_java") {
+  deps = [
+    "android:factory_java",
+    "android:java",
+  ]
+}
diff --git a/chrome/browser/password_entry_edit/DIR_METADATA b/chrome/browser/password_entry_edit/DIR_METADATA
new file mode 100644
index 0000000000000..eed8b5f2b4731
--- /dev/null
+++ b/chrome/browser/password_entry_edit/DIR_METADATA
@@ -0,0 +1,7 @@
+monorail: {
+  component: "UI>Browser>Passwords"
+}
+team_email: "chromium-dev@chromium.org"
+buganizer_public: {
+  component_id: 1457410
+}
diff --git a/chrome/browser/password_entry_edit/OWNERS b/chrome/browser/password_entry_edit/OWNERS
new file mode 100644
index 0000000000000..b29db19810b4e
--- /dev/null
+++ b/chrome/browser/password_entry_edit/OWNERS
@@ -0,0 +1,3 @@
+friedrichh@chromium.org
+ioanap@chromium.org
+
diff --git a/chrome/browser/password_entry_edit/android/BUILD.gn b/chrome/browser/password_entry_edit/android/BUILD.gn
new file mode 100644
index 0000000000000..eb1bcb8031895
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/BUILD.gn
@@ -0,0 +1,77 @@
+# Copyright 2021 The Chromium Authors
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/android/rules.gni")
+import("//chrome/android/features/android_library_factory_tmpl.gni")
+
+source_set("android") {
+  sources = [
+    "credential_edit_bridge.cc",
+    "credential_edit_bridge.h",
+  ]
+
+  deps = [
+    "//base",
+    "//chrome/app:generated_resources",
+    "//chrome/browser/password_entry_edit/android/internal:jni",
+    "//chrome/browser/ui",
+    "//components/password_manager/core/browser",
+    "//components/password_manager/core/browser/affiliation:affiliation_fetching",
+    "//components/url_formatter",
+    "//ui/base",
+  ]
+}
+
+android_library("java") {
+  sources = [
+    "//chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialFragmentView.java",
+    "//chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditFragmentView.java",
+    "//chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEntryFragmentViewBase.java",
+    "//chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialFragmentView.java",
+  ]
+
+  deps = [
+    ":java_resources",
+    "//base:supplier_java",
+    "//components/browser_ui/settings/android:java",
+    "//third_party/android_deps:material_design_java",
+    "//third_party/androidx:androidx_annotation_annotation_java",
+    "//third_party/androidx:androidx_core_core_java",
+    "//third_party/androidx:androidx_fragment_fragment_java",
+    "//third_party/androidx:androidx_preference_preference_java",
+    "//ui/android:ui_no_recycler_view_java",
+  ]
+
+  resources_package = "org.chromium.chrome.browser.password_entry_edit"
+}
+
+android_resources("java_resources") {
+  sources = [
+    "java/res/layout/blocked_credential_view.xml",
+    "java/res/layout/credential_edit_view.xml",
+    "java/res/layout/federated_credential_view.xml",
+    "java/res/layout/site_or_app.xml",
+    "java/res/menu/credential_edit_action_bar_menu.xml",
+    "java/res/values/dimens.xml",
+  ]
+  deps = [
+    "//chrome/browser/feedback/android:java_resources",
+    "//chrome/browser/ui/android/strings:ui_strings_grd",
+    "//components/browser_ui/styles/android:java_resources",
+    "//components/browser_ui/widget/android:java_resources",
+  ]
+}
+
+android_library_factory("factory_java") {
+  # These deps will be inherited by the resulting android_library target.
+  deps = [
+    ":java",
+    "//chrome/browser/feedback/android:java",
+    "//chrome/browser/profiles/android:java",
+  ]
+
+  # This internal file will be replaced by a generated file so the resulting
+  # android_library target does not actually depend on this internal file.
+  sources = [ "//chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditUiFactory.java" ]
+}
diff --git a/chrome/browser/password_entry_edit/android/credential_edit_bridge.cc b/chrome/browser/password_entry_edit/android/credential_edit_bridge.cc
new file mode 100644
index 0000000000000..2a6be170bf7ce
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/credential_edit_bridge.cc
@@ -0,0 +1,139 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/password_entry_edit/android/credential_edit_bridge.h"
+
+#include <jni.h>
+
+#include <memory>
+
+#include "base/android/jni_android.h"
+#include "base/android/jni_array.h"
+#include "base/android/jni_string.h"
+#include "base/android/scoped_java_ref.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/affiliations/core/browser/affiliation_utils.h"
+#include "components/password_manager/core/browser/password_form.h"
+#include "components/password_manager/core/browser/ui/saved_passwords_presenter.h"
+#include "components/url_formatter/url_formatter.h"
+#include "ui/base/l10n/l10n_util.h"
+
+// Must come after all headers that specialize FromJniType() / ToJniType().
+#include "chrome/browser/password_entry_edit/android/internal/jni/CredentialEditBridge_jni.h"
+
+std::unique_ptr<CredentialEditBridge> CredentialEditBridge::MaybeCreate(
+    const password_manager::CredentialUIEntry credential,
+    IsInsecureCredential is_insecure_credential,
+    std::vector<std::u16string> existing_usernames,
+    password_manager::SavedPasswordsPresenter* saved_passwords_presenter,
+    base::OnceClosure dismissal_callback,
+    const base::android::JavaRef<jobject>& context) {
+  base::android::ScopedJavaGlobalRef<jobject> java_bridge;
+  java_bridge.Reset(Java_CredentialEditBridge_maybeCreate(
+      base::android::AttachCurrentThread()));
+  if (!java_bridge) {
+    return nullptr;
+  }
+  return base::WrapUnique(new CredentialEditBridge(
+      std::move(credential), is_insecure_credential,
+      std::move(existing_usernames), saved_passwords_presenter,
+      std::move(dismissal_callback), context, std::move(java_bridge)));
+}
+
+CredentialEditBridge::CredentialEditBridge(
+    const password_manager::CredentialUIEntry credential,
+    IsInsecureCredential is_insecure_credential,
+    std::vector<std::u16string> existing_usernames,
+    password_manager::SavedPasswordsPresenter* saved_passwords_presenter,
+    base::OnceClosure dismissal_callback,
+    const base::android::JavaRef<jobject>& context,
+    base::android::ScopedJavaGlobalRef<jobject> java_bridge)
+    : credential_(std::move(credential)),
+      is_insecure_credential_(is_insecure_credential),
+      existing_usernames_(std::move(existing_usernames)),
+      saved_passwords_presenter_(saved_passwords_presenter),
+      dismissal_callback_(std::move(dismissal_callback)),
+      java_bridge_(java_bridge) {
+  Java_CredentialEditBridge_initAndLaunchUi(
+      base::android::AttachCurrentThread(), java_bridge_,
+      reinterpret_cast<intptr_t>(this), context, credential.blocked_by_user,
+      credential.federation_origin.IsValid());
+}
+
+CredentialEditBridge::~CredentialEditBridge() {
+  Java_CredentialEditBridge_destroy(base::android::AttachCurrentThread(),
+                                    java_bridge_);
+}
+
+void CredentialEditBridge::GetCredential(JNIEnv* env) {
+  Java_CredentialEditBridge_setCredential(
+      env, java_bridge_, GetDisplayURLOrAppName(), credential_.username,
+      credential_.password, GetDisplayFederationOrigin(),
+      is_insecure_credential_.value());
+}
+
+void CredentialEditBridge::GetExistingUsernames(JNIEnv* env) {
+  Java_CredentialEditBridge_setExistingUsernames(
+      env, java_bridge_,
+      base::android::ToJavaArrayOfStrings(env, existing_usernames_));
+}
+
+void CredentialEditBridge::SaveChanges(JNIEnv* env,
+                                       std::u16string& username,
+                                       std::u16string& password) {
+  password_manager::CredentialUIEntry updated_credential = credential_;
+  updated_credential.username = username;
+  updated_credential.password = password;
+  saved_passwords_presenter_->EditSavedCredentials(credential_,
+                                                   updated_credential);
+}
+
+void CredentialEditBridge::DeleteCredential(JNIEnv* env) {
+  saved_passwords_presenter_->RemoveCredential(credential_);
+  std::move(dismissal_callback_).Run();
+}
+
+void CredentialEditBridge::OnUiDismissed(JNIEnv* env) {
+  std::move(dismissal_callback_).Run();
+}
+
+std::u16string CredentialEditBridge::GetDisplayURLOrAppName() {
+  auto facet = affiliations::FacetURI::FromPotentiallyInvalidSpec(
+      credential_.GetFirstSignonRealm());
+  std::string display_name = credential_.GetDisplayName();
+
+  if (facet.IsValidAndroidFacetURI()) {
+    if (display_name.empty()) {
+      // In case no affiliation information could be obtained show the
+      // formatted package name to the user.
+      return l10n_util::GetStringFUTF16(
+          IDS_SETTINGS_PASSWORDS_ANDROID_APP,
+          base::UTF8ToUTF16(facet.android_package_name()));
+    }
+
+    return base::UTF8ToUTF16(display_name);
+  }
+
+  return url_formatter::FormatUrl(
+      credential_.GetURL().DeprecatedGetOriginAsURL(),
+      url_formatter::kFormatUrlOmitDefaults |
+          url_formatter::kFormatUrlOmitHTTPS |
+          url_formatter::kFormatUrlOmitTrivialSubdomains |
+          url_formatter::kFormatUrlTrimAfterHost,
+      base::UnescapeRule::SPACES, nullptr, nullptr, nullptr);
+}
+
+std::u16string CredentialEditBridge::GetDisplayFederationOrigin() {
+  return credential_.federation_origin.IsValid()
+             ? url_formatter::FormatUrl(
+                   credential_.federation_origin.GetURL(),
+                   url_formatter::kFormatUrlOmitDefaults |
+                       url_formatter::kFormatUrlOmitHTTPS |
+                       url_formatter::kFormatUrlOmitTrivialSubdomains |
+                       url_formatter::kFormatUrlTrimAfterHost,
+                   base::UnescapeRule::SPACES, nullptr, nullptr, nullptr)
+             : std::u16string();
+}
diff --git a/chrome/browser/password_entry_edit/android/credential_edit_bridge.h b/chrome/browser/password_entry_edit/android/credential_edit_bridge.h
new file mode 100644
index 0000000000000..94442e10fc8d9
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/credential_edit_bridge.h
@@ -0,0 +1,96 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_PASSWORD_ENTRY_EDIT_ANDROID_CREDENTIAL_EDIT_BRIDGE_H_
+#define CHROME_BROWSER_PASSWORD_ENTRY_EDIT_ANDROID_CREDENTIAL_EDIT_BRIDGE_H_
+
+#include <jni.h>
+
+#include "base/android/scoped_java_ref.h"
+#include "base/functional/callback_forward.h"
+#include "base/memory/raw_ptr.h"
+#include "components/password_manager/core/browser/ui/credential_ui_entry.h"
+#include "components/password_manager/core/browser/ui/insecure_credentials_manager.h"
+#include "components/password_manager/core/browser/ui/saved_passwords_presenter.h"
+
+// This bridge is responsible for creating and releasing its Java counterpart,
+// in order to launch or dismiss the edit UI.
+class CredentialEditBridge {
+ public:
+  using IsInsecureCredential =
+      base::StrongAlias<class IsInsecureCredentialTag, bool>;
+  // Returns a new bridge if none exists. If a bridge already exitst, it returns
+  // null, since that means the edit UI is already open and it should not be
+  // shared.
+  static std::unique_ptr<CredentialEditBridge> MaybeCreate(
+      const password_manager::CredentialUIEntry credential,
+      IsInsecureCredential is_insecure_credential,
+      std::vector<std::u16string> existing_usernames,
+      password_manager::SavedPasswordsPresenter* saved_passwords_presenter,
+      base::OnceClosure dismissal_callback,
+      const base::android::JavaRef<jobject>& context);
+  ~CredentialEditBridge();
+
+  CredentialEditBridge(const CredentialEditBridge&) = delete;
+  CredentialEditBridge& operator=(const CredentialEditBridge&) = delete;
+
+  // Called by Java to get the credential to be edited.
+  void GetCredential(JNIEnv* env);
+
+  // Called by Java to get the existing usernames.
+  void GetExistingUsernames(JNIEnv* env);
+
+  // Called by Java to save the changes to the edited credential.
+  void SaveChanges(JNIEnv* env,
+                   std::u16string& username,
+                   std::u16string& password);
+
+  // Called by Java to remove the credential from the store.
+  void DeleteCredential(JNIEnv* env);
+
+  // Called by Java to signal that the UI was dismissed.
+  void OnUiDismissed(JNIEnv* env);
+
+ private:
+  CredentialEditBridge(
+      const password_manager::CredentialUIEntry credential,
+      IsInsecureCredential is_insecure_credential,
+      std::vector<std::u16string> existing_usernames,
+      password_manager::SavedPasswordsPresenter* saved_passwords_presenter,
+      base::OnceClosure dismissal_callback,
+      const base::android::JavaRef<jobject>& context,
+      base::android::ScopedJavaGlobalRef<jobject> java_bridge);
+
+  // Returns the URL or app for which the credential was saved, formatted
+  // for display.
+  std::u16string GetDisplayURLOrAppName();
+
+  // If the credential to be edited is a federated credential, it returns
+  // the identity provider formatted for display. Otherwise, it returns an empty
+  // string.
+  std::u16string GetDisplayFederationOrigin();
+
+  // The credential to be edited.
+  const password_manager::CredentialUIEntry credential_;
+
+  // Whether the credential being edited is an insecure credential. Used to
+  // customize the deletion confirmation dialog string.
+  IsInsecureCredential is_insecure_credential_;
+
+  // All the usernames saved for the current site/app.
+  std::vector<std::u16string> existing_usernames_;
+
+  // The backend to route the edit event to. Should be owned by the the owner of
+  // the bridge.
+  raw_ptr<password_manager::SavedPasswordsPresenter>
+      saved_passwords_presenter_ = nullptr;
+
+  // Callback invoked when the UI is being dismissed from the Java side.
+  base::OnceClosure dismissal_callback_;
+
+  // The corresponding java object.
+  base::android::ScopedJavaGlobalRef<jobject> java_bridge_;
+};
+
+#endif  // CHROME_BROWSER_PASSWORD_ENTRY_EDIT_ANDROID_CREDENTIAL_EDIT_BRIDGE_H_
diff --git a/chrome/browser/password_entry_edit/android/internal/BUILD.gn b/chrome/browser/password_entry_edit/android/internal/BUILD.gn
new file mode 100644
index 0000000000000..a7baeef08ea14
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/BUILD.gn
@@ -0,0 +1,98 @@
+# Copyright 2021 The Chromium Authors
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/android/rules.gni")
+import("//third_party/jni_zero/jni_zero.gni")
+
+generate_jni("jni") {
+  sources = [ "java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditBridge.java" ]
+}
+
+android_library("java") {
+  visibility = [
+    ":*",
+    "//chrome/android:chrome_all_java",
+  ]
+
+  srcjar_deps = [ ":jni" ]
+  sources = [
+    "java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialViewBinder.java",
+    "java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditBridge.java",
+    "java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditCoordinator.java",
+    "java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditMediator.java",
+    "java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditProperties.java",
+    "java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditUiFactory.java",
+    "java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewBinder.java",
+    "java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialViewBinder.java",
+  ]
+
+  deps = [
+    "//base:base_java",
+    "//build/android:build_java",
+    "//chrome/browser/feedback/android:factory_java",
+    "//chrome/browser/feedback/android:java",
+    "//chrome/browser/feedback/android:java_resources",
+    "//chrome/browser/password_entry_edit/android:java",
+    "//chrome/browser/password_manager/android:java",
+    "//chrome/browser/profiles/android:java",
+    "//chrome/browser/settings:factory_java",
+    "//chrome/browser/ui/android/strings:ui_strings_grd",
+    "//components/browser_ui/settings/android:java",
+    "//third_party/androidx:androidx_annotation_annotation_java",
+    "//third_party/androidx:androidx_fragment_fragment_java",
+    "//third_party/androidx:androidx_preference_preference_java",
+    "//third_party/jni_zero:jni_zero_java",
+    "//ui/android:ui_no_recycler_view_java",
+  ]
+  resources_package = "org.chromium.chrome.browser.password_entry_edit"
+}
+
+robolectric_library("junit") {
+  resources_package = "org.chromium.chrome.browser.password_entry_edit"
+  sources = [ "java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditControllerTest.java" ]
+
+  deps = [
+    ":java",
+    "//base:base_java",
+    "//base:base_java_test_support",
+    "//base:base_junit_test_support",
+    "//chrome/browser/password_entry_edit/android:java",
+    "//chrome/browser/password_entry_edit/android:java_resources",
+    "//chrome/browser/password_manager/android:java",
+    "//chrome/browser/ui/android/strings:ui_strings_grd",
+    "//third_party/android_deps:espresso_java",
+    "//third_party/androidx:androidx_test_core_java",
+    "//third_party/hamcrest:hamcrest_java",
+    "//third_party/hamcrest:hamcrest_library_java",
+    "//third_party/junit",
+    "//third_party/mockito:mockito_java",
+    "//ui/android:ui_no_recycler_view_java",
+  ]
+}
+
+android_library("javatests") {
+  testonly = true
+  resources_package = "org.chromium.chrome.browser.password_entry_edit"
+  sources = [ "java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewTest.java" ]
+
+  deps = [
+    ":java",
+    "//base:base_java_test_support",
+    "//chrome/android:chrome_java",
+    "//chrome/browser/feedback/android:java",
+    "//chrome/browser/flags:java",
+    "//chrome/browser/password_entry_edit/android:java",
+    "//chrome/browser/password_entry_edit/android:java_resources",
+    "//chrome/browser/profiles/android:java",
+    "//chrome/browser/settings:test_support_java",
+    "//chrome/test/android:chrome_java_integration_test_support",
+    "//content/public/test/android:content_java_test_support",
+    "//third_party/android_deps:material_design_java",
+    "//third_party/androidx:androidx_test_runner_java",
+    "//third_party/hamcrest:hamcrest_java",
+    "//third_party/junit",
+    "//third_party/mockito:mockito_java",
+    "//ui/android:ui_no_recycler_view_java",
+  ]
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialViewBinder.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialViewBinder.java
new file mode 100644
index 0000000000000..819c0eb19710c
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialViewBinder.java
@@ -0,0 +1,44 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.FEDERATION_ORIGIN;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD_VISIBLE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_ACTION_HANDLER;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_DISMISSED_BY_NATIVE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.URL_OR_APP;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.USERNAME;
+
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.ui.modelutil.PropertyKey;
+import org.chromium.ui.modelutil.PropertyModel;
+
+/**
+ * Maps {@link CredentialEditProperties} changes in a {@link PropertyModel} to the suitable methods
+ * in {@link BlockedCredentialFragmentView}.
+ */
+@NullMarked
+public class BlockedCredentialViewBinder {
+    static void bindBlockedCredentialView(
+            PropertyModel model,
+            BlockedCredentialFragmentView fragmentView,
+            PropertyKey propertyKey) {
+        if (propertyKey == UI_ACTION_HANDLER) {
+            fragmentView.setUiActionHandler(model.get(UI_ACTION_HANDLER));
+        } else if (propertyKey == URL_OR_APP) {
+            fragmentView.setUrlOrApp(model.get(URL_OR_APP));
+        } else if (propertyKey == UI_DISMISSED_BY_NATIVE) {
+            fragmentView.dismiss();
+        } else if (propertyKey == FEDERATION_ORIGIN
+                || propertyKey == USERNAME
+                || propertyKey == PASSWORD
+                || propertyKey == PASSWORD_VISIBLE) {
+            // These properties are not relevant for the blocked credential view.
+        } else {
+            assert false : "Unhandled update to property: " + propertyKey;
+        }
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditBridge.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditBridge.java
new file mode 100644
index 0000000000000..3a020b17425c6
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditBridge.java
@@ -0,0 +1,143 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static org.chromium.build.NullUtil.assumeNonNull;
+
+import android.content.Context;
+
+import org.jni_zero.CalledByNative;
+import org.jni_zero.JniType;
+import org.jni_zero.NativeMethods;
+
+import org.chromium.build.annotations.MonotonicNonNull;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEditCoordinator.CredentialActionDelegate;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEditCoordinator.UiDismissalHandler;
+import org.chromium.chrome.browser.settings.SettingsNavigationFactory;
+import org.chromium.components.browser_ui.settings.SettingsNavigation;
+
+/**
+ * Class mediating the communication between the credential edit UI and the C++ part responsible for
+ * saving the changes.
+ */
+@NullMarked
+class CredentialEditBridge implements UiDismissalHandler, CredentialActionDelegate {
+    private static @Nullable CredentialEditBridge sCredentialEditBridge;
+
+    private long mNativeCredentialEditBridge;
+    private @MonotonicNonNull CredentialEditCoordinator mCoordinator;
+
+    static @Nullable CredentialEditBridge get() {
+        return sCredentialEditBridge;
+    }
+
+    private CredentialEditBridge() {}
+
+    @CalledByNative
+    static @Nullable CredentialEditBridge maybeCreate() {
+        // There can only be one bridge at a time and it shouldn't be shared.
+        if (sCredentialEditBridge != null) return null;
+        sCredentialEditBridge = new CredentialEditBridge();
+        return sCredentialEditBridge;
+    }
+
+    @CalledByNative
+    void initAndLaunchUi(
+            long nativeCredentialEditBridge,
+            Context context,
+            boolean isBlockedCredential,
+            boolean isFederatedCredential) {
+        mNativeCredentialEditBridge = nativeCredentialEditBridge;
+        SettingsNavigation settingsNavigation =
+                SettingsNavigationFactory.createSettingsNavigation();
+        if (isBlockedCredential) {
+            settingsNavigation.startSettings(context, BlockedCredentialFragmentView.class);
+            return;
+        }
+        if (isFederatedCredential) {
+            settingsNavigation.startSettings(context, FederatedCredentialFragmentView.class);
+            return;
+        }
+        settingsNavigation.startSettings(context, CredentialEditFragmentView.class);
+    }
+
+    public void initialize(CredentialEditCoordinator coordinator) {
+        mCoordinator = coordinator;
+        // This will result in setCredential being called from native with the required data.
+        CredentialEditBridgeJni.get().getCredential(mNativeCredentialEditBridge);
+
+        // This will result in setExistingUsernames being called from native with the required data.
+        CredentialEditBridgeJni.get().getExistingUsernames(mNativeCredentialEditBridge);
+    }
+
+    @CalledByNative
+    void setCredential(
+            @JniType("std::u16string") String displayUrlOrAppName,
+            @JniType("std::u16string") String username,
+            @JniType("std::u16string") String password,
+            @JniType("std::u16string") String displayFederationOrigin,
+            boolean isInsecureCredential) {
+        assumeNonNull(mCoordinator);
+        mCoordinator.setCredential(
+                displayUrlOrAppName,
+                username,
+                password,
+                displayFederationOrigin,
+                isInsecureCredential);
+    }
+
+    @CalledByNative
+    void setExistingUsernames(String[] existingUsernames) {
+        assumeNonNull(mCoordinator);
+        mCoordinator.setExistingUsernames(existingUsernames);
+    }
+
+    // This can be called either before or after the native counterpart has gone away, depending
+    // on where the edit component is being destroyed from.
+    @Override
+    public void onUiDismissed() {
+        if (mNativeCredentialEditBridge != 0) {
+            CredentialEditBridgeJni.get().onUiDismissed(mNativeCredentialEditBridge);
+        }
+        mNativeCredentialEditBridge = 0;
+        sCredentialEditBridge = null;
+    }
+
+    @Override
+    public void saveChanges(String username, String password) {
+        if (mNativeCredentialEditBridge == 0) return;
+        CredentialEditBridgeJni.get().saveChanges(mNativeCredentialEditBridge, username, password);
+    }
+
+    @Override
+    public void deleteCredential() {
+        CredentialEditBridgeJni.get().deleteCredential(mNativeCredentialEditBridge);
+    }
+
+    @CalledByNative
+    void destroy() {
+        if (mCoordinator != null) mCoordinator.dismiss();
+        mNativeCredentialEditBridge = 0;
+        sCredentialEditBridge = null;
+    }
+
+    @NativeMethods
+    interface Natives {
+        void getCredential(long nativeCredentialEditBridge);
+
+        void getExistingUsernames(long nativeCredentialEditBridge);
+
+        void saveChanges(
+                long nativeCredentialEditBridge,
+                @JniType("std::u16string") String username,
+                @JniType("std::u16string") String password);
+
+        void deleteCredential(long nativeCredentialEditBridge);
+
+        void onUiDismissed(long nativeCredentialEditBridge);
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditControllerTest.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditControllerTest.java
new file mode 100644
index 0000000000000..5262a5d2c6ddf
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditControllerTest.java
@@ -0,0 +1,410 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static androidx.test.espresso.matcher.ViewMatchers.assertThat;
+
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.BLOCKED_CREDENTIAL_ACTION_HISTOGRAM;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.FEDERATED_CREDENTIAL_ACTION_HISTOGRAM;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.SAVED_PASSWORD_ACTION_HISTOGRAM;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.ALL_KEYS;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.DUPLICATE_USERNAME_ERROR;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.EMPTY_PASSWORD_ERROR;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.FEDERATION_ORIGIN;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD_VISIBLE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_ACTION_HANDLER;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_DISMISSED_BY_NATIVE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.URL_OR_APP;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.USERNAME;
+
+import android.content.ClipData;
+import android.content.ClipboardManager;
+import android.content.Context;
+import android.content.res.Resources;
+import android.os.PersistableBundle;
+
+import androidx.test.core.app.ApplicationProvider;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+import org.robolectric.annotation.Config;
+
+import org.chromium.base.Callback;
+import org.chromium.base.metrics.RecordHistogram;
+import org.chromium.base.test.BaseRobolectricTestRunner;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEditCoordinator.CredentialActionDelegate;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction;
+import org.chromium.chrome.browser.password_manager.ConfirmationDialogHelper;
+import org.chromium.chrome.browser.password_manager.settings.PasswordAccessReauthenticationHelper;
+import org.chromium.chrome.browser.password_manager.settings.PasswordAccessReauthenticationHelper.ReauthReason;
+import org.chromium.ui.base.Clipboard;
+import org.chromium.ui.modelutil.PropertyModel;
+
+/** Tests verifying that the credential edit mediator modifies the model correctly. */
+@RunWith(BaseRobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class CredentialEditControllerTest {
+    private static final String TEST_URL = "https://m.a.xyz/signin";
+    private static final String TEST_USERNAME = "TestUsername";
+    private static final String NEW_TEST_USERNAME = "TestNewUsername";
+    private static final String TEST_PASSWORD = "TestPassword";
+    private static final String NEW_TEST_PASSWORD = "TestNewPassword";
+
+    @Rule public final MockitoRule mMockitoRule = MockitoJUnit.rule();
+    @Mock private PasswordAccessReauthenticationHelper mReauthenticationHelper;
+
+    @Mock private ConfirmationDialogHelper mDeleteDialogHelper;
+
+    @Mock private CredentialActionDelegate mCredentialActionDelegate;
+
+    @Mock private Runnable mHelpLauncher;
+
+    CredentialEditMediator mMediator;
+    PropertyModel mModel;
+
+    private void verifyTheClipdataContainSensitiveExtra(ClipData clipData) {
+        PersistableBundle extras = clipData.getDescription().getExtras();
+        assertTrue(extras.getBoolean("android.content.extra.IS_SENSITIVE"));
+    }
+
+    @Before
+    public void setUp() {
+        Clipboard.resetForTesting();
+        mMediator =
+                new CredentialEditMediator(
+                        mReauthenticationHelper,
+                        mDeleteDialogHelper,
+                        mCredentialActionDelegate,
+                        mHelpLauncher,
+                        false);
+        mModel =
+                new PropertyModel.Builder(ALL_KEYS)
+                        .with(UI_ACTION_HANDLER, mMediator)
+                        .with(URL_OR_APP, TEST_URL)
+                        .with(FEDERATION_ORIGIN, "")
+                        .build();
+        mMediator.initialize(mModel);
+    }
+
+    @Test
+    public void testSetsCredential() {
+        mMediator.setCredential(TEST_USERNAME, TEST_PASSWORD, false);
+        assertEquals(TEST_USERNAME, mModel.get(USERNAME));
+        assertEquals(TEST_PASSWORD, mModel.get(PASSWORD));
+        assertFalse(mModel.get(PASSWORD_VISIBLE));
+    }
+
+    @Test
+    public void testDismissPropagatesToTheModel() {
+        mMediator.dismiss();
+        assertTrue(mModel.get(UI_DISMISSED_BY_NATIVE));
+    }
+
+    @Test
+    public void testMaskingWithoutReauth() {
+        mModel.set(PASSWORD_VISIBLE, true);
+        mMediator.onMaskOrUnmaskPassword();
+        verify(mReauthenticationHelper, never()).canReauthenticate();
+        verify(mReauthenticationHelper, never()).reauthenticate(anyInt(), any(Callback.class));
+    }
+
+    @Test
+    public void testCannotReauthPromptsToast() {
+        when(mReauthenticationHelper.canReauthenticate()).thenReturn(false);
+        mModel.set(PASSWORD_VISIBLE, false);
+        mMediator.onMaskOrUnmaskPassword();
+        verify(mReauthenticationHelper).showScreenLockToast(eq(ReauthReason.VIEW_PASSWORD));
+        verify(mReauthenticationHelper, never()).reauthenticate(anyInt(), any(Callback.class));
+    }
+
+    @Test
+    public void testUnmaskTriggersReauthenticate() {
+        when(mReauthenticationHelper.canReauthenticate()).thenReturn(true);
+        mModel.set(PASSWORD_VISIBLE, false);
+        mMediator.onMaskOrUnmaskPassword();
+        verify(mReauthenticationHelper)
+                .reauthenticate(eq(ReauthReason.VIEW_PASSWORD), any(Callback.class));
+    }
+
+    @Test
+    public void testCannotUnmaskIfReauthFailed() {
+        when(mReauthenticationHelper.canReauthenticate()).thenReturn(true);
+        mModel.set(PASSWORD_VISIBLE, false);
+        doAnswer(
+                        (invocation) -> {
+                            Callback callback = (Callback) invocation.getArguments()[1];
+                            callback.onResult(false);
+                            return null;
+                        })
+                .when(mReauthenticationHelper)
+                .reauthenticate(eq(ReauthReason.VIEW_PASSWORD), any(Callback.class));
+        mMediator.onMaskOrUnmaskPassword();
+        verify(mReauthenticationHelper)
+                .reauthenticate(eq(ReauthReason.VIEW_PASSWORD), any(Callback.class));
+        assertFalse(mModel.get(PASSWORD_VISIBLE));
+    }
+
+    @Test
+    public void testCopyPasswordTriggersReauth() {
+        when(mReauthenticationHelper.canReauthenticate()).thenReturn(true);
+        mMediator.onCopyPassword(ApplicationProvider.getApplicationContext());
+        verify(mReauthenticationHelper)
+                .reauthenticate(eq(ReauthReason.COPY_PASSWORD), any(Callback.class));
+    }
+
+    @Test
+    public void testCantCopyPasswordIfReauthFails() {
+        mModel.set(PASSWORD, TEST_PASSWORD);
+        when(mReauthenticationHelper.canReauthenticate()).thenReturn(true);
+        doAnswer(
+                        (invocation) -> {
+                            Callback callback = (Callback) invocation.getArguments()[1];
+                            callback.onResult(false);
+                            return null;
+                        })
+                .when(mReauthenticationHelper)
+                .reauthenticate(eq(ReauthReason.COPY_PASSWORD), any(Callback.class));
+
+        Context context = ApplicationProvider.getApplicationContext();
+        mMediator.onCopyPassword(context);
+
+        verify(mReauthenticationHelper)
+                .reauthenticate(eq(ReauthReason.COPY_PASSWORD), any(Callback.class));
+        ClipboardManager clipboard =
+                (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
+        assertNull(clipboard.getPrimaryClip());
+    }
+
+    @Test
+    public void testCanCopyPasswordIfReauthSucceeds() {
+        mModel.set(PASSWORD, TEST_PASSWORD);
+        when(mReauthenticationHelper.canReauthenticate()).thenReturn(true);
+        doAnswer(
+                        (invocation) -> {
+                            Callback callback = (Callback) invocation.getArguments()[1];
+                            callback.onResult(true);
+                            return null;
+                        })
+                .when(mReauthenticationHelper)
+                .reauthenticate(eq(ReauthReason.COPY_PASSWORD), any(Callback.class));
+        Context context = ApplicationProvider.getApplicationContext();
+        mMediator.onCopyPassword(context);
+
+        verify(mReauthenticationHelper)
+                .reauthenticate(eq(ReauthReason.COPY_PASSWORD), any(Callback.class));
+        ClipboardManager clipboard =
+                (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
+        assertNotNull(clipboard.getPrimaryClip());
+        assertEquals(TEST_PASSWORD, clipboard.getPrimaryClip().getItemAt(0).getText());
+        verifyTheClipdataContainSensitiveExtra(clipboard.getPrimaryClip());
+    }
+
+    @Test
+    public void callsTheDelegateWithCorrectDataWhenSaving() {
+        mModel.set(USERNAME, TEST_USERNAME);
+        mModel.set(PASSWORD, TEST_PASSWORD);
+        mMediator.onSave();
+        verify(mCredentialActionDelegate).saveChanges(TEST_USERNAME, TEST_PASSWORD);
+    }
+
+    @Test
+    public void testUsernameTextChangedUpdatesModel() {
+        mMediator.setCredential(TEST_USERNAME, TEST_PASSWORD, false);
+        mMediator.setExistingUsernames(new String[] {TEST_USERNAME});
+        mMediator.onUsernameTextChanged(NEW_TEST_USERNAME);
+        assertEquals(NEW_TEST_USERNAME, mModel.get(USERNAME));
+    }
+
+    @Test
+    public void testPasswordTextChangedUpdatesModel() {
+        mMediator.setCredential(TEST_USERNAME, TEST_PASSWORD, false);
+        mMediator.onPasswordTextChanged(NEW_TEST_PASSWORD);
+        assertEquals(NEW_TEST_PASSWORD, mModel.get(PASSWORD));
+    }
+
+    @Test
+    public void testEmptyPasswordTriggersError() {
+        mMediator.setCredential(TEST_USERNAME, TEST_PASSWORD, false);
+        mMediator.onPasswordTextChanged("");
+        assertTrue(mModel.get(EMPTY_PASSWORD_ERROR));
+
+        mMediator.onPasswordTextChanged(TEST_PASSWORD);
+        assertFalse(mModel.get(EMPTY_PASSWORD_ERROR));
+    }
+
+    @Test
+    public void testDuplicateUsernameTriggersError() {
+        mMediator.setCredential(TEST_USERNAME, TEST_PASSWORD, false);
+        mMediator.setExistingUsernames(new String[] {TEST_USERNAME, NEW_TEST_USERNAME});
+
+        mMediator.onUsernameTextChanged(NEW_TEST_USERNAME);
+        assertTrue(mModel.get(DUPLICATE_USERNAME_ERROR));
+
+        mMediator.onUsernameTextChanged(TEST_USERNAME);
+        assertFalse(mModel.get(DUPLICATE_USERNAME_ERROR));
+    }
+
+    @Test
+    public void testDeletingCredentialPromptsConfirmation() {
+        mMediator.setCredential(TEST_USERNAME, TEST_PASSWORD, false);
+        Resources resources = ApplicationProvider.getApplicationContext().getResources();
+        when(mDeleteDialogHelper.getResources()).thenReturn(resources);
+
+        String title =
+                resources.getString(R.string.password_entry_edit_delete_credential_dialog_title);
+        String message =
+                resources.getString(R.string.password_entry_edit_deletion_dialog_body, TEST_URL);
+        String confirmButtonText =
+                resources.getString(R.string.password_entry_edit_delete_credential_dialog_confirm);
+        doAnswer(
+                        (invocation) -> {
+                            Runnable callback = (Runnable) invocation.getArguments()[3];
+                            callback.run();
+                            return null;
+                        })
+                .when(mDeleteDialogHelper)
+                .showConfirmation(
+                        eq(title), eq(message), eq(confirmButtonText), any(Runnable.class));
+
+        mMediator.onDelete();
+
+        verify(mDeleteDialogHelper)
+                .showConfirmation(
+                        eq(title), eq(message), eq(confirmButtonText), any(Runnable.class));
+        verify(mCredentialActionDelegate).deleteCredential();
+
+        assertThat(
+                RecordHistogram.getHistogramValueCountForTesting(
+                        SAVED_PASSWORD_ACTION_HISTOGRAM, CredentialEntryAction.DELETED),
+                is(1));
+    }
+
+    @Test
+    public void testDeletingCompromisedCredentialPromptsCorrectMessage() {
+        mMediator.setCredential(TEST_USERNAME, TEST_PASSWORD, true);
+        Resources resources = ApplicationProvider.getApplicationContext().getResources();
+        when(mDeleteDialogHelper.getResources()).thenReturn(resources);
+
+        String title =
+                resources.getString(R.string.password_entry_edit_delete_credential_dialog_title);
+        String message =
+                resources.getString(
+                        R.string.password_check_delete_credential_dialog_body, TEST_URL);
+        String confirmButtonText =
+                resources.getString(R.string.password_entry_edit_delete_credential_dialog_confirm);
+
+        mMediator.onDelete();
+        verify(mDeleteDialogHelper)
+                .showConfirmation(
+                        eq(title), eq(message), eq(confirmButtonText), any(Runnable.class));
+    }
+
+    @Test
+    public void testDeletingFederatedCredentialPromptsConfirmation() {
+        initMediatorWithFederatedCredential();
+        mMediator.setCredential(TEST_USERNAME, "", false);
+        Resources resources = ApplicationProvider.getApplicationContext().getResources();
+        when(mDeleteDialogHelper.getResources()).thenReturn(resources);
+
+        String title =
+                resources.getString(R.string.password_entry_edit_delete_credential_dialog_title);
+        String message =
+                resources.getString(R.string.password_entry_edit_deletion_dialog_body, TEST_URL);
+        String confirmButtonText =
+                resources.getString(R.string.password_entry_edit_delete_credential_dialog_confirm);
+
+        doAnswer(
+                        (invocation) -> {
+                            Runnable callback = (Runnable) invocation.getArguments()[3];
+                            callback.run();
+                            return null;
+                        })
+                .when(mDeleteDialogHelper)
+                .showConfirmation(
+                        eq(title), eq(message), eq(confirmButtonText), any(Runnable.class));
+
+        mMediator.onDelete();
+
+        verify(mDeleteDialogHelper)
+                .showConfirmation(
+                        eq(title), eq(message), eq(confirmButtonText), any(Runnable.class));
+        verify(mCredentialActionDelegate).deleteCredential();
+
+        assertThat(
+                RecordHistogram.getHistogramValueCountForTesting(
+                        FEDERATED_CREDENTIAL_ACTION_HISTOGRAM, CredentialEntryAction.DELETED),
+                is(1));
+    }
+
+    @Test
+    public void testDeletingBlockedCredentialDoesntPromptDialog() {
+        mMediator =
+                new CredentialEditMediator(
+                        mReauthenticationHelper,
+                        mDeleteDialogHelper,
+                        mCredentialActionDelegate,
+                        mHelpLauncher,
+                        true);
+        mModel =
+                new PropertyModel.Builder(ALL_KEYS)
+                        .with(UI_ACTION_HANDLER, mMediator)
+                        .with(URL_OR_APP, TEST_URL)
+                        .with(FEDERATION_ORIGIN, "")
+                        .build();
+        mMediator.initialize(mModel);
+
+        mMediator.onDelete();
+
+        verify(mDeleteDialogHelper, never()).getResources();
+        verify(mDeleteDialogHelper, never())
+                .showConfirmation(
+                        any(String.class),
+                        any(String.class),
+                        any(String.class),
+                        any(Runnable.class));
+        verify(mCredentialActionDelegate).deleteCredential();
+
+        assertThat(
+                RecordHistogram.getHistogramValueCountForTesting(
+                        BLOCKED_CREDENTIAL_ACTION_HISTOGRAM, CredentialEntryAction.DELETED),
+                is(1));
+    }
+
+    private void initMediatorWithFederatedCredential() {
+        mModel =
+                new PropertyModel.Builder(ALL_KEYS)
+                        .with(UI_ACTION_HANDLER, mMediator)
+                        .with(URL_OR_APP, TEST_URL)
+                        .with(FEDERATION_ORIGIN, "accounts.example.com")
+                        .build();
+        mMediator.initialize(mModel);
+    }
+
+    @Test
+    public void testHandleHelpCallsHelpLauncher() {
+        mMediator.handleHelp();
+        verify(mHelpLauncher).run();
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditCoordinator.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditCoordinator.java
new file mode 100644
index 0000000000000..07fa9f6a74a42
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditCoordinator.java
@@ -0,0 +1,142 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.ALL_KEYS;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.FEDERATION_ORIGIN;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_ACTION_HANDLER;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.URL_OR_APP;
+
+import org.chromium.build.annotations.Initializer;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.chrome.browser.feedback.HelpAndFeedbackLauncherFactory;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEntryFragmentViewBase.ComponentStateDelegate;
+import org.chromium.chrome.browser.password_manager.ConfirmationDialogHelper;
+import org.chromium.chrome.browser.password_manager.settings.PasswordAccessReauthenticationHelper;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.ui.modelutil.PropertyModel;
+import org.chromium.ui.modelutil.PropertyModelChangeProcessor;
+
+/** Creates the credential edit UI and is responsible for managing it. */
+@NullMarked
+class CredentialEditCoordinator implements ComponentStateDelegate {
+    private final Profile mProfile;
+    private final CredentialEntryFragmentViewBase mFragmentView;
+    private final PasswordAccessReauthenticationHelper mReauthenticationHelper;
+    private final CredentialEditMediator mMediator;
+    private final UiDismissalHandler mDismissalHandler;
+
+    private PropertyModel mModel;
+
+    interface UiDismissalHandler {
+        /** Issued when the Ui is being permanently dismissed. */
+        void onUiDismissed();
+    }
+
+    interface CredentialActionDelegate {
+        /** Called when the user has decided to save the changes to the credential. */
+        void saveChanges(String username, String password);
+
+        /** Called when the user has confirmed the credential deletion. */
+        void deleteCredential();
+    }
+
+    CredentialEditCoordinator(
+            Profile profile,
+            CredentialEntryFragmentViewBase fragmentView,
+            UiDismissalHandler dismissalHandler,
+            CredentialActionDelegate credentialActionDelegate) {
+        mProfile = profile;
+        mFragmentView = fragmentView;
+        mReauthenticationHelper =
+                new PasswordAccessReauthenticationHelper(
+                        fragmentView.getActivity(), fragmentView.getParentFragmentManager());
+        mMediator =
+                new CredentialEditMediator(
+                        mReauthenticationHelper,
+                        new ConfirmationDialogHelper(mFragmentView.getContext()),
+                        credentialActionDelegate,
+                        this::handleHelp,
+                        fragmentView instanceof BlockedCredentialFragmentView);
+        mDismissalHandler = dismissalHandler;
+        mFragmentView.setComponentStateDelegate(this);
+    }
+
+    @Initializer
+    void setCredential(
+            String displayUrlOrAppName,
+            String username,
+            String password,
+            String displayFederationOrigin,
+            boolean isInsecureCredential) {
+        mModel =
+                new PropertyModel.Builder(ALL_KEYS)
+                        .with(URL_OR_APP, displayUrlOrAppName)
+                        .with(FEDERATION_ORIGIN, displayFederationOrigin)
+                        .build();
+        mMediator.initialize(mModel);
+        mMediator.setCredential(username, password, isInsecureCredential);
+    }
+
+    @Initializer
+    void setExistingUsernames(String[] existingUsernames) {
+        mMediator.setExistingUsernames(existingUsernames);
+    }
+
+    void dismiss() {
+        mMediator.dismiss();
+    }
+
+    void handleHelp() {
+        HelpAndFeedbackLauncherFactory.getForProfile(mProfile)
+                .show(
+                        mFragmentView.getActivity(),
+                        mFragmentView.getActivity().getString(R.string.help_context_passwords),
+                        null);
+    }
+
+    @Override
+    public void onStartFragment() {
+        CredentialEditCoordinator.setupModelChangeProcessor(mModel, mFragmentView);
+        mModel.set(UI_ACTION_HANDLER, mMediator);
+    }
+
+    @Override
+    public void onResumeFragment() {
+        mReauthenticationHelper.onReauthenticationMaybeHappened();
+    }
+
+    @Override
+    public void onDestroy() {
+        mDismissalHandler.onUiDismissed();
+    }
+
+    static void setupModelChangeProcessor(
+            PropertyModel model, CredentialEntryFragmentViewBase view) {
+        if (view instanceof CredentialEditFragmentView) {
+            PropertyModelChangeProcessor.create(
+                    model,
+                    (CredentialEditFragmentView) view,
+                    CredentialEditViewBinder::bindCredentialEditView);
+            return;
+        }
+
+        if (view instanceof BlockedCredentialFragmentView) {
+            PropertyModelChangeProcessor.create(
+                    model,
+                    (BlockedCredentialFragmentView) view,
+                    BlockedCredentialViewBinder::bindBlockedCredentialView);
+            return;
+        }
+
+        if (view instanceof FederatedCredentialFragmentView) {
+            PropertyModelChangeProcessor.create(
+                    model,
+                    (FederatedCredentialFragmentView) view,
+                    FederatedCredentialViewBinder::bindFederatedCredentialView);
+            return;
+        }
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditMediator.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditMediator.java
new file mode 100644
index 0000000000000..d4f35be25062b
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditMediator.java
@@ -0,0 +1,328 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEditError.DUPLICATE_USERNAME;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEditError.EMPTY_PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEditError.ERROR_COUNT;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction.ACTION_COUNT;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction.COPIED_PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction.COPIED_USERNAME;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction.DELETED;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction.EDITED_PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction.EDITED_USERNAME;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction.EDITED_USERNAME_AND_PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction.MASKED_PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditMediator.CredentialEntryAction.UNMASKED_PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.DUPLICATE_USERNAME_ERROR;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.EMPTY_PASSWORD_ERROR;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.FEDERATION_ORIGIN;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD_VISIBLE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_DISMISSED_BY_NATIVE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.URL_OR_APP;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.USERNAME;
+
+import android.content.Context;
+import android.content.res.Resources;
+
+import androidx.annotation.IntDef;
+
+import org.chromium.base.Callback;
+import org.chromium.base.metrics.RecordHistogram;
+import org.chromium.build.annotations.Initializer;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEditCoordinator.CredentialActionDelegate;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEntryFragmentViewBase.UiActionHandler;
+import org.chromium.chrome.browser.password_manager.ConfirmationDialogHelper;
+import org.chromium.chrome.browser.password_manager.settings.PasswordAccessReauthenticationHelper;
+import org.chromium.chrome.browser.password_manager.settings.PasswordAccessReauthenticationHelper.ReauthReason;
+import org.chromium.ui.base.Clipboard;
+import org.chromium.ui.modelutil.PropertyModel;
+import org.chromium.ui.widget.Toast;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Contains the logic for the edit component. It  updates the model when needed and reacts to UI
+ * events (e.g. button clicks).
+ */
+@NullMarked
+public class CredentialEditMediator implements UiActionHandler {
+    static final String SAVED_PASSWORD_ACTION_HISTOGRAM =
+            "PasswordManager.CredentialEntryActions.SavedPassword";
+    static final String FEDERATED_CREDENTIAL_ACTION_HISTOGRAM =
+            "PasswordManager.CredentialEntryActions.FederatedCredential";
+    static final String BLOCKED_CREDENTIAL_ACTION_HISTOGRAM =
+            "PasswordManager.CredentialEntryActions.BlockedCredential";
+    private final PasswordAccessReauthenticationHelper mReauthenticationHelper;
+    private final ConfirmationDialogHelper mDeleteDialogHelper;
+    private final CredentialActionDelegate mCredentialActionDelegate;
+    private final Runnable mHelpLauncher;
+    private final boolean mIsBlockedCredential;
+    private PropertyModel mModel;
+    private String mOriginalUsername;
+    private String mOriginalPassword;
+    private boolean mIsInsecureCredential;
+    private Set<String> mExistingUsernames;
+
+    /**
+     * The action that the user takes within the credential entry UI.
+     *
+     * These values are persisted to logs. Entries should not be renumbered and
+     * numeric values should never be reused.
+     */
+    @IntDef({
+        DELETED,
+        COPIED_USERNAME,
+        UNMASKED_PASSWORD,
+        MASKED_PASSWORD,
+        COPIED_PASSWORD,
+        EDITED_USERNAME,
+        EDITED_PASSWORD,
+        EDITED_USERNAME_AND_PASSWORD,
+        ACTION_COUNT
+    })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface CredentialEntryAction {
+        /**
+         * The credential entry was deleted. Recorded after the user confirms it, when a
+         * confirmation dialog is prompted.
+         */
+        int DELETED = 0;
+
+        /** The username was copied. */
+        int COPIED_USERNAME = 1;
+
+        /** The password was unmasked. Recorded after successful reauth is one was performed. */
+        int UNMASKED_PASSWORD = 2;
+
+        /** The password was masked. */
+        int MASKED_PASSWORD = 3;
+
+        /** The password was copied. Recorded after successful reauth is one was performed. */
+        int COPIED_PASSWORD = 4;
+
+        /** The username was edited. Recorded after the user presses the save button". */
+        int EDITED_USERNAME = 5;
+
+        /** The password was edited. Recorded after the user presses the save button". */
+        int EDITED_PASSWORD = 6;
+
+        /**
+         * Both username and password were edited. Recorded after the user presses the save button".
+         */
+        int EDITED_USERNAME_AND_PASSWORD = 7;
+
+        int ACTION_COUNT = 8;
+    }
+
+    /**
+     *  The error displayed in the UI while the user is editing a credential.
+     *
+     *  These values are persisted to logs. Entries should not be renumbered and
+     *  numeric values should never be reused.
+     */
+    @IntDef({EMPTY_PASSWORD, DUPLICATE_USERNAME, ERROR_COUNT})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface CredentialEditError {
+        /** The password field is empty. */
+        int EMPTY_PASSWORD = 0;
+
+        /** The username in the username field is already saved for this site/app. */
+        int DUPLICATE_USERNAME = 1;
+
+        int ERROR_COUNT = 2;
+    }
+
+    CredentialEditMediator(
+            PasswordAccessReauthenticationHelper reauthenticationHelper,
+            ConfirmationDialogHelper deleteDialogHelper,
+            CredentialActionDelegate credentialActionDelegate,
+            Runnable helpLauncher,
+            boolean isBlockedCredential) {
+        mReauthenticationHelper = reauthenticationHelper;
+        mDeleteDialogHelper = deleteDialogHelper;
+        mCredentialActionDelegate = credentialActionDelegate;
+        mHelpLauncher = helpLauncher;
+        mIsBlockedCredential = isBlockedCredential;
+    }
+
+    @Initializer
+    void initialize(PropertyModel model) {
+        mModel = model;
+    }
+
+    @Initializer
+    void setCredential(String username, String password, boolean isInsecureCredential) {
+        mOriginalUsername = username;
+        mOriginalPassword = password;
+        mIsInsecureCredential = isInsecureCredential;
+
+        mModel.set(USERNAME, username);
+        mModel.set(PASSWORD_VISIBLE, false);
+        mModel.set(PASSWORD, password);
+    }
+
+    @Initializer
+    void setExistingUsernames(String[] existingUsernames) {
+        mExistingUsernames = new HashSet<>(Arrays.asList(existingUsernames));
+    }
+
+    void dismiss() {
+        mModel.set(UI_DISMISSED_BY_NATIVE, true);
+    }
+
+    @Override
+    public void onMaskOrUnmaskPassword() {
+        if (mModel.get(PASSWORD_VISIBLE)) {
+            RecordHistogram.recordEnumeratedHistogram(
+                    SAVED_PASSWORD_ACTION_HISTOGRAM, MASKED_PASSWORD, ACTION_COUNT);
+            mModel.set(PASSWORD_VISIBLE, false);
+            return;
+        }
+        reauthenticateUser(
+                ReauthReason.VIEW_PASSWORD,
+                (reauthSucceeded) -> {
+                    if (!reauthSucceeded) return;
+                    RecordHistogram.recordEnumeratedHistogram(
+                            SAVED_PASSWORD_ACTION_HISTOGRAM, UNMASKED_PASSWORD, ACTION_COUNT);
+                    mModel.set(PASSWORD_VISIBLE, true);
+                });
+    }
+
+    @Override
+    public void onSave() {
+        recordSavedEdit();
+        mCredentialActionDelegate.saveChanges(mModel.get(USERNAME), mModel.get(PASSWORD));
+    }
+
+    @Override
+    public void onUsernameTextChanged(String username) {
+        mModel.set(USERNAME, username);
+        boolean hasError =
+                !mOriginalUsername.equals(username) && mExistingUsernames.contains(username);
+        mModel.set(DUPLICATE_USERNAME_ERROR, hasError);
+    }
+
+    @Override
+    public void onPasswordTextChanged(String password) {
+        mModel.set(PASSWORD, password);
+        mModel.set(EMPTY_PASSWORD_ERROR, password.isEmpty());
+    }
+
+    @Override
+    public void onCopyUsername(Context context) {
+        recordUsernameCopied();
+        Clipboard.getInstance().setText("username", mModel.get(USERNAME));
+        Toast.makeText(
+                        context,
+                        R.string.password_entry_viewer_username_copied_into_clipboard,
+                        Toast.LENGTH_SHORT)
+                .show();
+    }
+
+    @Override
+    public void onDelete() {
+        if (mIsBlockedCredential) {
+            recordDeleted();
+            mCredentialActionDelegate.deleteCredential();
+            return;
+        }
+        Resources resources = mDeleteDialogHelper.getResources();
+        if (resources == null) return;
+        String title =
+                resources.getString(R.string.password_entry_edit_delete_credential_dialog_title);
+        String message =
+                resources.getString(
+                        mIsInsecureCredential
+                                ? R.string.password_check_delete_credential_dialog_body
+                                : R.string.password_entry_edit_deletion_dialog_body,
+                        mModel.get(URL_OR_APP));
+        String confirmation =
+                resources.getString(R.string.password_entry_edit_delete_credential_dialog_confirm);
+        mDeleteDialogHelper.showConfirmation(
+                title,
+                message,
+                confirmation,
+                () -> {
+                    recordDeleted();
+                    mCredentialActionDelegate.deleteCredential();
+                });
+    }
+
+    @Override
+    public void handleHelp() {
+        mHelpLauncher.run();
+    }
+
+    @Override
+    public void onCopyPassword(Context context) {
+        reauthenticateUser(
+                ReauthReason.COPY_PASSWORD,
+                (reauthSucceeded) -> {
+                    if (!reauthSucceeded) return;
+                    RecordHistogram.recordEnumeratedHistogram(
+                            SAVED_PASSWORD_ACTION_HISTOGRAM, COPIED_PASSWORD, ACTION_COUNT);
+                    Clipboard.getInstance().setPassword(mModel.get(PASSWORD));
+                    Toast.makeText(
+                                    context,
+                                    R.string.password_entry_viewer_password_copied_into_clipboard,
+                                    Toast.LENGTH_SHORT)
+                            .show();
+                });
+    }
+
+    private void reauthenticateUser(@ReauthReason int reason, Callback<Boolean> action) {
+        if (!mReauthenticationHelper.canReauthenticate()) {
+            mReauthenticationHelper.showScreenLockToast(reason);
+            return;
+        }
+        mReauthenticationHelper.reauthenticate(reason, action);
+    }
+
+    private void recordUsernameCopied() {
+        String histogram =
+                mModel.get(FEDERATION_ORIGIN).isEmpty()
+                        ? SAVED_PASSWORD_ACTION_HISTOGRAM
+                        : FEDERATED_CREDENTIAL_ACTION_HISTOGRAM;
+        RecordHistogram.recordEnumeratedHistogram(histogram, COPIED_USERNAME, ACTION_COUNT);
+    }
+
+    private void recordDeleted() {
+        String histogram = SAVED_PASSWORD_ACTION_HISTOGRAM;
+        if (mIsBlockedCredential) {
+            histogram = BLOCKED_CREDENTIAL_ACTION_HISTOGRAM;
+        } else if (!mModel.get(FEDERATION_ORIGIN).isEmpty()) {
+            histogram = FEDERATED_CREDENTIAL_ACTION_HISTOGRAM;
+        }
+        RecordHistogram.recordEnumeratedHistogram(histogram, DELETED, ACTION_COUNT);
+    }
+
+    private void recordSavedEdit() {
+        boolean changedUsername = !mModel.get(USERNAME).equals(mOriginalUsername);
+        boolean changedPassword = !mModel.get(PASSWORD).equals(mOriginalPassword);
+        if (changedUsername && changedPassword) {
+            RecordHistogram.recordEnumeratedHistogram(
+                    SAVED_PASSWORD_ACTION_HISTOGRAM, EDITED_USERNAME_AND_PASSWORD, ACTION_COUNT);
+            return;
+        }
+
+        if (changedUsername) {
+            RecordHistogram.recordEnumeratedHistogram(
+                    SAVED_PASSWORD_ACTION_HISTOGRAM, EDITED_USERNAME, ACTION_COUNT);
+            return;
+        }
+
+        if (changedPassword) {
+            RecordHistogram.recordEnumeratedHistogram(
+                    SAVED_PASSWORD_ACTION_HISTOGRAM, EDITED_PASSWORD, ACTION_COUNT);
+        }
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditProperties.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditProperties.java
new file mode 100644
index 0000000000000..c51cd7b50dfeb
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditProperties.java
@@ -0,0 +1,48 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEntryFragmentViewBase.UiActionHandler;
+import org.chromium.ui.modelutil.PropertyKey;
+import org.chromium.ui.modelutil.PropertyModel;
+
+/** Properties defined here reflect the visible state of the credential edit UI. */
+@NullMarked
+class CredentialEditProperties {
+    static final PropertyModel.WritableObjectPropertyKey<UiActionHandler> UI_ACTION_HANDLER =
+            new PropertyModel.WritableObjectPropertyKey<>("ui action handler");
+    static final PropertyModel.ReadableObjectPropertyKey<String> URL_OR_APP =
+            new PropertyModel.ReadableObjectPropertyKey<>("url or app");
+    static final PropertyModel.WritableObjectPropertyKey<String> USERNAME =
+            new PropertyModel.WritableObjectPropertyKey<>("username");
+    static final PropertyModel.WritableBooleanPropertyKey DUPLICATE_USERNAME_ERROR =
+            new PropertyModel.WritableBooleanPropertyKey("duplicate username error");
+    static final PropertyModel.WritableBooleanPropertyKey PASSWORD_VISIBLE =
+            new PropertyModel.WritableBooleanPropertyKey("password visible");
+    static final PropertyModel.WritableObjectPropertyKey<String> PASSWORD =
+            new PropertyModel.WritableObjectPropertyKey<>("password");
+    static final PropertyModel.WritableBooleanPropertyKey EMPTY_PASSWORD_ERROR =
+            new PropertyModel.WritableBooleanPropertyKey("empty password error");
+    static final PropertyModel.ReadableObjectPropertyKey<String> FEDERATION_ORIGIN =
+            new PropertyModel.ReadableObjectPropertyKey<>("federation origin");
+
+    static final PropertyModel.WritableBooleanPropertyKey UI_DISMISSED_BY_NATIVE =
+            new PropertyModel.WritableBooleanPropertyKey("ui dismissed by native");
+
+    static final PropertyKey[] ALL_KEYS = {
+        UI_ACTION_HANDLER,
+        URL_OR_APP,
+        USERNAME,
+        DUPLICATE_USERNAME_ERROR,
+        PASSWORD_VISIBLE,
+        PASSWORD,
+        EMPTY_PASSWORD_ERROR,
+        FEDERATION_ORIGIN,
+        UI_DISMISSED_BY_NATIVE
+    };
+
+    private CredentialEditProperties() {}
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditUiFactory.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditUiFactory.java
new file mode 100644
index 0000000000000..fc69d06acd6a8
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditUiFactory.java
@@ -0,0 +1,52 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import androidx.annotation.VisibleForTesting;
+
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.chrome.browser.profiles.Profile;
+
+/** Use {@link #create()} to instantiate a {@link CredentialEditCoordinator}. */
+@NullMarked
+public class CredentialEditUiFactory {
+    /**
+     * The factory used to create components that connect to the {@link CredentialEditFragmentView}
+     * and provide data.
+     */
+    interface CreationStrategy {
+        /** Creates a component that connects to the given fragment and manipulates its data. */
+        void create(CredentialEntryFragmentViewBase fragmentView, Profile profile);
+    }
+
+    private CredentialEditUiFactory() {}
+
+    private static CreationStrategy sCreationStrategy =
+            (fragmentView, profile) -> {
+                CredentialEditBridge bridge = CredentialEditBridge.get();
+                if (bridge == null) {
+                    // There is no backend to talk to, so the UI shouldn't be shown.
+                    fragmentView.dismiss();
+                    return;
+                }
+
+                bridge.initialize(
+                        new CredentialEditCoordinator(profile, fragmentView, bridge, bridge));
+            };
+
+    /**
+     * Creates the credential edit UI
+     *
+     * @param fragmentView the view which will be managed by the coordinator.
+     */
+    public static void create(CredentialEntryFragmentViewBase fragmentView, Profile profile) {
+        sCreationStrategy.create(fragmentView, profile);
+    }
+
+    @VisibleForTesting
+    static void setCreationStrategy(CreationStrategy creationStrategy) {
+        sCreationStrategy = creationStrategy;
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewBinder.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewBinder.java
new file mode 100644
index 0000000000000..45ff6f3e7036c
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewBinder.java
@@ -0,0 +1,52 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.DUPLICATE_USERNAME_ERROR;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.EMPTY_PASSWORD_ERROR;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.FEDERATION_ORIGIN;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD_VISIBLE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_ACTION_HANDLER;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_DISMISSED_BY_NATIVE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.URL_OR_APP;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.USERNAME;
+
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.ui.modelutil.PropertyKey;
+import org.chromium.ui.modelutil.PropertyModel;
+
+/**
+ * Maps {@link CredentialEditProperties} changes in a {@link PropertyModel} to the suitable methods
+ * in {@link CredentialEditFragmentView}.
+ */
+@NullMarked
+class CredentialEditViewBinder {
+    static void bindCredentialEditView(
+            PropertyModel model, CredentialEditFragmentView fragmentView, PropertyKey propertyKey) {
+        if (propertyKey == UI_ACTION_HANDLER) {
+            fragmentView.setUiActionHandler(model.get(UI_ACTION_HANDLER));
+        } else if (propertyKey == URL_OR_APP) {
+            fragmentView.setUrlOrApp(model.get(URL_OR_APP));
+        } else if (propertyKey == FEDERATION_ORIGIN) {
+            // TODO(crbug.com/40169863): Treat this case when the federated credentials
+            // layout is in place.
+        } else if (propertyKey == USERNAME) {
+            fragmentView.setUsername(model.get(USERNAME));
+        } else if (propertyKey == DUPLICATE_USERNAME_ERROR) {
+            fragmentView.changeUsernameError(model.get(DUPLICATE_USERNAME_ERROR));
+        } else if (propertyKey == PASSWORD_VISIBLE) {
+            fragmentView.changePasswordVisibility(model.get(PASSWORD_VISIBLE));
+        } else if (propertyKey == PASSWORD) {
+            fragmentView.setPassword(model.get(PASSWORD));
+        } else if (propertyKey == EMPTY_PASSWORD_ERROR) {
+            fragmentView.changePasswordError(model.get(EMPTY_PASSWORD_ERROR));
+        } else if (propertyKey == UI_DISMISSED_BY_NATIVE) {
+            fragmentView.dismiss();
+        } else {
+            assert false : "Unhandled update to property: " + propertyKey;
+        }
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewTest.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewTest.java
new file mode 100644
index 0000000000000..5292ad9e17ea6
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditViewTest.java
@@ -0,0 +1,237 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static android.text.InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.hasToString;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import static org.chromium.base.ThreadUtils.runOnUiThreadBlocking;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.ALL_KEYS;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.DUPLICATE_USERNAME_ERROR;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.EMPTY_PASSWORD_ERROR;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.FEDERATION_ORIGIN;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD_VISIBLE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.URL_OR_APP;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.USERNAME;
+
+import android.widget.EditText;
+import android.widget.TextView;
+
+import androidx.test.filters.MediumTest;
+
+import com.google.android.material.textfield.TextInputEditText;
+import com.google.android.material.textfield.TextInputLayout;
+
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.browser.password_entry_edit.CredentialEntryFragmentViewBase.ComponentStateDelegate;
+import org.chromium.chrome.browser.settings.SettingsActivityTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.ui.modelutil.PropertyModel;
+import org.chromium.ui.widget.ButtonCompat;
+import org.chromium.ui.widget.ChromeImageButton;
+
+/** View tests for the credential editing UI displaying a saved credential. */
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class CredentialEditViewTest {
+    private static final String TEST_URL = "https://m.a.xyz/signin";
+    private static final String TEST_USERNAME = "TestUsername";
+    private static final String TEST_PASSWORD = "TestPassword";
+
+    @Mock private ComponentStateDelegate mMockComponentStateDelegate;
+
+    private CredentialEditFragmentView mCredentialEditView;
+    private PropertyModel mModel;
+
+    @Rule public final MockitoRule mMockitoRule = MockitoJUnit.rule();
+
+    @Rule
+    public SettingsActivityTestRule<CredentialEditFragmentView> mTestRule =
+            new SettingsActivityTestRule<>(CredentialEditFragmentView.class);
+
+    @Before
+    public void setUp() throws InterruptedException {
+        CredentialEditUiFactory.setCreationStrategy(
+                (fragmentView, helpLauncher) -> {
+                    mCredentialEditView = (CredentialEditFragmentView) fragmentView;
+                    mCredentialEditView.setComponentStateDelegate(mMockComponentStateDelegate);
+                });
+        mTestRule.startSettingsActivity();
+        runOnUiThreadBlocking(
+                () -> {
+                    mModel =
+                            new PropertyModel.Builder(ALL_KEYS)
+                                    .with(URL_OR_APP, TEST_URL)
+                                    .with(FEDERATION_ORIGIN, "")
+                                    .build();
+                    CredentialEditCoordinator.setupModelChangeProcessor(
+                            mModel, mCredentialEditView);
+                });
+    }
+
+    @Test
+    @MediumTest
+    public void testDisplaysUrlOrAppAndExplanation() {
+        TextView urlOrAppView = mCredentialEditView.getView().findViewById(R.id.url_or_app);
+        assertThat(urlOrAppView.getText(), hasToString(TEST_URL));
+
+        TextView editInfoView = mCredentialEditView.getView().findViewById(R.id.edit_info);
+        assertThat(
+                editInfoView.getText(),
+                hasToString(mCredentialEditView.getString(R.string.password_edit_hint, TEST_URL)));
+    }
+
+    @Test
+    @MediumTest
+    public void testDisplaysUsername() {
+        runOnUiThreadBlocking(() -> mModel.set(USERNAME, TEST_USERNAME));
+        EditText usernameView = mCredentialEditView.getView().findViewById(R.id.username);
+        assertThat(usernameView.getText(), hasToString(TEST_USERNAME));
+    }
+
+    @Test
+    @MediumTest
+    public void testDisplaysPasswordWhenVisible() {
+        runOnUiThreadBlocking(
+                () -> {
+                    mModel.set(PASSWORD, TEST_PASSWORD);
+                    mModel.set(PASSWORD_VISIBLE, true);
+                });
+        TextInputEditText passwordView = mCredentialEditView.getView().findViewById(R.id.password);
+        assertThat(passwordView.getText(), hasToString(TEST_PASSWORD));
+
+        assertThat(passwordView, isVisiblePasswordInput(true));
+
+        ChromeImageButton hideButton =
+                mCredentialEditView.getView().findViewById(R.id.password_visibility_button);
+        assertThat(
+                hideButton.getContentDescription(),
+                equalTo(
+                        mCredentialEditView.getString(
+                                R.string.password_entry_viewer_hide_stored_password)));
+    }
+
+    @Test
+    @MediumTest
+    public void testContainsHiddenPassword() {
+        runOnUiThreadBlocking(
+                () -> {
+                    mModel.set(PASSWORD, TEST_PASSWORD);
+                    mModel.set(PASSWORD_VISIBLE, false);
+                });
+        TextInputEditText passwordView = mCredentialEditView.getView().findViewById(R.id.password);
+        assertThat(passwordView.getText(), hasToString(TEST_PASSWORD));
+        assertThat(passwordView, isVisiblePasswordInput(false));
+
+        ChromeImageButton showButton =
+                mCredentialEditView.getView().findViewById(R.id.password_visibility_button);
+        assertThat(
+                showButton.getContentDescription(),
+                equalTo(
+                        mCredentialEditView.getString(
+                                R.string.password_entry_viewer_show_stored_password)));
+    }
+
+    @Test
+    @MediumTest
+    public void testDisplaysUsernameErrorAndDisablesDoneButton() {
+        runOnUiThreadBlocking(
+                () -> {
+                    mModel.set(DUPLICATE_USERNAME_ERROR, true);
+                });
+        TextInputLayout usernameInputLayout =
+                mCredentialEditView.getView().findViewById(R.id.username_text_input_layout);
+        assertThat(
+                usernameInputLayout.getError(),
+                equalTo(
+                        mCredentialEditView.getString(
+                                R.string.password_entry_edit_duplicate_username_error)));
+
+        ButtonCompat doneButton = mCredentialEditView.getView().findViewById(R.id.button_primary);
+        assertFalse(doneButton.isEnabled());
+        assertFalse(doneButton.isClickable());
+
+        runOnUiThreadBlocking(
+                () -> {
+                    mModel.set(DUPLICATE_USERNAME_ERROR, false);
+                });
+        assertNull(usernameInputLayout.getError());
+        assertTrue(doneButton.isEnabled());
+        assertTrue(doneButton.isClickable());
+    }
+
+    @Test
+    @MediumTest
+    public void testDisplaysPasswordErrorAndDisablesDoneButton() {
+        runOnUiThreadBlocking(
+                () -> {
+                    mModel.set(EMPTY_PASSWORD_ERROR, true);
+                });
+        TextInputLayout passwordInputLayout =
+                mCredentialEditView.getView().findViewById(R.id.password_text_input_layout);
+        assertThat(
+                passwordInputLayout.getError(),
+                equalTo(
+                        mCredentialEditView.getString(
+                                R.string.password_entry_edit_empty_password_error)));
+
+        ButtonCompat doneButton = mCredentialEditView.getView().findViewById(R.id.button_primary);
+        assertFalse(doneButton.isEnabled());
+        assertFalse(doneButton.isClickable());
+
+        runOnUiThreadBlocking(
+                () -> {
+                    mModel.set(EMPTY_PASSWORD_ERROR, false);
+                });
+        assertNull(passwordInputLayout.getError());
+        assertTrue(doneButton.isEnabled());
+        assertTrue(doneButton.isClickable());
+    }
+
+    /**
+     * Matches any {@link EditText} which has the content visibility matching to |shouldBeVisible|.
+     *
+     * @return The matcher checking the input type.
+     */
+    private static Matcher<EditText> isVisiblePasswordInput(boolean shouldBeVisible) {
+        return new BaseMatcher<>() {
+            @Override
+            public boolean matches(Object o) {
+                EditText editText = (EditText) o;
+                return ((editText.getInputType() & TYPE_TEXT_VARIATION_VISIBLE_PASSWORD)
+                                == TYPE_TEXT_VARIATION_VISIBLE_PASSWORD)
+                        == shouldBeVisible;
+            }
+
+            @Override
+            public void describeTo(Description description) {
+                if (shouldBeVisible) {
+                    description.appendText("The content should be visible.");
+                } else {
+                    description.appendText("The content should not be visible.");
+                }
+            }
+        };
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialViewBinder.java b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialViewBinder.java
new file mode 100644
index 0000000000000..c5f5526ab7342
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/internal/java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialViewBinder.java
@@ -0,0 +1,45 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.FEDERATION_ORIGIN;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.PASSWORD_VISIBLE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_ACTION_HANDLER;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.UI_DISMISSED_BY_NATIVE;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.URL_OR_APP;
+import static org.chromium.chrome.browser.password_entry_edit.CredentialEditProperties.USERNAME;
+
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.ui.modelutil.PropertyKey;
+import org.chromium.ui.modelutil.PropertyModel;
+
+/**
+ * Maps {@link CredentialEditProperties} changes in a {@link PropertyModel} to the suitable methods
+ * in {@link FederatedCredentialFragmentView}.
+ */
+@NullMarked
+public class FederatedCredentialViewBinder {
+    static void bindFederatedCredentialView(
+            PropertyModel model,
+            FederatedCredentialFragmentView fragmentView,
+            PropertyKey propertyKey) {
+        if (propertyKey == UI_ACTION_HANDLER) {
+            fragmentView.setUiActionHandler(model.get(UI_ACTION_HANDLER));
+        } else if (propertyKey == URL_OR_APP) {
+            fragmentView.setUrlOrApp(model.get(URL_OR_APP));
+        } else if (propertyKey == UI_DISMISSED_BY_NATIVE) {
+            fragmentView.dismiss();
+        } else if (propertyKey == USERNAME) {
+            fragmentView.setUsername(model.get(USERNAME));
+        } else if (propertyKey == FEDERATION_ORIGIN) {
+            fragmentView.setIdentityProvider(model.get(FEDERATION_ORIGIN));
+        } else if (propertyKey == PASSWORD || propertyKey == PASSWORD_VISIBLE) {
+            // These properties are not relevant for the federated credential view.
+        } else {
+            assert false : "Unhandled update to property: " + propertyKey;
+        }
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/java/res/layout/blocked_credential_view.xml b/chrome/browser/password_entry_edit/android/java/res/layout/blocked_credential_view.xml
new file mode 100644
index 0000000000000..5cf94ce056349
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/res/layout/blocked_credential_view.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2021 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+   android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingStart="@dimen/password_entry_editor_content_spacing"
+    android:paddingEnd="@dimen/password_entry_editor_content_spacing"
+    android:paddingLeft="@dimen/password_entry_editor_content_spacing"
+    android:paddingRight="@dimen/password_entry_editor_content_spacing"
+    android:orientation="vertical">
+
+   <include layout="@layout/site_or_app"/>
+</LinearLayout>
diff --git a/chrome/browser/password_entry_edit/android/java/res/layout/credential_edit_view.xml b/chrome/browser/password_entry_edit/android/java/res/layout/credential_edit_view.xml
new file mode 100644
index 0000000000000..3291c2b2cdbee
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/res/layout/credential_edit_view.xml
@@ -0,0 +1,141 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2021 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingStart="@dimen/password_entry_editor_content_spacing"
+    android:paddingEnd="@dimen/password_entry_editor_content_spacing">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+        <include layout="@layout/site_or_app"/>
+
+        <!-- Username -->
+        <FrameLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="22dp">
+
+            <com.google.android.material.textfield.TextInputLayout
+                android:id="@+id/username_text_input_layout"
+                android:labelFor="@+id/username"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:hint="@string/password_entry_viewer_username_title"
+                app:hintTextAppearance="@style/TextAppearance.TextSmall.Secondary"
+                app:errorTextAppearance="@style/TextAppearance.ErrorCaption"
+                app:errorEnabled="true">
+
+                <com.google.android.material.textfield.TextInputEditText
+                    tools:ignore="LabelFor"
+                    android:id="@+id/username"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:imeOptions="flagNoExtractUi"
+                    android:importantForAutofill="noExcludeDescendants"
+                    android:inputType="textMultiLine"
+                    android:textAppearance="@style/TextAppearance.TextLarge.Primary"/>
+            </com.google.android.material.textfield.TextInputLayout>
+
+            <org.chromium.ui.widget.ChromeImageButton
+                    android:id="@+id/copy_username_button"
+                    android:background="?attr/selectableItemBackground"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_gravity="center_vertical | end"
+                    android:layout_marginBottom="@dimen/credential_edit_text_icon_margin_bottom"
+                    android:contentDescription="@string/password_entry_viewer_copy_stored_username"
+                    app:srcCompat="@drawable/ic_content_copy"
+                    app:tint="@color/default_icon_color_tint_list"
+                    style="?android:attr/buttonStyleSmall"/>
+        </FrameLayout>
+
+        <!-- Password -->
+        <FrameLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="8dp">
+
+            <com.google.android.material.textfield.TextInputLayout
+                android:id="@+id/password_text_input_layout"
+                android:labelFor="@+id/password"
+                android:layout_height="wrap_content"
+                android:layout_width="match_parent"
+                android:hint="@string/password_entry_viewer_password"
+                app:hintTextAppearance="@style/TextAppearance.TextSmall.Secondary"
+                app:errorTextAppearance="@style/TextAppearance.ErrorCaption"
+                app:errorEnabled="true">
+
+                <com.google.android.material.textfield.TextInputEditText
+                    tools:ignore="LabelFor"
+                    android:id="@+id/password"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:imeOptions="flagNoExtractUi"
+                    android:importantForAutofill="noExcludeDescendants"
+                    android:inputType="textVisiblePassword"
+                    android:textAppearance="@style/TextAppearance.TextLarge.Primary"/>
+            </com.google.android.material.textfield.TextInputLayout>
+
+            <LinearLayout
+                android:id="@+id/password_icons"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginBottom="@dimen/credential_edit_text_icon_margin_bottom"
+                android:layout_gravity="center_vertical | end"
+                android:orientation="horizontal">
+
+                 <org.chromium.ui.widget.ChromeImageButton
+                    android:id="@+id/password_visibility_button"
+                    android:background="?attr/selectableItemBackground"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:contentDescription="@string/password_entry_viewer_show_stored_password"
+                    app:srcCompat="@drawable/ic_visibility_black"
+                    app:tint="@color/default_icon_color_tint_list"
+                    style="?android:attr/buttonStyleSmall"/>
+
+                <org.chromium.ui.widget.ChromeImageButton
+                    android:id="@+id/copy_password_button"
+                    android:background="?attr/selectableItemBackground"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:contentDescription="@string/password_entry_viewer_copy_stored_password"
+                    app:srcCompat="@drawable/ic_content_copy"
+                    app:tint="@color/default_icon_color_tint_list"
+                    style="?android:attr/buttonStyleSmall"/>
+            </LinearLayout>
+        </FrameLayout>
+
+        <TextView
+            android:id="@+id/edit_info"
+            android:layout_marginTop="@dimen/password_entry_editor_field_top_margin"
+            android:layout_marginStart="@dimen/credential_edit_text_view_margin"
+            android:layout_marginEnd="@dimen/credential_edit_text_view_margin"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:textAppearance="@style/TextAppearance.TextSmall.Secondary"/>
+
+        <org.chromium.components.browser_ui.widget.DualControlLayout
+            android:id="@+id/button_bar"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:paddingTop="@dimen/credential_edit_button_layout_padding"
+            android:paddingBottom="@dimen/credential_edit_button_layout_padding"
+            android:background="@macro/default_bg_color"
+            app:stackedMargin="@dimen/credential_edit_button_layout_stacked_margin"
+            app:primaryButtonText="@string/done"
+            app:secondaryButtonText="@string/cancel"
+            app:buttonAlignment="end"/>
+    </LinearLayout>
+</ScrollView>
\ No newline at end of file
diff --git a/chrome/browser/password_entry_edit/android/java/res/layout/federated_credential_view.xml b/chrome/browser/password_entry_edit/android/java/res/layout/federated_credential_view.xml
new file mode 100644
index 0000000000000..e4508506ae45e
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/res/layout/federated_credential_view.xml
@@ -0,0 +1,86 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2021 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingStart="@dimen/password_entry_editor_content_spacing"
+    android:paddingEnd="@dimen/password_entry_editor_content_spacing">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+        <include layout="@layout/site_or_app"/>
+
+        <!-- Username -->
+        <LinearLayout
+            android:id="@+id/username_layout"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal"
+            android:layout_marginTop="8dp"
+            android:layout_marginBottom="@dimen/federated_view_username_margin_bottom">
+
+            <LinearLayout
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:orientation="vertical">
+                <TextView
+                    android:id="@+id/username_label"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:layout_marginStart="@dimen/credential_edit_text_view_margin"
+                    android:layout_marginEnd="@dimen/credential_edit_text_view_margin"
+                    android:text="@string/password_entry_viewer_username_title"
+                    android:textAppearance="@style/TextAppearance.TextSmall.Secondary"/>
+                <TextView
+                    android:id="@+id/username"
+                    android:layout_height="wrap_content"
+                    android:layout_width="match_parent"
+                    android:layout_marginStart="@dimen/credential_edit_text_view_margin"
+                    android:layout_marginEnd="@dimen/credential_edit_text_view_margin"
+                    android:textAppearance="@style/TextAppearance.TextLarge.Primary"/>
+            </LinearLayout>
+
+            <org.chromium.ui.widget.ChromeImageButton
+                android:id="@+id/copy_username_button"
+                android:background="?attr/selectableItemBackground"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center"
+                android:contentDescription="@string/password_entry_viewer_copy_stored_username"
+                app:srcCompat="@drawable/ic_content_copy"
+                app:tint="@color/default_icon_color_tint_list"
+                style="?android:attr/buttonStyleSmall"/>
+        </LinearLayout>
+
+
+        <!-- Identity provider -->
+        <TextView
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="@dimen/credential_edit_text_view_label_margin_bottom"
+            android:layout_marginStart="@dimen/credential_edit_text_view_margin"
+            android:layout_marginEnd="@dimen/credential_edit_text_view_margin"
+            android:text="@string/password_entry_viewer_password"
+            android:textAppearance="@style/TextAppearance.TextSmall.Secondary"/>
+
+        <TextView
+            android:id="@+id/password"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginBottom="@dimen/password_entry_editor_field_bottom_margin"
+            android:layout_marginStart="@dimen/credential_edit_text_view_margin"
+            android:layout_marginEnd="@dimen/credential_edit_text_view_margin"
+            android:textAppearance="@style/TextAppearance.TextLarge.Primary"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/chrome/browser/password_entry_edit/android/java/res/layout/site_or_app.xml b/chrome/browser/password_entry_edit/android/java/res/layout/site_or_app.xml
new file mode 100644
index 0000000000000..3c37077c5dab3
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/res/layout/site_or_app.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2021 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<merge xmlns:android="http://schemas.android.com/apk/res/android">
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="@dimen/password_entry_editor_field_large_top_margin"
+        android:layout_marginBottom="@dimen/credential_edit_text_view_label_margin_bottom"
+        android:layout_marginStart="@dimen/credential_edit_text_view_margin"
+        android:layout_marginEnd="@dimen/credential_edit_text_view_margin"
+        android:text="@string/password_entry_viewer_site_title"
+        android:textAppearance="@style/TextAppearance.TextSmall.Secondary"/>
+
+    <TextView
+        android:id="@+id/url_or_app"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="@dimen/password_entry_editor_field_bottom_margin"
+        android:layout_marginStart="@dimen/credential_edit_text_view_margin"
+        android:layout_marginEnd="@dimen/credential_edit_text_view_margin"
+        android:textAppearance="@style/TextAppearance.TextLarge.Primary"/>
+</merge>
\ No newline at end of file
diff --git a/chrome/browser/password_entry_edit/android/java/res/menu/credential_edit_action_bar_menu.xml b/chrome/browser/password_entry_edit/android/java/res/menu/credential_edit_action_bar_menu.xml
new file mode 100644
index 0000000000000..9fe3deb369ec7
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/res/menu/credential_edit_action_bar_menu.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2021 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto" >
+
+  <item
+      android:id="@+id/action_delete_saved_password"
+      android:icon="@drawable/ic_delete_white_24dp"
+      app:iconTint="@macro/default_icon_color"
+      android:title="@string/password_entry_viewer_delete_stored_password_action_title"
+      android:contentDescription="@string/password_entry_viewer_delete_stored_password"
+      app:showAsAction="ifRoom"/>
+
+  <item
+      android:id="@+id/help_button"
+      android:icon="@drawable/ic_help_and_feedback"
+      app:iconTint="@macro/default_icon_color"
+      android:title="@string/menu_help"
+      app:showAsAction="ifRoom"/>
+</menu>
\ No newline at end of file
diff --git a/chrome/browser/password_entry_edit/android/java/res/values/dimens.xml b/chrome/browser/password_entry_edit/android/java/res/values/dimens.xml
new file mode 100644
index 0000000000000..70476fd543aa0
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/res/values/dimens.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2021 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<resources xmlns:tools="http://schemas.android.com/tools">
+    <!-- Used to ensure that the TextViews are aligned with the contents
+    of the TextInputLayout elements -->
+    <dimen name="credential_edit_text_view_margin">4dp</dimen>
+    <dimen name="credential_edit_text_view_label_margin_bottom">2dp</dimen>
+    <dimen name="credential_edit_text_icon_margin_bottom">12dp</dimen>
+    <dimen name="credential_edit_button_layout_padding">10dp</dimen>
+    <dimen name="credential_edit_button_layout_stacked_margin">24dp</dimen>
+    <dimen name="federated_view_username_margin_bottom">16dp</dimen>
+</resources>
diff --git a/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialFragmentView.java b/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialFragmentView.java
new file mode 100644
index 0000000000000..f1f780a41b1b1
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/BlockedCredentialFragmentView.java
@@ -0,0 +1,56 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static org.chromium.build.NullUtil.assumeNonNull;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import org.chromium.base.supplier.ObservableSupplier;
+import org.chromium.base.supplier.ObservableSupplierImpl;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+
+/**
+ * This class is responsible for rendering a fragment containing details about a site that the user
+ * blocked from saving.
+ */
+@NullMarked
+public class BlockedCredentialFragmentView extends CredentialEntryFragmentViewBase {
+    private final ObservableSupplierImpl<String> mPageTitle = new ObservableSupplierImpl<>();
+
+    @Override
+    public void onCreatePreferences(@Nullable Bundle bundle, @Nullable String s) {
+        mPageTitle.set(getString(R.string.section_saved_passwords_exceptions));
+    }
+
+    @Override
+    public ObservableSupplier<String> getPageTitle() {
+        return mPageTitle;
+    }
+
+    @Override
+    public View onCreateView(
+            LayoutInflater inflater,
+            @Nullable ViewGroup container,
+            @Nullable Bundle savedInstanceState) {
+        setHasOptionsMenu(true);
+        return inflater.inflate(R.layout.blocked_credential_view, container, false);
+    }
+
+    void setUrlOrApp(String urlOrApp) {
+        TextView urlOrAppText = assumeNonNull(getView()).findViewById(R.id.url_or_app);
+        urlOrAppText.setText(urlOrApp);
+    }
+
+    @Override
+    public @AnimationType int getAnimationType() {
+        return AnimationType.PROPERTY;
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditFragmentView.java b/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditFragmentView.java
new file mode 100644
index 0000000000000..f7b9c067600f1
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEditFragmentView.java
@@ -0,0 +1,226 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static org.chromium.build.NullUtil.assumeNonNull;
+
+import android.os.Bundle;
+import android.text.InputType;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.widget.TextView;
+
+import androidx.core.view.ViewCompat;
+
+import com.google.android.material.textfield.TextInputEditText;
+import com.google.android.material.textfield.TextInputLayout;
+
+import org.chromium.base.supplier.ObservableSupplier;
+import org.chromium.base.supplier.ObservableSupplierImpl;
+import org.chromium.build.annotations.Initializer;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.ui.text.EmptyTextWatcher;
+import org.chromium.ui.widget.ButtonCompat;
+import org.chromium.ui.widget.ChromeImageButton;
+
+/**
+ * This class is responsible for rendering the edit fragment where users can edit a saved password.
+ */
+@NullMarked
+public class CredentialEditFragmentView extends CredentialEntryFragmentViewBase {
+    private TextInputLayout mUsernameInputLayout;
+
+    private TextInputEditText mUsernameField;
+
+    private TextInputLayout mPasswordInputLayout;
+
+    private TextInputEditText mPasswordField;
+
+    private ButtonCompat mDoneButton;
+
+    private final ObservableSupplierImpl<String> mPageTitle = new ObservableSupplierImpl<>();
+
+    @Override
+    public void onCreatePreferences(@Nullable Bundle bundle, @Nullable String rootKey) {
+        mPageTitle.set(getString(R.string.password_entry_viewer_edit_stored_password_action_title));
+    }
+
+    @Override
+    public ObservableSupplier<String> getPageTitle() {
+        return mPageTitle;
+    }
+
+    @Override
+    public View onCreateView(
+            LayoutInflater inflater,
+            @Nullable ViewGroup container,
+            @Nullable Bundle savedInstanceState) {
+        setHasOptionsMenu(true);
+        return inflater.inflate(R.layout.credential_edit_view, container, false);
+    }
+
+    @Override
+    @Initializer
+    public void onStart() {
+        View view = assumeNonNull(getView());
+        mUsernameInputLayout = view.findViewById(R.id.username_text_input_layout);
+        mUsernameField = view.findViewById(R.id.username);
+        View usernameIcon = view.findViewById(R.id.copy_username_button);
+        addLayoutChangeListener(mUsernameField, usernameIcon);
+
+        mPasswordInputLayout = view.findViewById(R.id.password_text_input_layout);
+        mPasswordField = view.findViewById(R.id.password);
+        View passwordIcons = view.findViewById(R.id.password_icons);
+        addLayoutChangeListener(mPasswordField, passwordIcons);
+
+        mDoneButton = view.findViewById(R.id.button_primary);
+
+        view.findViewById(R.id.button_secondary).setOnClickListener((unusedView) -> dismiss());
+
+        super.onStart();
+    }
+
+    @Override
+    void setUiActionHandler(UiActionHandler uiActionHandler) {
+        super.setUiActionHandler(uiActionHandler);
+
+        View view = assumeNonNull(getView());
+        ChromeImageButton usernameCopyButton = view.findViewById(R.id.copy_username_button);
+        usernameCopyButton.setOnClickListener(
+                (unusedView) ->
+                        uiActionHandler.onCopyUsername(getActivity().getApplicationContext()));
+
+        ChromeImageButton passwordCopyButton = view.findViewById(R.id.copy_password_button);
+        passwordCopyButton.setOnClickListener(
+                (unusedView) ->
+                        uiActionHandler.onCopyPassword(getActivity().getApplicationContext()));
+
+        ChromeImageButton passwordVisibilityButton =
+                view.findViewById(R.id.password_visibility_button);
+        passwordVisibilityButton.setOnClickListener(
+                (unusedView) -> uiActionHandler.onMaskOrUnmaskPassword());
+
+        view.findViewById(R.id.button_primary)
+                .setOnClickListener(
+                        (unusedView) -> {
+                            uiActionHandler.onSave();
+                            dismiss();
+                        });
+
+        view.findViewById(R.id.button_secondary).setOnClickListener((unusedView) -> dismiss());
+
+        mUsernameField.addTextChangedListener(
+                new EmptyTextWatcher() {
+                    @Override
+                    public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {
+                        uiActionHandler.onUsernameTextChanged(charSequence.toString());
+                    }
+                });
+
+        mPasswordField.addTextChangedListener(
+                new EmptyTextWatcher() {
+                    @Override
+                    public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {
+                        uiActionHandler.onPasswordTextChanged(charSequence.toString());
+                    }
+                });
+    }
+
+    void setUrlOrApp(String urlOrApp) {
+        View view = assumeNonNull(getView());
+        TextView urlOrAppText = view.findViewById(R.id.url_or_app);
+        urlOrAppText.setText(urlOrApp);
+
+        TextView editInfoText = view.findViewById(R.id.edit_info);
+        editInfoText.setText(getString(R.string.password_edit_hint, urlOrApp));
+    }
+
+    void setUsername(String username) {
+        // Don't update the text field if it has the same contents, as this will reset the cursor
+        // position to the beginning.
+        if (assumeNonNull(mUsernameField.getText()).toString().equals(username)) return;
+        mUsernameField.setText(username);
+    }
+
+    void changeUsernameError(boolean hasError) {
+        mUsernameInputLayout.setError(
+                hasError ? getString(R.string.password_entry_edit_duplicate_username_error) : "");
+        changeDoneButtonState(hasError);
+    }
+
+    void changePasswordError(boolean hasError) {
+        mPasswordInputLayout.setError(
+                hasError ? getString(R.string.password_entry_edit_empty_password_error) : "");
+        changeDoneButtonState(hasError);
+    }
+
+    void setPassword(String password) {
+        // Don't update the text field if it has the same contents, as this will reset the cursor
+        // position to the beginning.
+        if (assumeNonNull(mPasswordField.getText()).toString().equals(password)) return;
+        mPasswordField.setText(password);
+    }
+
+    void changePasswordVisibility(boolean visible) {
+        if (visible) {
+            getActivity()
+                    .getWindow()
+                    .setFlags(
+                            WindowManager.LayoutParams.FLAG_SECURE,
+                            WindowManager.LayoutParams.FLAG_SECURE);
+            mPasswordField.setInputType(
+                    InputType.TYPE_CLASS_TEXT
+                            | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD
+                            | InputType.TYPE_TEXT_FLAG_MULTI_LINE);
+        } else {
+            getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_SECURE);
+            mPasswordField.setInputType(
+                    InputType.TYPE_CLASS_TEXT
+                            | InputType.TYPE_TEXT_VARIATION_PASSWORD
+                            | InputType.TYPE_TEXT_FLAG_MULTI_LINE);
+        }
+        ChromeImageButton passwordVisibilityButton =
+                assumeNonNull(getView()).findViewById(R.id.password_visibility_button);
+        passwordVisibilityButton.setImageResource(
+                visible ? R.drawable.ic_visibility_off_black : R.drawable.ic_visibility_black);
+        passwordVisibilityButton.setContentDescription(
+                visible
+                        ? getString(R.string.password_entry_viewer_hide_stored_password)
+                        : getString(R.string.password_entry_viewer_show_stored_password));
+    }
+
+    void changeDoneButtonState(boolean hasError) {
+        mDoneButton.setEnabled(!hasError);
+        mDoneButton.setClickable(!hasError);
+    }
+
+    private static void addLayoutChangeListener(TextInputEditText textField, View icons) {
+        icons.addOnLayoutChangeListener(
+                (View v,
+                        int left,
+                        int top,
+                        int right,
+                        int bottom,
+                        int oldLeft,
+                        int oldTop,
+                        int oldRight,
+                        int oldBottom) -> {
+                    // Padding at the end of the text to ensure space for the icons.
+                    textField.setPaddingRelative(
+                            ViewCompat.getPaddingStart(textField),
+                            textField.getPaddingTop(),
+                            icons.getWidth(),
+                            textField.getPaddingBottom());
+                });
+    }
+
+    @Override
+    public @AnimationType int getAnimationType() {
+        return AnimationType.PROPERTY;
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEntryFragmentViewBase.java b/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEntryFragmentViewBase.java
new file mode 100644
index 0000000000000..26a7f681edae5
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/CredentialEntryFragmentViewBase.java
@@ -0,0 +1,135 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import android.content.Context;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+
+import androidx.preference.PreferenceFragmentCompat;
+
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.components.browser_ui.settings.EmbeddableSettingsPage;
+
+/**
+ * Base structure to be shared by fragments displaying: saved credentials to be edited, saved
+ * federated credentials and sites blocklisted for saving by the user.
+ */
+@NullMarked
+public abstract class CredentialEntryFragmentViewBase extends PreferenceFragmentCompat
+        implements EmbeddableSettingsPage {
+    @Nullable ComponentStateDelegate mComponentStateDelegate;
+    @Nullable UiActionHandler mUiActionHandler;
+
+    /**
+     * To be implemented by classes which need to know about the fragment's state
+     * TODO(crbug.com/40749164): The coordinator should be made a LifecycleObserver instead.
+     */
+    interface ComponentStateDelegate {
+        /** Called when the fragment is started. */
+        void onStartFragment();
+
+        /** Called when the fragment is resumed. */
+        void onResumeFragment();
+
+        /** Signals that the component is no longer needed. */
+        void onDestroy();
+    }
+
+    /**
+     * Handler for the various actions available in the UI: removing credentials, copying the
+     * username, copying the password, etc.
+     */
+    interface UiActionHandler {
+        /** Called when the user clicks the button to mask/unmask the password */
+        void onMaskOrUnmaskPassword();
+
+        /** Called when the user clicks the button to delete the credential */
+        void onDelete();
+
+        /** Called when the help icon is clicked */
+        void handleHelp();
+
+        /** Called when the text in the username field changes */
+        void onUsernameTextChanged(String username);
+
+        /** Called when the text in the password field changes */
+        void onPasswordTextChanged(String password);
+
+        /**
+         * Called when the user clicks the button to copy the username
+         *
+         * @param context application context that can be used to get the {@link ClipboardManager}
+         */
+        void onCopyUsername(Context context);
+
+        /**
+         * Called when the user clicks the button to copy the password
+         *
+         * @param context application context that can be used to get the {@link ClipboardManager}
+         */
+        void onCopyPassword(Context context);
+
+        /** Called when the user clicks the button to save the changes to the credential */
+        void onSave();
+    }
+
+    void setComponentStateDelegate(ComponentStateDelegate stateDelegate) {
+        mComponentStateDelegate = stateDelegate;
+    }
+
+    void setUiActionHandler(UiActionHandler actionHandler) {
+        mUiActionHandler = actionHandler;
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        menu.clear();
+
+        inflater.inflate(R.menu.credential_edit_action_bar_menu, menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (mUiActionHandler == null) return super.onOptionsItemSelected(item);
+
+        int id = item.getItemId();
+        if (id == R.id.action_delete_saved_password) {
+            mUiActionHandler.onDelete();
+            return true;
+        }
+        if (id == R.id.help_button) {
+            mUiActionHandler.handleHelp();
+            return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        if (mComponentStateDelegate != null) mComponentStateDelegate.onStartFragment();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (mComponentStateDelegate != null) mComponentStateDelegate.onResumeFragment();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        if (getActivity().isFinishing() && mComponentStateDelegate != null) {
+            mComponentStateDelegate.onDestroy();
+        }
+    }
+
+    void dismiss() {
+        getActivity().finish();
+    }
+}
diff --git a/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialFragmentView.java b/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialFragmentView.java
new file mode 100644
index 0000000000000..016d12f037a89
--- /dev/null
+++ b/chrome/browser/password_entry_edit/android/java/src/org/chromium/chrome/browser/password_entry_edit/FederatedCredentialFragmentView.java
@@ -0,0 +1,116 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_entry_edit;
+
+import static org.chromium.build.NullUtil.assumeNonNull;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewGroup.MarginLayoutParams;
+import android.widget.TextView;
+
+import org.chromium.base.supplier.ObservableSupplier;
+import org.chromium.base.supplier.ObservableSupplierImpl;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.ui.widget.ChromeImageButton;
+
+/**
+ * This class is responsible for rendering a fragment containing details about a saved federated
+ * credential.
+ */
+@NullMarked
+public class FederatedCredentialFragmentView extends CredentialEntryFragmentViewBase {
+    private ChromeImageButton mCopyButton;
+    private TextView mUsernameTextView;
+    private final ObservableSupplierImpl<String> mPageTitle = new ObservableSupplierImpl<>();
+
+    @Override
+    public void onCreatePreferences(@Nullable Bundle bundle, @Nullable String s) {
+        mPageTitle.set(getString(R.string.password_entry_viewer_title));
+    }
+
+    @Override
+    public ObservableSupplier<String> getPageTitle() {
+        return mPageTitle;
+    }
+
+    @Override
+    public View onCreateView(
+            LayoutInflater inflater,
+            @Nullable ViewGroup container,
+            @Nullable Bundle savedInstanceState) {
+        setHasOptionsMenu(true);
+        return inflater.inflate(R.layout.federated_credential_view, container, false);
+    }
+
+    @Override
+    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
+        mUsernameTextView = view.findViewById(R.id.username);
+        mCopyButton = view.findViewById(R.id.copy_username_button);
+
+        View usernameLayout = view.findViewById(R.id.username_layout);
+        TextView usernameLabel = view.findViewById(R.id.username_label);
+
+        usernameLayout.addOnLayoutChangeListener(
+                (View v,
+                        int left,
+                        int top,
+                        int right,
+                        int bottom,
+                        int oldLeft,
+                        int oldTop,
+                        int oldRight,
+                        int oldBottom) -> {
+                    MarginLayoutParams layoutParams =
+                            (MarginLayoutParams) usernameLayout.getLayoutParams();
+                    int totalMargin =
+                            getResources()
+                                    .getDimensionPixelSize(
+                                            R.dimen.federated_view_username_margin_bottom);
+                    if (mCopyButton.getHeight() < usernameLayout.getHeight()) {
+                        layoutParams.bottomMargin = totalMargin;
+                    } else {
+                        layoutParams.bottomMargin =
+                                totalMargin
+                                        - (mCopyButton.getHeight()
+                                                - mUsernameTextView.getHeight()
+                                                - usernameLabel.getHeight());
+                    }
+                    usernameLayout.setLayoutParams(layoutParams);
+                });
+    }
+
+    @Override
+    void setUiActionHandler(UiActionHandler uiActionHandler) {
+        super.setUiActionHandler(uiActionHandler);
+        ChromeImageButton mCopyButton =
+                assumeNonNull(getView()).findViewById(R.id.copy_username_button);
+        mCopyButton.setOnClickListener(
+                (unusedView) ->
+                        uiActionHandler.onCopyUsername(getActivity().getApplicationContext()));
+    }
+
+    void setUrlOrApp(String urlOrApp) {
+        TextView urlOrAppText = assumeNonNull(getView()).findViewById(R.id.url_or_app);
+        urlOrAppText.setText(urlOrApp);
+    }
+
+    void setUsername(String username) {
+        mUsernameTextView.setText(username);
+    }
+
+    void setIdentityProvider(String federatedOrigin) {
+        TextView passwordText = assumeNonNull(getView()).findViewById(R.id.password);
+        passwordText.setText(getString(R.string.password_via_federation, federatedOrigin));
+    }
+
+    @Override
+    public @AnimationType int getAnimationType() {
+        return AnimationType.PROPERTY;
+    }
+}
diff --git a/chrome/browser/password_manager/android/BUILD.gn b/chrome/browser/password_manager/android/BUILD.gn
index f69f7955dc3b5..3324ab9bb3e3e 100644
--- a/chrome/browser/password_manager/android/BUILD.gn
+++ b/chrome/browser/password_manager/android/BUILD.gn
@@ -185,7 +185,10 @@ android_library("java") {
     "java/src/org/chromium/chrome/browser/password_manager/PasswordStoreBridge.java",
     "java/src/org/chromium/chrome/browser/password_manager/PasswordStoreCredential.java",
     "java/src/org/chromium/chrome/browser/password_manager/PasswordSyncControllerDelegateBridgeImpl.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordAccessReauthenticationHelper.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragment.java",
     "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordsPreference.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManager.java",
   ]
 
   resources_package = "org.chromium.chrome.browser.password_manager"
@@ -295,6 +298,8 @@ robolectric_binary("password_manager_junit_tests") {
     "junit/src/org/chromium/chrome/browser/password_manager/PasswordStoreAndroidBackendDispatcherBridgeTest.java",
     "junit/src/org/chromium/chrome/browser/password_manager/PasswordStoreAndroidBackendReceiverBridgeTest.java",
     "junit/src/org/chromium/chrome/browser/password_manager/PasswordSyncControllerDelegateBridgeTest.java",
+    "junit/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragmentTest.java",
+    "junit/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManagerTest.java",
     "junit/src/org/chromium/chrome/browser/password_manager/tests/utils/FakePasswordCheckupClientHelperTest.java",
   ]
 
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordAccessReauthenticationHelper.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordAccessReauthenticationHelper.java
new file mode 100644
index 0000000000000..7e469a7ca3b14
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordAccessReauthenticationHelper.java
@@ -0,0 +1,143 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import android.content.Context;
+import android.view.View;
+
+import androidx.annotation.IntDef;
+import androidx.fragment.app.FragmentManager;
+
+import org.chromium.base.Callback;
+import org.chromium.base.metrics.RecordHistogram;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.chrome.browser.device_reauth.ReauthResult;
+import org.chromium.chrome.browser.password_manager.R;
+import org.chromium.chrome.browser.password_manager.settings.ReauthenticationManager.ReauthScope;
+import org.chromium.ui.widget.Toast;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * A helper to perform a user's reauthentication for a specific {@link ReauthReason}. Only a single
+ * reauthentication can happen at a given time.
+ */
+@NullMarked
+public class PasswordAccessReauthenticationHelper {
+    public static final String SETTINGS_REAUTHENTICATION_HISTOGRAM =
+            "PasswordManager.ReauthToAccessPasswordInSettings";
+
+    /**
+     * The reason for the reauthentication.
+     *
+     * <p>TODO(crbug.com/40170183): Remove the edit reason once the password check credential editor
+     * is completely replaced with the new one.
+     */
+    @IntDef({ReauthReason.VIEW_PASSWORD, ReauthReason.EDIT_PASSWORD, ReauthReason.COPY_PASSWORD})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface ReauthReason {
+        /** A reauthentication is required for viewing a password. */
+        int VIEW_PASSWORD = 0;
+
+        /** A reauthentication is required for editing a password. */
+        int EDIT_PASSWORD = 1;
+
+        /** Reauthentication is required in order to copy a password. */
+        int COPY_PASSWORD = 2;
+    }
+
+    private final Context mContext;
+    private final FragmentManager mFragmentManager;
+    private @Nullable Callback<Boolean> mCallback;
+
+    public PasswordAccessReauthenticationHelper(Context context, FragmentManager fragmentManager) {
+        mContext = context;
+        mFragmentManager = fragmentManager;
+    }
+
+    public boolean canReauthenticate() {
+        return ReauthenticationManager.isScreenLockSetUp(mContext);
+    }
+
+    /**
+     * Asks the user to reauthenticate. Requires {@link #canReauthenticate()}.
+     * @param reason The {@link ReauthReason} for the reauth.
+     * @param callback A {@link Callback}. Will invoke {@link Callback#onResult} with whether the
+     *         user passed or dismissed the reauth screen.
+     */
+    public void reauthenticate(@ReauthReason int reason, Callback<Boolean> callback) {
+        assert canReauthenticate();
+        assert mCallback == null;
+
+        // Invoke the handler immediately if an authentication is still valid.
+        if (ReauthenticationManager.authenticationStillValid(ReauthScope.ONE_AT_A_TIME)) {
+            RecordHistogram.recordEnumeratedHistogram(
+                    SETTINGS_REAUTHENTICATION_HISTOGRAM,
+                    ReauthResult.SKIPPED,
+                    ReauthResult.MAX_VALUE);
+
+            callback.onResult(true);
+            return;
+        }
+
+        mCallback = callback;
+
+        switch (reason) {
+            case ReauthReason.VIEW_PASSWORD:
+                ReauthenticationManager.displayReauthenticationFragment(
+                        R.string.lockscreen_description_view,
+                        View.NO_ID,
+                        mFragmentManager,
+                        ReauthScope.ONE_AT_A_TIME);
+                break;
+            case ReauthReason.EDIT_PASSWORD:
+                ReauthenticationManager.displayReauthenticationFragment(
+                        R.string.lockscreen_description_edit,
+                        View.NO_ID,
+                        mFragmentManager,
+                        ReauthScope.ONE_AT_A_TIME);
+                break;
+            case ReauthReason.COPY_PASSWORD:
+                ReauthenticationManager.displayReauthenticationFragment(
+                        R.string.lockscreen_description_copy,
+                        View.NO_ID,
+                        mFragmentManager,
+                        ReauthScope.ONE_AT_A_TIME);
+                break;
+        }
+    }
+
+    /**
+     * Shows a toast to the user nudging them to set up a screen lock. Intended to be called in case
+     * {@link #canReauthenticate()} returns false.
+     */
+    public void showScreenLockToast(@ReauthReason int reason) {
+        if (reason == ReauthReason.COPY_PASSWORD) {
+            Toast.makeText(
+                            mContext,
+                            R.string.password_entry_copy_set_screen_lock,
+                            Toast.LENGTH_LONG)
+                    .show();
+            return;
+        }
+        Toast.makeText(mContext, R.string.password_entry_view_set_screen_lock, Toast.LENGTH_LONG)
+                .show();
+    }
+
+    /**
+     * Invoked when a reauthentication might have happened. Invokes {@link Callback#onResult}
+     * with whether the user passed the reauthentication challenge.
+     * No-op if {@link #mCallback} is null.
+     */
+    public void onReauthenticationMaybeHappened() {
+        if (mCallback != null) {
+            mCallback.onResult(
+                    ReauthenticationManager.authenticationStillValid(ReauthScope.ONE_AT_A_TIME));
+            mCallback = null;
+        }
+    }
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragment.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragment.java
new file mode 100644
index 0000000000000..4634391d79368
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragment.java
@@ -0,0 +1,111 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static org.chromium.build.NullUtil.assertNonNull;
+import static org.chromium.chrome.browser.password_manager.settings.PasswordAccessReauthenticationHelper.SETTINGS_REAUTHENTICATION_HISTOGRAM;
+
+import android.app.Activity;
+import android.app.KeyguardManager;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+
+import org.chromium.base.metrics.RecordHistogram;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.chrome.browser.device_reauth.ReauthResult;
+
+/** Show the lock screen confirmation and lock the screen. */
+@NullMarked
+public class PasswordReauthenticationFragment extends Fragment {
+    /**
+     * The key for the description argument, which is used to retrieve an explanation of the
+     * reauthentication prompt to the user.
+     */
+    public static final String DESCRIPTION_ID = "description";
+
+    /**
+     * The key for the scope, with values from {@link ReauthenticationManager.ReauthScope}. The
+     * scope enum value corresponds to what is indicated in the description message for the user
+     * (e.g., if the message mentions "export passwords", the scope should be BULK, but for "view
+     * password" it should be ONE_AT_A_TIME).
+     */
+    public static final String SCOPE_ID = "scope";
+
+    protected static final int CONFIRM_DEVICE_CREDENTIAL_REQUEST_CODE = 2;
+
+    protected static final String HAS_BEEN_SUSPENDED_KEY = "has_been_suspended";
+
+    private static boolean sPreventLockDevice;
+
+    private FragmentManager mFragmentManager;
+
+    @Override
+    public void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mFragmentManager = assertNonNull(getFragmentManager());
+        boolean isFirstTime = savedInstanceState == null;
+        if (!sPreventLockDevice && isFirstTime) {
+            lockDevice();
+        }
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        // On Android L, an empty |outState| would degrade to null in |onCreate|, making Chrome
+        // unable to distinguish the first time launch. Insert a value into |outState| to prevent
+        // that.
+        outState.putBoolean(HAS_BEEN_SUSPENDED_KEY, true);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        if (requestCode == CONFIRM_DEVICE_CREDENTIAL_REQUEST_CODE) {
+            if (resultCode == Activity.RESULT_OK) {
+                RecordHistogram.recordEnumeratedHistogram(
+                        SETTINGS_REAUTHENTICATION_HISTOGRAM,
+                        ReauthResult.SUCCESS,
+                        ReauthResult.MAX_VALUE);
+                ReauthenticationManager.recordLastReauth(
+                        System.currentTimeMillis(), getArguments().getInt(SCOPE_ID));
+            } else {
+                RecordHistogram.recordEnumeratedHistogram(
+                        SETTINGS_REAUTHENTICATION_HISTOGRAM,
+                        ReauthResult.FAILURE,
+                        ReauthResult.MAX_VALUE);
+                ReauthenticationManager.resetLastReauth();
+            }
+            mFragmentManager.popBackStack();
+        }
+    }
+
+    /** Prevent calling the {@link #lockDevice} method in {@link #onCreate}. */
+    public static void preventLockingForTesting() {
+        sPreventLockDevice = true;
+    }
+
+    private void lockDevice() {
+        KeyguardManager keyguardManager =
+                (KeyguardManager) getActivity().getSystemService(Context.KEYGUARD_SERVICE);
+        final int resourceId = getArguments().getInt(DESCRIPTION_ID, 0);
+        // Forgetting to set the DESCRIPTION_ID is an error on the callsite.
+        assert resourceId != 0;
+        // Set title to null to use the system default title which is adapted to the particular type
+        // of device lock which the user set up.
+        Intent intent =
+                keyguardManager.createConfirmDeviceCredentialIntent(null, getString(resourceId));
+        if (intent != null) {
+            startActivityForResult(intent, CONFIRM_DEVICE_CREDENTIAL_REQUEST_CODE);
+            return;
+        }
+        mFragmentManager.popBackStackImmediate();
+    }
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManager.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManager.java
new file mode 100644
index 0000000000000..c95af00baa1e8
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManager.java
@@ -0,0 +1,198 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import android.app.KeyguardManager;
+import android.content.Context;
+import android.os.Bundle;
+import android.view.View;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.VisibleForTesting;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentTransaction;
+
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * This collection of static methods provides reauthentication primitives for passwords settings UI.
+ */
+@NullMarked
+public final class ReauthenticationManager {
+    // Used for various ways to override checks provided by this class.
+    @IntDef({OverrideState.NOT_OVERRIDDEN, OverrideState.AVAILABLE, OverrideState.UNAVAILABLE})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface OverrideState {
+        int NOT_OVERRIDDEN = 0;
+        int AVAILABLE = 1;
+        int UNAVAILABLE = 2;
+    }
+
+    // Used to specify the scope of the reauthentication -- either to grant bulk access like, e.g.,
+    // exporting passwords, or just one-at-a-time, like, e.g., viewing a single password.
+    @IntDef({ReauthScope.ONE_AT_A_TIME, ReauthScope.BULK})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface ReauthScope {
+        int ONE_AT_A_TIME = 0;
+        int BULK = 1;
+    }
+
+    // Useful for retrieving the fragment in tests.
+    @VisibleForTesting
+    public static final String FRAGMENT_TAG = "reauthentication-manager-fragment";
+
+    // Defines how long a successful reauthentication remains valid.
+    @VisibleForTesting public static final int VALID_REAUTHENTICATION_TIME_INTERVAL_MILLIS = 60000;
+
+    // Used for verifying if the last successful reauthentication is still valid. The null value
+    // means there was no successful reauthentication yet.
+    private static @Nullable Long sLastReauthTimeMillis;
+
+    // Stores the reauth scope used when |sLastReauthTimeMillis| was reset last time.
+    private static @ReauthScope int sLastReauthScope = ReauthScope.ONE_AT_A_TIME;
+
+    // Used in tests to override the result of checking for screen lock set-up. This allows the
+    // tests to be independent of a particular device configuration.
+    private static @OverrideState int sScreenLockSetUpOverride = OverrideState.NOT_OVERRIDDEN;
+
+    // Used in tests to override the result of checking for availability of the screen-locking API.
+    // This allows the tests to be independent of a particular device configuration.
+    private static @OverrideState int sApiOverride = OverrideState.NOT_OVERRIDDEN;
+
+    // Used in tests to avoid displaying the OS reauth dialog.
+    private static boolean sSkipSystemReauth;
+
+    /**
+     * Clears the record of the last reauth so that a call to authenticationStillValid will return
+     * false.
+     */
+    public static void resetLastReauth() {
+        sLastReauthTimeMillis = null;
+        sLastReauthScope = ReauthScope.ONE_AT_A_TIME;
+    }
+
+    /**
+     * Stores the timestamp of last reauthentication of the user.
+     * @param timeStampMillis The time of the most recent successful user reauthentication.
+     * @param scope The scope of the reauthentication as advertised to the user via UI.
+     */
+    public static void recordLastReauth(long timeStampMillis, @ReauthScope int scope) {
+        sLastReauthTimeMillis = timeStampMillis;
+        sLastReauthScope = scope;
+    }
+
+    @VisibleForTesting
+    public static void setScreenLockSetUpOverride(@OverrideState int screenLockSetUpOverride) {
+        sScreenLockSetUpOverride = screenLockSetUpOverride;
+    }
+
+    @VisibleForTesting
+    public static void setApiOverride(@OverrideState int apiOverride) {
+        // Ensure that tests don't accidentally try to launch the OS-provided lock screen.
+        if (apiOverride == OverrideState.AVAILABLE) {
+            PasswordReauthenticationFragment.preventLockingForTesting();
+        }
+
+        sApiOverride = apiOverride;
+    }
+
+    @VisibleForTesting
+    public static void setSkipSystemReauth(boolean skipSystemReauth) {
+        sSkipSystemReauth = skipSystemReauth;
+    }
+
+    /**
+     * Checks whether reauthentication is available on the device at all.
+     * @return The result of the check.
+     */
+    public static boolean isReauthenticationApiAvailable() {
+        switch (sApiOverride) {
+            case OverrideState.NOT_OVERRIDDEN:
+            case OverrideState.AVAILABLE:
+                return true;
+            case OverrideState.UNAVAILABLE:
+                return false;
+        }
+        // This branch is not reachable.
+        assert false;
+        return false;
+    }
+
+    /**
+     * Initiates the reauthentication prompt with a given description.
+     *
+     * @param descriptionId The resource ID of the string to be displayed to explain the reason for
+     *     the reauthentication.
+     * @param containerViewId The ID of the container, fragments of which will get replaced with the
+     *     reauthentication prompt. It may be equal to View.NO_ID in tests or when coming from
+     *     password check.
+     * @param fragmentManager For putting the lock screen on the transaction stack.
+     */
+    public static void displayReauthenticationFragment(
+            int descriptionId,
+            int containerViewId,
+            FragmentManager fragmentManager,
+            @ReauthScope int scope) {
+        if (sSkipSystemReauth) return;
+
+        Fragment passwordReauthentication = new PasswordReauthenticationFragment();
+        Bundle args = new Bundle();
+        args.putInt(PasswordReauthenticationFragment.DESCRIPTION_ID, descriptionId);
+        args.putInt(PasswordReauthenticationFragment.SCOPE_ID, scope);
+        passwordReauthentication.setArguments(args);
+
+        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
+        if (containerViewId == View.NO_ID) {
+            fragmentTransaction.add(passwordReauthentication, FRAGMENT_TAG);
+        } else {
+            fragmentTransaction.replace(containerViewId, passwordReauthentication, FRAGMENT_TAG);
+        }
+        fragmentTransaction.addToBackStack(null);
+        fragmentTransaction.commit();
+    }
+
+    /**
+     * Checks whether authentication is recent enough to be valid. The authentication is valid as
+     * long as the user authenticated less than {@code VALID_REAUTHENTICATION_TIME_INTERVAL_MILLIS}
+     * milliseconds ago, for a scope including the passed {@code scope} argument. The {@code BULK}
+     * scope includes the {@code ONE_AT_A_TIME} scope.
+     *
+     * @param scope The scope the reauth should be valid for.
+     */
+    public static boolean authenticationStillValid(@ReauthScope int scope) {
+        final boolean scopeIncluded =
+                scope == sLastReauthScope || sLastReauthScope == ReauthScope.BULK;
+        return sLastReauthTimeMillis != null
+                && scopeIncluded
+                && (System.currentTimeMillis() - sLastReauthTimeMillis)
+                        < VALID_REAUTHENTICATION_TIME_INTERVAL_MILLIS;
+    }
+
+    /**
+     * Checks whether the user set up screen lock so that it can be used for reauthentication. Can
+     * be overridden in tests.
+     *
+     * @param context The context to retrieve the KeyguardManager to find out.
+     */
+    public static boolean isScreenLockSetUp(Context context) {
+        switch (sScreenLockSetUpOverride) {
+            case OverrideState.NOT_OVERRIDDEN:
+                return ((KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE))
+                        .isKeyguardSecure();
+            case OverrideState.AVAILABLE:
+                return true;
+            case OverrideState.UNAVAILABLE:
+                return false;
+        }
+        // This branch is not reachable.
+        assert false;
+        return false;
+    }
+}
diff --git a/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragmentTest.java b/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragmentTest.java
new file mode 100644
index 0000000000000..c914792dedaec
--- /dev/null
+++ b/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragmentTest.java
@@ -0,0 +1,121 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentTransaction;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.LooperMode;
+
+import org.chromium.base.test.BaseRobolectricTestRunner;
+
+/** Tests for the "Save Passwords" settings screen. */
+@RunWith(BaseRobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+@LooperMode(LooperMode.Mode.LEGACY)
+public class PasswordReauthenticationFragmentTest {
+    // All reauthentication scopes to be checked in the tests.
+    private static final int[] ALL_SCOPES = {
+        ReauthenticationManager.ReauthScope.ONE_AT_A_TIME, ReauthenticationManager.ReauthScope.BULK
+    };
+
+    /**
+     * Creates a dummy fragment, pushes the reauth fragment on top of it, then resolves the activity
+     * for the reauth fragment and checks that back stack is in a correct state.
+     *
+     * @param resultCode The code which is passed to the reauth fragment as the result of the
+     *     activity.
+     * @param scope The scope of the reauthentication.
+     */
+    private void checkPopFromBackStackOnResult(
+            int resultCode, @ReauthenticationManager.ReauthScope int scope) {
+        PasswordReauthenticationFragment passwordReauthentication =
+                new PasswordReauthenticationFragment();
+        Bundle args = new Bundle();
+        args.putInt(PasswordReauthenticationFragment.DESCRIPTION_ID, 0);
+        args.putSerializable(PasswordReauthenticationFragment.SCOPE_ID, scope);
+        passwordReauthentication.setArguments(args);
+
+        // Replacement fragment for CredentialEntryFragment, which is the fragment that
+        // replaces PasswordReauthentication after popBackStack is called.
+        Fragment mockCredentialEntryFragment = new Fragment();
+
+        FragmentActivity testActivity = Robolectric.setupActivity(FragmentActivity.class);
+        Intent returnIntent = new Intent();
+        returnIntent.putExtra("result", "This is the result");
+        PasswordReauthenticationFragment.preventLockingForTesting();
+
+        FragmentManager fragmentManager = testActivity.getSupportFragmentManager();
+        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
+        fragmentTransaction.add(mockCredentialEntryFragment, "credential_edit_fragment");
+        fragmentTransaction.addToBackStack("add_credential_edit_fragment");
+        fragmentTransaction.commit();
+
+        FragmentTransaction fragmentTransaction2 = fragmentManager.beginTransaction();
+        fragmentTransaction2.add(passwordReauthentication, "password_reauthentication");
+        fragmentTransaction2.addToBackStack("add_password_reauthentication");
+        fragmentTransaction2.commit();
+
+        passwordReauthentication.onActivityResult(
+                PasswordReauthenticationFragment.CONFIRM_DEVICE_CREDENTIAL_REQUEST_CODE,
+                resultCode,
+                returnIntent);
+        fragmentManager.executePendingTransactions();
+
+        // Assert that the number of fragments in the Back Stack is equal to 1 after
+        // reauthentication, as PasswordReauthenticationFragment is popped.
+        assertEquals(1, fragmentManager.getBackStackEntryCount());
+
+        // Assert that the remaining fragment in the Back Stack is CredentialEntryFragment.
+        assertEquals(
+                "add_credential_edit_fragment", fragmentManager.getBackStackEntryAt(0).getName());
+    }
+
+    /**
+     * Ensure that upon successful reauthentication PasswordReauthenticationFragment is popped from
+     * the FragmentManager backstack and the reauthentication is marked as valid.
+     */
+    @Test
+    public void testOnOkActivityResult() {
+        for (int scope : ALL_SCOPES) {
+            // Ensure that the reauthentication state is changed by setting it to fail the final
+            // expectation.
+            ReauthenticationManager.resetLastReauth();
+
+            checkPopFromBackStackOnResult(Activity.RESULT_OK, scope);
+            assertTrue(ReauthenticationManager.authenticationStillValid(scope));
+        }
+    }
+
+    /**
+     * Ensure that upon canceled reauthentication PasswordReauthenticationFragment is popped from
+     * the FragmentManager backstack and the reauthentication is marked as invalid.
+     */
+    @Test
+    public void testOnCanceledActivityResult() {
+        for (int scope : ALL_SCOPES) {
+            // Ensure that the reauthentication state is changed by setting it to fail the final
+            // expectation.
+            ReauthenticationManager.recordLastReauth(System.currentTimeMillis(), scope);
+
+            checkPopFromBackStackOnResult(Activity.RESULT_CANCELED, scope);
+            assertFalse(ReauthenticationManager.authenticationStillValid(scope));
+        }
+    }
+}
diff --git a/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManagerTest.java b/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManagerTest.java
new file mode 100644
index 0000000000000..88ec374ecfe66
--- /dev/null
+++ b/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManagerTest.java
@@ -0,0 +1,214 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.view.View;
+
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentActivity;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentTransaction;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.LooperMode;
+
+import org.chromium.base.test.BaseRobolectricTestRunner;
+import org.chromium.chrome.R;
+
+/** Tests for the "Save Passwords" settings screen. */
+@RunWith(BaseRobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+@LooperMode(LooperMode.Mode.LEGACY)
+public class ReauthenticationManagerTest {
+    private FragmentManager mFragmentManager;
+
+    private FragmentActivity mTestActivity;
+
+    @Before
+    public void setUp() {
+        mTestActivity = Robolectric.setupActivity(FragmentActivity.class);
+        PasswordReauthenticationFragment.preventLockingForTesting();
+
+        mFragmentManager = mTestActivity.getSupportFragmentManager();
+
+        // Prepare a dummy Fragment and commit a FragmentTransaction with it.
+        FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();
+        // Replacement fragment for CredentialEntryFragment, which is the fragment that
+        // replaces PasswordReauthentication after popBackStack is called.
+        Fragment mockCredentialEntryFragment = new Fragment();
+        fragmentTransaction.add(mockCredentialEntryFragment, "credential_entry_fragment");
+        fragmentTransaction.addToBackStack(null);
+        fragmentTransaction.commit();
+    }
+
+    /**
+     * Prepares a dummy Intent to pass to PasswordReauthenticationFragment as a fake result of the
+     * reauthentication screen.
+     *
+     * @return The dummy Intent.
+     */
+    private Intent prepareDummyDataForActivityResult() {
+        Intent data = new Intent();
+        data.putExtra("result", "This is the result");
+        return data;
+    }
+
+    /**
+     * Ensure that displayReauthenticationFragment puts the reauthentication fragment on the
+     * transaction stack and updates the validity of the reauth when reauth passed.
+     */
+    @Test
+    public void testDisplayReauthenticationFragment_Passed() {
+        ReauthenticationManager.resetLastReauth();
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.ONE_AT_A_TIME));
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.BULK));
+
+        ReauthenticationManager.displayReauthenticationFragment(
+                R.string.lockscreen_description_view,
+                View.NO_ID,
+                mFragmentManager,
+                ReauthenticationManager.ReauthScope.ONE_AT_A_TIME);
+        Fragment reauthFragment =
+                mFragmentManager.findFragmentByTag(ReauthenticationManager.FRAGMENT_TAG);
+        assertNotNull(reauthFragment);
+
+        reauthFragment.onActivityResult(
+                PasswordReauthenticationFragment.CONFIRM_DEVICE_CREDENTIAL_REQUEST_CODE,
+                Activity.RESULT_OK,
+                prepareDummyDataForActivityResult());
+        mFragmentManager.executePendingTransactions();
+
+        assertTrue(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.ONE_AT_A_TIME));
+    }
+
+    /**
+     * Ensure that displayReauthenticationFragment puts the reauthentication fragment on the
+     * transaction stack and updates the validity of the reauth when reauth failed.
+     */
+    @Test
+    public void testDisplayReauthenticationFragment_Failed() {
+        ReauthenticationManager.resetLastReauth();
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.ONE_AT_A_TIME));
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.BULK));
+
+        ReauthenticationManager.displayReauthenticationFragment(
+                R.string.lockscreen_description_view,
+                View.NO_ID,
+                mFragmentManager,
+                ReauthenticationManager.ReauthScope.ONE_AT_A_TIME);
+        Fragment reauthFragment =
+                mFragmentManager.findFragmentByTag(ReauthenticationManager.FRAGMENT_TAG);
+        assertNotNull(reauthFragment);
+
+        reauthFragment.onActivityResult(
+                PasswordReauthenticationFragment.CONFIRM_DEVICE_CREDENTIAL_REQUEST_CODE,
+                Activity.RESULT_CANCELED,
+                prepareDummyDataForActivityResult());
+        mFragmentManager.executePendingTransactions();
+
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.ONE_AT_A_TIME));
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.BULK));
+    }
+
+    /**
+     * Ensure that displayReauthenticationFragment considers BULK scope to cover the ONE_AT_A_TIME
+     * scope as well.
+     */
+    @Test
+    public void testDisplayReauthenticationFragment_OneAtATimeCovered() {
+        ReauthenticationManager.resetLastReauth();
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.ONE_AT_A_TIME));
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.BULK));
+
+        ReauthenticationManager.displayReauthenticationFragment(
+                R.string.lockscreen_description_view,
+                View.NO_ID,
+                mFragmentManager,
+                ReauthenticationManager.ReauthScope.BULK);
+        Fragment reauthFragment =
+                mFragmentManager.findFragmentByTag(ReauthenticationManager.FRAGMENT_TAG);
+        assertNotNull(reauthFragment);
+
+        reauthFragment.onActivityResult(
+                PasswordReauthenticationFragment.CONFIRM_DEVICE_CREDENTIAL_REQUEST_CODE,
+                Activity.RESULT_OK,
+                prepareDummyDataForActivityResult());
+        mFragmentManager.executePendingTransactions();
+
+        // Both BULK and ONE_AT_A_TIME scopes should be covered by the BULK request above.
+        assertTrue(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.ONE_AT_A_TIME));
+        assertTrue(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.BULK));
+    }
+
+    /**
+     * Ensure that displayReauthenticationFragment does not consider ONE_AT_A_TIME scope to cover
+     * the BULK scope.
+     */
+    @Test
+    public void testDisplayReauthenticationFragment_BulkNotCovered() {
+        ReauthenticationManager.resetLastReauth();
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.ONE_AT_A_TIME));
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.BULK));
+
+        ReauthenticationManager.displayReauthenticationFragment(
+                R.string.lockscreen_description_view,
+                View.NO_ID,
+                mFragmentManager,
+                ReauthenticationManager.ReauthScope.ONE_AT_A_TIME);
+        Fragment reauthFragment =
+                mFragmentManager.findFragmentByTag(ReauthenticationManager.FRAGMENT_TAG);
+        assertNotNull(reauthFragment);
+
+        reauthFragment.onActivityResult(
+                PasswordReauthenticationFragment.CONFIRM_DEVICE_CREDENTIAL_REQUEST_CODE,
+                Activity.RESULT_OK,
+                prepareDummyDataForActivityResult());
+        mFragmentManager.executePendingTransactions();
+
+        // Only ONE_AT_A_TIME scope should be covered by the ONE_AT_A_TIME request above.
+        assertTrue(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.ONE_AT_A_TIME));
+        assertFalse(
+                ReauthenticationManager.authenticationStillValid(
+                        ReauthenticationManager.ReauthScope.BULK));
+    }
+}
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings.grd b/chrome/browser/ui/android/strings/android_chrome_strings.grd
index cce3b7bf7b9dc..12b75bc75eeef 100644
--- a/chrome/browser/ui/android/strings/android_chrome_strings.grd
+++ b/chrome/browser/ui/android/strings/android_chrome_strings.grd
@@ -705,6 +705,78 @@ For more settings that use data to improve your Vanadium experience, go to <ph n
       <message name="IDS_PASSWORDS_LEAK_DETECTION_SWITCH_SUMMARY" desc="Summary for the switch toggling whether Vanadium should check that entered credentials have been part of a leak.">
         When you use a password, Vanadium warns you if it has been published online. When doing this, your passwords and usernames are encrypted, so they cant be read by anyone, including Google.
       </message>
+      <message name="IDS_PASSWORDS_CHECK_TITLE" desc="Title for the check passwords button which allows to check whether the user's passwords have been compromised.">
+        Check passwords
+      </message>
+      <message name="IDS_SECTION_SAVED_PASSWORDS_EXCEPTIONS" desc="Header for the list of websites for which user selected to never save passwords. [CHAR_LIMIT=32]">
+        Never saved
+      </message>
+      <message name="IDS_PASSWORD_EDIT_HINT" desc="Small hint on the editing screens that advises users to store the same password as they use on the currently edited site.">
+        Make sure the password you are saving matches your password for <ph name="SITE">%1$s<ex>example.com</ex></ph>
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_EDIT_DELETION_DIALOG_BODY" desc="Text explaining the user that deleting the credential that they are viewing will not remove their account on the reaspective website.">
+        Deleting this password will not delete your account on <ph name="SITE">%1$s<ex>example.com</ex></ph>
+      </message>
+      <message name="IDS_PASSWORD_CHECK_DELETE_CREDENTIAL_DIALOG_BODY" desc="The body of a prompt to confirm that the user intends to delete the stored password.">
+        Deleting this password will not delete your account on <ph name="SITE">%1$s<ex>example.com</ex></ph>. Change your password or delete your account on <ph name="SITE">%1$s<ex>example.com</ex></ph> to keep it safe from others.
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_TITLE" desc="The title of a prompt to confirm that the user intends to delete the stored password.">
+        Delete password?
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_CONFIRM" desc="The caption the button confirming that the user intends to delete the stored password.">
+        Delete password
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_TITLE" desc='Title of the overview screen for a saved password.'>
+        Saved password
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_SITE_TITLE" desc='Title preceding the identification of the site where the stored password comes from.'>
+        Site
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_USERNAME_TITLE" desc='Title preceding username of the account where the stored password comes from.'>
+        Username
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_PASSWORD" desc='Title preceding password on password entry viewer.'>
+        Password
+      </message>
+      <message name="IDS_PASSWORD_VIA_FEDERATION" desc="Text for federated credential's value.">
+        with <ph name="PROVIDER">%1$s<ex>example.com</ex></ph>
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_COPY_STORED_USERNAME" desc='Content description for the button that copies the stored username.'>
+        Copy username
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_COPY_STORED_PASSWORD" desc='Content description for the button that copies the stored password.'>
+        Copy password
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_SHOW_STORED_PASSWORD" desc='Content description for the button that allows users to view the stored password upon reauthentication.'>
+        Show password
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_DELETE_STORED_PASSWORD_ACTION_TITLE" desc='Title for button on action bar that deletes the stored password.'>
+        Delete password
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_EDIT_STORED_PASSWORD_ACTION_TITLE" desc='Title for button on action bar that edits the stored password.'>
+        Edit password
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_HIDE_STORED_PASSWORD" desc="A tooltip on a button that hides the saved password that is being shown.">
+        Hide password
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_DELETE_STORED_PASSWORD" desc='Content description for the button that allows users to delete the stored password.'>
+        Delete stored password
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_USERNAME_COPIED_INTO_CLIPBOARD" desc='Text that announces to the user that the username of a saved account has been copied into clipboard.'>
+        Username copied
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEWER_PASSWORD_COPIED_INTO_CLIPBOARD" desc='Text that announces to the user that the password of a saved account has been copied into clipboard.'>
+        Password copied
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_VIEW_SET_SCREEN_LOCK" desc='Text prompting user to set up screen lock on their device in order to view passwords'>
+        To view passwords, first set a screen lock on your device
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_COPY_SET_SCREEN_LOCK" desc='Text prompting user to set up screen lock on their device in order to copy passwords'>
+        To copy passwords, first set a screen lock on your device
+      </message>
+      <message name="IDS_PASSWORD_ENTRY_EDIT_DUPLICATE_USERNAME_ERROR" desc='Error text displayed when the user changes the username in the editor to another username that they already saved for the same site.'>
+        You already saved this username for this site
+      </message>
       <message name="IDS_PASSWORD_ENTRY_EDIT_EMPTY_PASSWORD_ERROR" desc='Error text displayed when the user has left the password field empty in the credential editor.'>
         Enter password
       </message>
@@ -791,6 +863,17 @@ For more settings that use data to improve your Vanadium experience, go to <ph n
         Password suggestion is closed.
       </message>
 
+      <!-- Lock Screen Fragment -->
+      <message name="IDS_LOCKSCREEN_DESCRIPTION_COPY" desc="When a user attempts to copy a password for a particular website into clipboard in Chrome's settings, Chrome launches a lock screen to verify the user's identity and displays the following explanation.">
+        Unlock to copy your password
+      </message>
+      <message name="IDS_LOCKSCREEN_DESCRIPTION_VIEW" desc="When a user attempts to view a password for a particular website in Chrome's settings, Chrome launches a lock screen to verify the user's identity and displays the following explanation.">
+        Unlock to view your password
+      </message>
+      <message name="IDS_LOCKSCREEN_DESCRIPTION_EDIT" desc="When a user attempts to edit a password for a particular website in Chrome's settings, Chrome launches a lock screen to verify the user's identity and displays the following explanation.">
+        Unlock to edit your password
+      </message>
+
       <!-- Homepage preferences -->
       <message name="IDS_OPTIONS_HOMEPAGE_EDIT_HINT" desc="Hint for the text edit on Homepage Preference setting, guiding user to enter their customized homepage setting">
         Enter custom web address
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_LOCKSCREEN_DESCRIPTION_EDIT.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_LOCKSCREEN_DESCRIPTION_EDIT.png.sha1
new file mode 100644
index 0000000000000..5303928b0661c
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_LOCKSCREEN_DESCRIPTION_EDIT.png.sha1
@@ -0,0 +1 @@
+7f16ce747df88cd289e5037f07beadc5ff251106
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORDS_CHECK_TITLE.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORDS_CHECK_TITLE.png.sha1
new file mode 100644
index 0000000000000..7dde38f36ac26
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORDS_CHECK_TITLE.png.sha1
@@ -0,0 +1 @@
+dde9e67e02af87bf8b25a1dff9de112432fff9cc
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_CHECK_DELETE_CREDENTIAL_DIALOG_BODY.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_CHECK_DELETE_CREDENTIAL_DIALOG_BODY.png.sha1
new file mode 100644
index 0000000000000..09007fe0dd998
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_CHECK_DELETE_CREDENTIAL_DIALOG_BODY.png.sha1
@@ -0,0 +1 @@
+19b07efe24ab4f8af6385168f1eb1a2209b850a6
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_EDIT_HINT.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_EDIT_HINT.png.sha1
new file mode 100644
index 0000000000000..bcaea3c7bc1fd
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_EDIT_HINT.png.sha1
@@ -0,0 +1 @@
+836fe6204aa775e50fa379738191cf32dd4f4f71
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_COPY_SET_SCREEN_LOCK.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_COPY_SET_SCREEN_LOCK.png.sha1
new file mode 100644
index 0000000000000..bc76938d3ff2f
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_COPY_SET_SCREEN_LOCK.png.sha1
@@ -0,0 +1 @@
+c2ec1c841660db79b35e493ba08d84f3ce2a5bfc
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_CONFIRM.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_CONFIRM.png.sha1
new file mode 100644
index 0000000000000..09007fe0dd998
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_CONFIRM.png.sha1
@@ -0,0 +1 @@
+19b07efe24ab4f8af6385168f1eb1a2209b850a6
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_TITLE.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_TITLE.png.sha1
new file mode 100644
index 0000000000000..09007fe0dd998
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETE_CREDENTIAL_DIALOG_TITLE.png.sha1
@@ -0,0 +1 @@
+19b07efe24ab4f8af6385168f1eb1a2209b850a6
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETION_DIALOG_BODY.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETION_DIALOG_BODY.png.sha1
new file mode 100644
index 0000000000000..855fad9f90116
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DELETION_DIALOG_BODY.png.sha1
@@ -0,0 +1 @@
+996553ff13d0ac7ce7de82d8cc0ee130dc079377
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DUPLICATE_USERNAME_ERROR.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DUPLICATE_USERNAME_ERROR.png.sha1
new file mode 100644
index 0000000000000..b3b2e0832cf1d
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_EDIT_DUPLICATE_USERNAME_ERROR.png.sha1
@@ -0,0 +1 @@
+64d5dde5fa669ba003abb73c61c9946980dd36ae
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_VIEWER_SHOW_STORED_PASSWORD.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_VIEWER_SHOW_STORED_PASSWORD.png.sha1
new file mode 100644
index 0000000000000..daca1167ea6d5
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_VIEWER_SHOW_STORED_PASSWORD.png.sha1
@@ -0,0 +1 @@
+7ddbdb9ac201a1898750ca6ae453a32730f71114
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_VIEW_SET_SCREEN_LOCK.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_VIEW_SET_SCREEN_LOCK.png.sha1
new file mode 100644
index 0000000000000..a4bbb3b7d4bb6
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_ENTRY_VIEW_SET_SCREEN_LOCK.png.sha1
@@ -0,0 +1 @@
+9a004f2cd3ef2455825109125bcc24ad603f04a5
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_VIA_FEDERATION.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_VIA_FEDERATION.png.sha1
new file mode 100644
index 0000000000000..d6c0be5f54190
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_VIA_FEDERATION.png.sha1
@@ -0,0 +1 @@
+c31117d6ab2e40d3a0e821b9facae7441d18c9f1
\ No newline at end of file
