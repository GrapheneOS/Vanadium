From ee38259dba3e414bdb716567da479346b9824745 Mon Sep 17 00:00:00 2001
From: Illia Klimov <elklm@google.com>
Date: Mon, 18 Jul 2022 13:46:57 +0000
Subject: [PATCH] Revoke site-level Notifications permission and FCM on
 Android.

go/fcm-revocation

If Chrome has no app-level Notifications permission on Android, we cannot display a push message and we should not process it but rather return early.

If the blocked state of the app-level Notifications permission on Android is permanent (longer than the grace period), then the site-level Notifications permission should be revoked and FCM should be unsubscribed.

Bug: 1336278
Change-Id: I068e0d13e44a4bf6a9493b90777e425a9f4b13fa
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3705212
Reviewed-by: Mike West <mkwst@chromium.org>
Reviewed-by: Arthur Sonzogni <arthursonzogni@chromium.org>
Reviewed-by: Michael van Ouwerkerk <mvanouwerkerk@chromium.org>
Reviewed-by: Shakti Sahu <shaktisahu@chromium.org>
Reviewed-by: Kamila Hasanbega <hkamila@chromium.org>
Commit-Queue: Illia Klimov <elklm@google.com>
Reviewed-by: Peter Beverloo <peter@chromium.org>
Reviewed-by: Theresa Sullivan <twellington@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1025226}
---
 chrome/browser/prefs/browser_prefs.cc         |   4 +
 .../push_messaging/push_messaging_features.cc |   9 +
 .../push_messaging/push_messaging_features.h  |  11 +
 .../push_messaging_service_impl.cc            | 129 +++++-
 .../push_messaging_service_impl.h             |  38 ++
 .../push_messaging_service_unittest.cc        | 373 +++++++++++++++++-
 components/permissions/android/BUILD.gn       |   1 +
 .../android/android_permission_util.cc        |   5 +
 .../android/android_permission_util.h         |   6 +-
 .../permissions/PermissionUtil.java           |  10 +
 .../permission_manager_unittest.cc            |  39 ++
 .../permissions/permission_controller_impl.cc |   5 +
 .../permissions/permission_controller_impl.h  |   2 +
 .../public/browser/permission_controller.h    |   4 +
 .../public/test/mock_permission_controller.cc |   3 +
 .../public/test/mock_permission_controller.h  |   2 +
 .../push_messaging_status.mojom               |  13 +
 17 files changed, 640 insertions(+), 14 deletions(-)

diff --git a/chrome/browser/prefs/browser_prefs.cc b/chrome/browser/prefs/browser_prefs.cc
index a748644cef16f..7006043cfc751 100644
--- a/chrome/browser/prefs/browser_prefs.cc
+++ b/chrome/browser/prefs/browser_prefs.cc
@@ -62,6 +62,7 @@
 #include "chrome/browser/profiles/profile_impl.h"
 #include "chrome/browser/profiles/profiles_state.h"
 #include "chrome/browser/push_messaging/push_messaging_app_identifier.h"
+#include "chrome/browser/push_messaging/push_messaging_service_impl.h"
 #include "chrome/browser/rlz/chrome_rlz_tracker_delegate.h"
 #include "chrome/browser/search/search.h"
 #include "chrome/browser/sharing/sharing_sync_preference.h"
@@ -1045,6 +1046,9 @@ void RegisterLocalState(PrefRegistrySimple* registry) {
   ProfileAttributesStorage::RegisterPrefs(registry);
   ProfileNetworkContextService::RegisterLocalStatePrefs(registry);
   profiles::RegisterPrefs(registry);
+#if BUILDFLAG(IS_ANDROID)
+  PushMessagingServiceImpl::RegisterPrefs(registry);
+#endif
   RegisterScreenshotPrefs(registry);
   safe_browsing::RegisterLocalStatePrefs(registry);
   secure_origin_allowlist::RegisterPrefs(registry);
diff --git a/chrome/browser/push_messaging/push_messaging_features.cc b/chrome/browser/push_messaging/push_messaging_features.cc
index 11ad3a97bb582..ea7b2cdeaebf2 100644
--- a/chrome/browser/push_messaging/push_messaging_features.cc
+++ b/chrome/browser/push_messaging/push_messaging_features.cc
@@ -12,4 +12,13 @@ const base::Feature kPushMessagingDisallowSenderIDs{
 const base::Feature kPushSubscriptionWithExpirationTime{
     "PushSubscriptionWithExpirationTime", base::FEATURE_DISABLED_BY_DEFAULT};
 
+#if BUILDFLAG(IS_ANDROID)
+const base::Feature kRevokeNotificationsPermissionIfDisabledOnAppLevel{
+    "RevokeNotificationsPermissionIfDisabledOnAppLevel",
+    base::FEATURE_DISABLED_BY_DEFAULT};
+
+const char kNotificationRevocationGracePeriodInDays[] =
+    "notifications_revocation_grace_period";
+#endif
+
 }  // namespace features
diff --git a/chrome/browser/push_messaging/push_messaging_features.h b/chrome/browser/push_messaging/push_messaging_features.h
index 1bdc9237860e8..b1177021977c7 100644
--- a/chrome/browser/push_messaging/push_messaging_features.h
+++ b/chrome/browser/push_messaging/push_messaging_features.h
@@ -16,6 +16,17 @@ extern const base::Feature kPushMessagingDisallowSenderIDs;
 // /chrome/browser/push_messaging/push_messaging_constants.h
 extern const base::Feature kPushSubscriptionWithExpirationTime;
 
+#if BUILDFLAG(IS_ANDROID)
+// Feature flag to revoke site-level Notifications permissions and FCM
+// registration.
+extern const base::Feature kRevokeNotificationsPermissionIfDisabledOnAppLevel;
+
+// Name of the variation parameter that represents the grace period that will be
+// applied before site-level Notifications permissions will be revoked and FCM
+// unsubscribed. The default value is 3.
+extern const char kNotificationRevocationGracePeriodInDays[];
+#endif
+
 }  // namespace features
 
 #endif  // CHROME_BROWSER_PUSH_MESSAGING_PUSH_MESSAGING_FEATURES_H_
diff --git a/chrome/browser/push_messaging/push_messaging_service_impl.cc b/chrome/browser/push_messaging/push_messaging_service_impl.cc
index 5fd72d4bd70c6..a9564d2015fcd 100644
--- a/chrome/browser/push_messaging/push_messaging_service_impl.cc
+++ b/chrome/browser/push_messaging/push_messaging_service_impl.cc
@@ -50,6 +50,7 @@
 #include "components/permissions/permission_manager.h"
 #include "components/permissions/permission_result.h"
 #include "components/pref_registry/pref_registry_syncable.h"
+#include "components/prefs/pref_registry_simple.h"
 #include "components/prefs/pref_service.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/devtools_background_services_context.h"
@@ -77,6 +78,9 @@
 #if BUILDFLAG(IS_ANDROID)
 #include "base/android/jni_android.h"
 #include "chrome/android/chrome_jni_headers/PushMessagingServiceObserver_jni.h"
+#include "chrome/browser/android/shortcut_helper.h"
+#include "components/permissions/android/android_permission_util.h"
+#include "components/prefs/pref_service.h"
 #endif
 
 using instance_id::InstanceID;
@@ -111,6 +115,24 @@ const char kSenderIdRegistrationDeprecatedMessage[] =
     "will be supported in the future. For more information check "
     "https://crbug.com/979235.";
 
+#if BUILDFLAG(IS_ANDROID)
+// The serialized base::Time used for Notifications permission revocation grace
+// period checks. This is usually the time at which the first push message was
+// received without app-level Notifications permission. An empty
+// (default-constructed) base::Time if there is no known time without app-level
+// Notifications permission.
+const char kNotificationsPermissionRevocationGracePeriodDate[] =
+    "notifications_permission_revocation_grace_period";
+
+// The grace period that will be applied before site-level Notifications
+// permissions will be revoked and FCM unsubscribed.
+int GetNotificationsRevocationGracePeriodInDays() {
+  return base::GetFieldTrialParamByFeatureAsInt(
+      features::kRevokeNotificationsPermissionIfDisabledOnAppLevel,
+      features::kNotificationRevocationGracePeriodInDays, 3);
+}
+#endif
+
 void RecordDeliveryStatus(blink::mojom::PushEventStatus status) {
   UMA_HISTOGRAM_ENUMERATION("PushMessaging.DeliveryStatus", status);
 }
@@ -347,8 +369,8 @@ void PushMessagingServiceImpl::OnMessage(const std::string& app_id,
         refresher_.FindActiveAppIdentifier(app_id);
     if (!refresh_identifier) {
       DeliverMessageCallback(app_id, GURL::EmptyGURL(),
-                             -1 /* kInvalidServiceWorkerRegistrationId */,
-                             message, false /* did_enqueue_message */,
+                             /*service_worker_registration_id=*/-1, message,
+                             /*did_enqueue_message=*/false,
                              blink::mojom::PushEventStatus::UNKNOWN_APP_ID);
       return;
     }
@@ -361,6 +383,15 @@ void PushMessagingServiceImpl::OnMessage(const std::string& app_id,
       /* was_encrypted= */ message.decrypted, std::string() /* error_message */,
       message.decrypted ? message.raw_data : std::string());
 
+#if BUILDFLAG(IS_ANDROID)
+  if (CheckAndRevokeNotificationPermissionIfNeeded(app_id, message,
+                                                   app_identifier)) {
+    // `message` is processed inside
+    // `CheckAndRevokeNotificationPermissionIfNeeded()`.
+    return;
+  }
+#endif
+
   if (IsPermissionSet(app_identifier.origin())) {
     messages_pending_permission_check_.emplace(app_id, message);
     // Start abusive origin verification only if no other verification is in
@@ -371,7 +402,7 @@ void PushMessagingServiceImpl::OnMessage(const std::string& app_id,
     // Drop message and unregister if origin has lost push permission.
     DeliverMessageCallback(app_id, app_identifier.origin(),
                            app_identifier.service_worker_registration_id(),
-                           message, false /* did_enqueue_message */,
+                           message, /*did_enqueue_message=*/false,
                            blink::mojom::PushEventStatus::PERMISSION_DENIED);
   }
 }
@@ -401,6 +432,77 @@ void PushMessagingServiceImpl::CheckOriginForAbuseAndDispatchNextMessage() {
                          weak_factory_.GetWeakPtr(), std::move(message)));
 }
 
+#if BUILDFLAG(IS_ANDROID)
+bool PushMessagingServiceImpl::CheckAndRevokeNotificationPermissionIfNeeded(
+    const std::string& app_id,
+    const gcm::IncomingMessage& message,
+    const PushMessagingAppIdentifier& app_identifier) {
+  if (!base::FeatureList::IsEnabled(
+          features::kRevokeNotificationsPermissionIfDisabledOnAppLevel)) {
+    return false;
+  }
+
+  bool has_app_level_notification_permission =
+      enabled_app_level_notification_permission_for_testing_.has_value()
+          ? enabled_app_level_notification_permission_for_testing_.value()
+          : permissions::AreAppLevelNotificationsEnabled();
+
+  bool contains_webapk = ShortcutHelper::DoesOriginContainAnyInstalledWebApk(
+      app_identifier.origin());
+  bool contains_twa =
+      ShortcutHelper::DoesOriginContainAnyInstalledTrustedWebActivity(
+          app_identifier.origin());
+  bool contains_installed_webapp = contains_twa || contains_webapk;
+
+  // If Notifications permission delegation is enabled, for the
+  // `app_identifier.origin()`, we should not revoke permissions because
+  // Notifications permissions are automatically synced with an installed app.
+  if (contains_installed_webapp)
+    return false;
+
+  PrefService* prefs = prefs_for_testing_.has_value()
+                           ? prefs_for_testing_.value()
+                           : g_browser_process->local_state();
+
+  if (has_app_level_notification_permission) {
+    // Chrome has app-level Notifications permission. Reset the grace period
+    // flag and continue as normal.
+    prefs->ClearPref(kNotificationsPermissionRevocationGracePeriodDate);
+    return false;
+  }
+
+  // Chrome has no app-level Notifications permission.
+  blink::mojom::PushEventStatus status;
+
+  if (prefs->GetTime(kNotificationsPermissionRevocationGracePeriodDate) ==
+      base::Time()) {
+    prefs->SetTime(kNotificationsPermissionRevocationGracePeriodDate,
+                   base::Time::Now());
+  }
+
+  base::TimeDelta permission_revocation_activated_duration =
+      base::Time::Now() -
+      prefs->GetTime(kNotificationsPermissionRevocationGracePeriodDate);
+  if (permission_revocation_activated_duration.InDays() <
+      GetNotificationsRevocationGracePeriodInDays()) {
+    // Ignore a push message during the grace period.
+    status = blink::mojom::PushEventStatus::NO_APP_LEVEL_PERMISSION_IGNORE;
+  } else {
+    // Revoke site-level Notifications permission & FCM.
+    status = blink::mojom::PushEventStatus::NO_APP_LEVEL_PERMISSION_UNSUBSCRIBE;
+
+    profile_->GetPermissionController()->ResetPermission(
+        blink::PermissionType::NOTIFICATIONS,
+        url::Origin::Create(app_identifier.origin()));
+  }
+
+  DeliverMessageCallback(app_id, app_identifier.origin(),
+                         app_identifier.service_worker_registration_id(),
+                         message, /*did_enqueue_message=*/false, status);
+  return true;
+}
+#endif
+
 void PushMessagingServiceImpl::OnCheckedOriginForAbuse(
     PendingMessage message,
     AbusiveOriginPermissionRevocationRequest::Outcome outcome) {
@@ -421,7 +523,7 @@ void PushMessagingServiceImpl::OnCheckedOriginForAbuse(
   int64_t service_worker_registration_id =
       app_identifier.service_worker_registration_id();
 
-  // It is possible that Notifications permission has been revoked by an user
+  // It is possible that Notifications permission has been revoked by a user
   // during abusive origin verification.
   if (outcome == AbusiveOriginPermissionRevocationRequest::Outcome::
                      PERMISSION_NOT_REVOKED &&
@@ -441,7 +543,7 @@ void PushMessagingServiceImpl::OnCheckedOriginForAbuse(
     // Drop message and unregister if origin has lost push permission.
     DeliverMessageCallback(
         message.app_id, origin, service_worker_registration_id, message.message,
-        false /* did_enqueue_message */,
+        /*did_enqueue_message=*/false,
         outcome == AbusiveOriginPermissionRevocationRequest::Outcome::
                        PERMISSION_NOT_REVOKED
             ? blink::mojom::PushEventStatus::PERMISSION_DENIED
@@ -471,7 +573,7 @@ void PushMessagingServiceImpl::
   auto deliver_message_callback = base::BindOnce(
       &PushMessagingServiceImpl::DeliverMessageCallback,
       weak_factory_.GetWeakPtr(), app_id, origin,
-      service_worker_registration_id, message, true /* did_enqueue_message */);
+      service_worker_registration_id, message, /*did_enqueue_message=*/true);
 
   // It is possible that Notification permissions have been revoked by a user
   // while handling previous messages for |origin|.
@@ -554,6 +656,13 @@ void PushMessagingServiceImpl::DeliverMessageCallback(
     case blink::mojom::PushEventStatus::SERVICE_WORKER_ERROR:
       // Do nothing, and hope the error is transient.
       break;
+    case blink::mojom::PushEventStatus::NO_APP_LEVEL_PERMISSION_IGNORE:
+      // Do nothing, ignore push messages during the grace period.
+      break;
+    case blink::mojom::PushEventStatus::NO_APP_LEVEL_PERMISSION_UNSUBSCRIBE:
+      unsubscribe_reason =
+          blink::mojom::PushUnregistrationReason::NO_APP_LEVEL_PERMISSION;
+      break;
     case blink::mojom::PushEventStatus::UNKNOWN_APP_ID:
       unsubscribe_reason =
           blink::mojom::PushUnregistrationReason::DELIVERY_UNKNOWN_APP_ID;
@@ -846,6 +955,14 @@ blink::mojom::PermissionStatus PushMessagingServiceImpl::GetPermissionStatus(
   }
 }
 
+#if BUILDFLAG(IS_ANDROID)
+// static
+void PushMessagingServiceImpl::RegisterPrefs(PrefRegistrySimple* registry) {
+  registry->RegisterTimePref(kNotificationsPermissionRevocationGracePeriodDate,
+                             base::Time());
+}
+#endif
+
 bool PushMessagingServiceImpl::SupportNonVisibleMessages() {
   return false;
 }
diff --git a/chrome/browser/push_messaging/push_messaging_service_impl.h b/chrome/browser/push_messaging/push_messaging_service_impl.h
index d92582ce885d0..1e3b011b710cc 100644
--- a/chrome/browser/push_messaging/push_messaging_service_impl.h
+++ b/chrome/browser/push_messaging/push_messaging_service_impl.h
@@ -37,9 +37,12 @@
 #include "third_party/blink/public/mojom/push_messaging/push_messaging.mojom-forward.h"
 
 class GURL;
+class PrefRegistrySimple;
+class PrefService;
 class Profile;
 class PushMessagingAppIdentifier;
 class PushMessagingServiceTest;
+class FCMRevocationTest;
 class ScopedKeepAlive;
 class ScopedProfileKeepAlive;
 
@@ -100,6 +103,11 @@ class PushMessagingServiceImpl : public content::PushMessagingService,
   blink::mojom::PermissionStatus GetPermissionStatus(const GURL& origin,
                                                      bool user_visible);
 
+#if BUILDFLAG(IS_ANDROID)
+  // Registers Local State prefs used by this class.
+  static void RegisterPrefs(PrefRegistrySimple* registry);
+#endif
+
   // gcm::GCMAppHandler implementation.
   void ShutdownHandler() override;
   void OnStoreReset() override;
@@ -187,15 +195,30 @@ class PushMessagingServiceImpl : public content::PushMessagingService,
       base::RepeatingClosure callback);
   void SetRemoveExpiredSubscriptionsCallbackForTesting(
       base::OnceClosure closure);
+  void set_enabled_app_level_notification_permission_for_testing(bool enabled) {
+    enabled_app_level_notification_permission_for_testing_ = enabled;
+  }
+  void set_prefs_for_testing(PrefService* prefs_for_testing) {
+    prefs_for_testing_ = prefs_for_testing;
+  }
 
  private:
   friend class PushMessagingBrowserTestBase;
   friend class PushMessagingServiceTest;
+  friend class FCMRevocationTest;
   FRIEND_TEST_ALL_PREFIXES(PushMessagingBrowserTest, PushEventOnShutdown);
   FRIEND_TEST_ALL_PREFIXES(PushMessagingServiceTest, NormalizeSenderInfo);
   FRIEND_TEST_ALL_PREFIXES(PushMessagingServiceTest, PayloadEncryptionTest);
   FRIEND_TEST_ALL_PREFIXES(PushMessagingServiceTest,
                            TestMultipleIncomingPushMessages);
+#if BUILDFLAG(IS_ANDROID)
+  FRIEND_TEST_ALL_PREFIXES(FCMRevocationTest,
+                           TestPermissionRevocationClearPreferences);
+  FRIEND_TEST_ALL_PREFIXES(FCMRevocationTest,
+                           TestPermissionRevocationNoPermissionFirstMessage);
+  FRIEND_TEST_ALL_PREFIXES(FCMRevocationTest,
+                           TestPermissionRevocationGracePeriodIsOver);
+#endif
 
   // A subscription is pending until it has succeeded or failed.
   void IncreasePushSubscriptionCount(int add, bool is_pending);
@@ -230,6 +253,18 @@ class PushMessagingServiceImpl : public content::PushMessagingService,
 
   void CheckOriginForAbuseAndDispatchNextMessage();
 
+#if BUILDFLAG(IS_ANDROID)
+  //  Verifies if Chrome has Android app-level Notifications permission. If
+  //  app-level permission is missing, `message` will be ignored, and site-level
+  //  Notifications permission and FCM will be revoked.
+  //
+  //  Returns true if `message` should be ignored, returns false otherwise.
+  bool CheckAndRevokeNotificationPermissionIfNeeded(
+      const std::string& app_id,
+      const gcm::IncomingMessage& message,
+      const PushMessagingAppIdentifier& app_identifier);
+#endif
+
   // Subscribe methods ---------------------------------------------------------
 
   void DoSubscribe(PushMessagingAppIdentifier app_identifier,
@@ -467,6 +502,9 @@ class PushMessagingServiceImpl : public content::PushMessagingService,
 
   int render_process_id_ = content::ChildProcessHost::kInvalidUniqueID;
 
+  absl::optional<bool> enabled_app_level_notification_permission_for_testing_;
+  absl::optional<PrefService*> prefs_for_testing_;
+
   base::WeakPtrFactory<PushMessagingServiceImpl> weak_factory_{this};
 };
 
diff --git a/chrome/browser/push_messaging/push_messaging_service_unittest.cc b/chrome/browser/push_messaging/push_messaging_service_unittest.cc
index fc6a305b7f22b..4c0b4b6cf106a 100644
--- a/chrome/browser/push_messaging/push_messaging_service_unittest.cc
+++ b/chrome/browser/push_messaging/push_messaging_service_unittest.cc
@@ -41,6 +41,7 @@
 #if BUILDFLAG(IS_ANDROID)
 #include "components/gcm_driver/instance_id/instance_id_android.h"
 #include "components/gcm_driver/instance_id/scoped_use_fake_instance_id_android.h"
+#include "components/prefs/testing_pref_service.h"
 #endif  // BUILDFLAG(IS_ANDROID)
 
 namespace {
@@ -100,11 +101,9 @@ constexpr base::TimeDelta kPushEventHandleTime = base::Seconds(10);
 class PushMessagingServiceTest : public ::testing::Test {
  public:
   PushMessagingServiceTest() {
-    // Always allow push notifications in the profile.
-    HostContentSettingsMap* host_content_settings_map =
-        HostContentSettingsMapFactory::GetForProfile(&profile_);
-    host_content_settings_map->SetDefaultContentSetting(
-        ContentSettingsType::NOTIFICATIONS, CONTENT_SETTING_ALLOW);
+#if BUILDFLAG(IS_ANDROID)
+    PushMessagingServiceImpl::RegisterPrefs(prefs_.registry());
+#endif
 
     // Override the GCM Profile service so that we can send fake messages.
     gcm::GCMProfileServiceFactory::GetInstance()->SetTestingFactory(
@@ -113,6 +112,13 @@ class PushMessagingServiceTest : public ::testing::Test {
 
   ~PushMessagingServiceTest() override = default;
 
+  void SetPermission(const GURL& origin, ContentSetting value) {
+    HostContentSettingsMap* host_content_settings_map =
+        HostContentSettingsMapFactory::GetForProfile(&profile_);
+    host_content_settings_map->SetContentSettingDefaultScope(
+        origin, origin, ContentSettingsType::NOTIFICATIONS, value);
+  }
+
   // Callback to use when the subscription may have been subscribed.
   void DidRegister(std::string* subscription_id_out,
                    GURL* endpoint_out,
@@ -224,9 +230,16 @@ class PushMessagingServiceTest : public ::testing::Test {
     return task_environment_;
   }
 
+#if BUILDFLAG(IS_ANDROID)
+  PrefService* get_pref() { return &prefs_; }
+#endif
+
  private:
   content::BrowserTaskEnvironment task_environment_{
       base::test::TaskEnvironment::TimeSource::MOCK_TIME};
+#if BUILDFLAG(IS_ANDROID)
+  TestingPrefServiceSimple prefs_;
+#endif
   PushMessagingTestingProfile profile_;
 
 #if BUILDFLAG(IS_ANDROID)
@@ -245,7 +258,15 @@ TEST_F(PushMessagingServiceTest, MAYBE_PayloadEncryptionTest) {
   PushMessagingServiceImpl* push_service = profile()->GetPushMessagingService();
   ASSERT_TRUE(push_service);
 
+#if BUILDFLAG(IS_ANDROID)
+  // Without Android app-level Notifications permission a push message will be
+  // ignored.
+  push_service->set_enabled_app_level_notification_permission_for_testing(true);
+  push_service->set_prefs_for_testing(get_pref());
+#endif
+
   const GURL origin(kTestOrigin);
+  SetPermission(origin, CONTENT_SETTING_ALLOW);
 
   // (1) Make sure that |kExampleOrigin| has access to use Push Messaging.
   ASSERT_EQ(blink::mojom::PermissionStatus::GRANTED,
@@ -349,10 +370,12 @@ TEST_F(PushMessagingServiceTest, MAYBE_RemoveExpiredSubscriptions) {
       /* disabled features */
       {});
 
+  const GURL origin(kTestOrigin);
+  SetPermission(origin, CONTENT_SETTING_ALLOW);
+
   // (2) Set up push service and test origin
   PushMessagingServiceImpl* push_service = profile()->GetPushMessagingService();
   ASSERT_TRUE(push_service);
-  const GURL origin(kTestOrigin);
 
   // (3) Subscribe origin to push service and find corresponding
   // |app_identifier|
@@ -384,11 +407,21 @@ TEST_F(PushMessagingServiceTest, MAYBE_RemoveExpiredSubscriptions) {
 
 TEST_F(PushMessagingServiceTest, TestMultipleIncomingPushMessages) {
   base::HistogramTester histograms;
+
+  const GURL origin(kTestOrigin);
+  SetPermission(origin, CONTENT_SETTING_ALLOW);
+
   PushMessagingServiceImpl* push_service = profile()->GetPushMessagingService();
   ASSERT_TRUE(push_service);
 
+#if BUILDFLAG(IS_ANDROID)
+  // Without Android app-level Notifications permission a push message will be
+  // ignored.
+  push_service->set_enabled_app_level_notification_permission_for_testing(true);
+  push_service->set_prefs_for_testing(get_pref());
+#endif
+
   // Subscribe |origin| to push service.
-  const GURL origin(kTestOrigin);
   Subscribe(push_service, origin);
   PushMessagingAppIdentifier app_identifier =
       PushMessagingAppIdentifier::FindByServiceWorker(profile(), origin,
@@ -477,3 +510,329 @@ TEST_F(PushMessagingServiceTest, TestMultipleIncomingPushMessages) {
                                    kPushEventHandleTime * 2,
                                    /*count=*/1);
 }
+
+#if BUILDFLAG(IS_ANDROID)
+class FCMRevocationTest : public PushMessagingServiceTest {
+ public:
+  FCMRevocationTest() {
+    scoped_feature_list_.InitAndEnableFeature(
+        features::kRevokeNotificationsPermissionIfDisabledOnAppLevel);
+  }
+
+  ~FCMRevocationTest() override = default;
+
+ private:
+  base::test::ScopedFeatureList scoped_feature_list_;
+};
+
+// Tests that the grace period preferences will be cleared if app-level
+// permissions are enabled.
+TEST_F(FCMRevocationTest, TestPermissionRevocationClearPreferences) {
+  const GURL origin(kTestOrigin);
+  SetPermission(origin, CONTENT_SETTING_ALLOW);
+
+  const char kNotificationsPermissionRevocationGracePeriodDate[] =
+      "notifications_permission_revocation_grace_period";
+
+  PushMessagingServiceImpl* push_service = profile()->GetPushMessagingService();
+  ASSERT_TRUE(push_service);
+
+  // Without Android app-level Notifications permission a push message will be
+  // ignored.
+  push_service->set_enabled_app_level_notification_permission_for_testing(true);
+  push_service->set_prefs_for_testing(get_pref());
+
+  // Just random value to make sure it is reset.
+  base::Time time = base::Time::FromTimeT(100);
+
+  get_pref()->SetTime(kNotificationsPermissionRevocationGracePeriodDate, time);
+
+  // (1) Make sure that |kExampleOrigin| has access to use Push Messaging.
+  ASSERT_TRUE(push_service->IsPermissionSet(origin, true /* user_visible */));
+
+  // (2) Subscribe for Push Messaging, and verify that we've got the required
+  // information in order to be able to create encrypted messages.
+  TestPushSubscription subscription;
+  Subscribe(push_service, origin, &subscription);
+
+  // (3) Encrypt a message using the public key and authentication secret that
+  // are associated with the subscription.
+
+  gcm::IncomingMessage message;
+  message.sender_id = kTestSenderId;
+
+  ASSERT_TRUE(gcm::CreateEncryptedPayloadForTesting(
+      kTestPayload,
+      base::StringPiece(reinterpret_cast<char*>(subscription.p256dh_.data()),
+                        subscription.p256dh_.size()),
+      base::StringPiece(reinterpret_cast<char*>(subscription.auth_.data()),
+                        subscription.auth_.size()),
+      &message));
+
+  ASSERT_GT(message.raw_data.size(), 0u);
+  ASSERT_NE(kTestPayload, message.raw_data);
+  ASSERT_FALSE(message.decrypted);
+
+  // (4) Find the app_id that has been associated with the subscription.
+  PushMessagingAppIdentifier app_identifier =
+      PushMessagingAppIdentifier::FindByServiceWorker(profile(), origin,
+                                                      kTestServiceWorkerId);
+
+  ASSERT_FALSE(app_identifier.is_null());
+
+  std::string app_id;
+  GURL dispatched_origin;
+  int64_t service_worker_registration_id;
+  absl::optional<std::string> payload;
+
+  // (5) Observe message dispatchings from the Push Messaging service, and
+  // then dispatch the |message| on the GCM driver as if it had actually
+  // been received by Google Cloud Messaging.
+  push_service->SetMessageDispatchedCallbackForTesting(base::BindRepeating(
+      &PushMessagingServiceTest::DidDispatchMessage, base::Unretained(this),
+      &app_id, &dispatched_origin, &service_worker_registration_id, &payload));
+
+  gcm::FakeGCMProfileService* fake_profile_service =
+      static_cast<gcm::FakeGCMProfileService*>(
+          gcm::GCMProfileServiceFactory::GetForProfile(profile()));
+
+  fake_profile_service->DispatchMessage(app_identifier.app_id(), message);
+
+  base::RunLoop().RunUntilIdle();
+
+  // (6) Verify that the message, as received by the Push Messaging Service, has
+  // indeed been decrypted by the GCM Driver, and has been forwarded to the
+  // Service Worker that has been associated with the subscription.
+  EXPECT_EQ(app_identifier.app_id(), app_id);
+  EXPECT_EQ(origin, dispatched_origin);
+  EXPECT_EQ(service_worker_registration_id, kTestServiceWorkerId);
+
+  EXPECT_TRUE(payload);
+  EXPECT_EQ(kTestPayload, *payload);
+
+  base::Time grace_period_date =
+      get_pref()->GetTime(kNotificationsPermissionRevocationGracePeriodDate);
+  EXPECT_EQ(grace_period_date, base::Time());
+  EXPECT_NE(grace_period_date, time);
+
+  // (7) |kExampleOrigin| still has access to use Push Messaging.
+  ASSERT_TRUE(push_service->IsPermissionSet(origin, true /* user_visible */));
+}
+
+// Tests that the grace period is not enabled, and no app-level permission.
+// Ignore a push message.
+TEST_F(FCMRevocationTest, TestPermissionRevocationNoPermissionFirstMessage) {
+  base::HistogramTester histogram_tester;
+  const GURL origin(kTestOrigin);
+  SetPermission(origin, CONTENT_SETTING_ALLOW);
+
+  const char kNotificationsPermissionRevocationGracePeriodDate[] =
+      "notifications_permission_revocation_grace_period";
+
+  PushMessagingServiceImpl* push_service = profile()->GetPushMessagingService();
+  ASSERT_TRUE(push_service);
+
+  // Without Android app-level Notifications permission a push message will be
+  // ignored.
+  push_service->set_enabled_app_level_notification_permission_for_testing(
+      false);
+  push_service->set_prefs_for_testing(get_pref());
+
+  // (1) Make sure that |kExampleOrigin| has access to use Push Messaging.
+  ASSERT_TRUE(push_service->IsPermissionSet(origin, true /* user_visible */));
+
+  // (2) Subscribe for Push Messaging, and verify that we've got the required
+  // information in order to be able to create encrypted messages.
+  TestPushSubscription subscription;
+  Subscribe(push_service, origin, &subscription);
+
+  // (3) Encrypt a message using the public key and authentication secret that
+  // are associated with the subscription.
+  gcm::IncomingMessage message;
+  message.sender_id = kTestSenderId;
+
+  ASSERT_TRUE(gcm::CreateEncryptedPayloadForTesting(
+      kTestPayload,
+      base::StringPiece(reinterpret_cast<char*>(subscription.p256dh_.data()),
+                        subscription.p256dh_.size()),
+      base::StringPiece(reinterpret_cast<char*>(subscription.auth_.data()),
+                        subscription.auth_.size()),
+      &message));
+
+  ASSERT_GT(message.raw_data.size(), 0u);
+  ASSERT_NE(kTestPayload, message.raw_data);
+  ASSERT_FALSE(message.decrypted);
+
+  // (4) Find the app_id that has been associated with the subscription.
+  PushMessagingAppIdentifier app_identifier =
+      PushMessagingAppIdentifier::FindByServiceWorker(profile(), origin,
+                                                      kTestServiceWorkerId);
+
+  ASSERT_FALSE(app_identifier.is_null());
+
+  std::string app_id;
+  GURL dispatched_origin;
+  int64_t service_worker_registration_id;
+  absl::optional<std::string> payload;
+
+  // (5) Observe message dispatchings from the Push Messaging service, and
+  // then dispatch the |message| on the GCM driver as if it had actually
+  // been received by Google Cloud Messaging.
+  push_service->SetMessageDispatchedCallbackForTesting(base::BindRepeating(
+      &PushMessagingServiceTest::DidDispatchMessage, base::Unretained(this),
+      &app_id, &dispatched_origin, &service_worker_registration_id, &payload));
+
+  gcm::FakeGCMProfileService* fake_profile_service =
+      static_cast<gcm::FakeGCMProfileService*>(
+          gcm::GCMProfileServiceFactory::GetForProfile(profile()));
+
+  fake_profile_service->DispatchMessage(app_identifier.app_id(), message);
+
+  base::RunLoop().RunUntilIdle();
+
+  // (6) Verify that the message, as received by the Push Messaging Service, has
+  // not been decrypted by the GCM Driver, and has not been forwarded to the
+  // Service Worker that has been associated with the subscription.
+  EXPECT_NE(app_identifier.app_id(), app_id);
+  EXPECT_NE(origin, dispatched_origin);
+  EXPECT_NE(service_worker_registration_id, kTestServiceWorkerId);
+
+  EXPECT_FALSE(payload);
+
+  // The grace period date has been changed.
+  EXPECT_NE(
+      get_pref()->GetTime(kNotificationsPermissionRevocationGracePeriodDate),
+      base::Time());
+
+  // (7) |kExampleOrigin| still has access to use Push Messaging.
+  ASSERT_TRUE(push_service->IsPermissionSet(origin, true /* user_visible */));
+
+  histogram_tester.ExpectUniqueSample(
+      "PushMessaging.DeliveryStatus",
+      static_cast<int>(
+          blink::mojom::PushEventStatus::NO_APP_LEVEL_PERMISSION_IGNORE),
+      1);
+
+  histogram_tester.ExpectTotalCount("PushMessaging.UnregistrationReason", 0);
+}
+
+// Tests that the grace period was enabled more than 3 days ago, and no
+// app-level permission. An incoming push message should be ignored and
+// origin-level Notifications permission should be revoked to prevent further
+// push messages.
+TEST_F(FCMRevocationTest, TestPermissionRevocationGracePeriodIsOver) {
+  base::HistogramTester histogram_tester;
+  const GURL origin(kTestOrigin);
+  SetPermission(origin, CONTENT_SETTING_ALLOW);
+
+  const char kNotificationsPermissionRevocationGracePeriodDate[] =
+      "notifications_permission_revocation_grace_period";
+
+  PushMessagingServiceImpl* push_service = profile()->GetPushMessagingService();
+  ASSERT_TRUE(push_service);
+
+  // Without Android app-level Notifications permission a push message will be
+  // ignored.
+  push_service->set_enabled_app_level_notification_permission_for_testing(
+      false);
+  push_service->set_prefs_for_testing(get_pref());
+
+  // Init `time` with 4 days old time value.
+  const base::Time time = base::Time::FromDeltaSinceWindowsEpoch(
+      base::Time::Now() -
+      base::Time::FromDeltaSinceWindowsEpoch(base::Days(4)));
+  // Init the grace period date with a value that is older than 3 days (the
+  // default grace period).
+  get_pref()->SetTime(kNotificationsPermissionRevocationGracePeriodDate, time);
+
+  // (1) Make sure that |kExampleOrigin| has access to use Push Messaging.
+  ASSERT_TRUE(push_service->IsPermissionSet(origin, true /* user_visible */));
+
+  // (2) Subscribe for Push Messaging, and verify that we've got the required
+  // information in order to be able to create encrypted messages.
+  TestPushSubscription subscription;
+  Subscribe(push_service, origin, &subscription);
+
+  // (3) Encrypt a message using the public key and authentication secret that
+  // are associated with the subscription.
+  gcm::IncomingMessage message;
+  message.sender_id = kTestSenderId;
+
+  ASSERT_TRUE(gcm::CreateEncryptedPayloadForTesting(
+      kTestPayload,
+      base::StringPiece(reinterpret_cast<char*>(subscription.p256dh_.data()),
+                        subscription.p256dh_.size()),
+      base::StringPiece(reinterpret_cast<char*>(subscription.auth_.data()),
+                        subscription.auth_.size()),
+      &message));
+
+  ASSERT_GT(message.raw_data.size(), 0u);
+  ASSERT_NE(kTestPayload, message.raw_data);
+  ASSERT_FALSE(message.decrypted);
+
+  // (4) Find the app_id that has been associated with the subscription.
+  PushMessagingAppIdentifier app_identifier =
+      PushMessagingAppIdentifier::FindByServiceWorker(profile(), origin,
+                                                      kTestServiceWorkerId);
+
+  ASSERT_FALSE(app_identifier.is_null());
+
+  std::string app_id;
+  GURL dispatched_origin;
+  int64_t service_worker_registration_id;
+  absl::optional<std::string> payload;
+
+  // (5) Observe message dispatchings from the Push Messaging service, and
+  // then dispatch the |message| on the GCM driver as if it had actually
+  // been received by Google Cloud Messaging.
+  push_service->SetMessageDispatchedCallbackForTesting(base::BindRepeating(
+      &PushMessagingServiceTest::DidDispatchMessage, base::Unretained(this),
+      &app_id, &dispatched_origin, &service_worker_registration_id, &payload));
+
+  gcm::FakeGCMProfileService* fake_profile_service =
+      static_cast<gcm::FakeGCMProfileService*>(
+          gcm::GCMProfileServiceFactory::GetForProfile(profile()));
+
+  fake_profile_service->DispatchMessage(app_identifier.app_id(), message);
+
+  base::RunLoop().RunUntilIdle();
+
+  // (6) Verify that the message, as received by the Push Messaging Service, has
+  // not been decrypted by the GCM Driver, and has not been forwarded to the
+  // Service Worker that has been associated with the subscription.
+  EXPECT_NE(app_identifier.app_id(), app_id);
+  EXPECT_NE(origin, dispatched_origin);
+  EXPECT_NE(service_worker_registration_id, kTestServiceWorkerId);
+
+  EXPECT_FALSE(payload);
+
+  // The grace period date has not been changed.
+  EXPECT_EQ(
+      get_pref()->GetTime(kNotificationsPermissionRevocationGracePeriodDate),
+      time);
+
+  // (7) |kExampleOrigin| has no access to use Push Messaging.
+  EXPECT_FALSE(push_service->IsPermissionSet(origin, true /* user_visible */));
+
+  histogram_tester.ExpectUniqueSample(
+      "PushMessaging.DeliveryStatus",
+      static_cast<int>(
+          blink::mojom::PushEventStatus::NO_APP_LEVEL_PERMISSION_UNSUBSCRIBE),
+      1);
+
+  // 1st event - blink::mojom::PushUnregistrationReason::PERMISSION_REVOKED,
+  // because `PushMessagingServiceImpl::OnContentSettingChanged` will be
+  // notified when Notifications permission is revoked.
+  //
+  // 2nd event -
+  // blink::mojom::PushUnregistrationReason::NO_APP_LEVEL_PERMISSION.
+  histogram_tester.ExpectTotalCount("PushMessaging.UnregistrationReason", 2);
+
+  histogram_tester.ExpectBucketCount(
+      "PushMessaging.UnregistrationReason",
+      blink::mojom::PushUnregistrationReason::PERMISSION_REVOKED, 1);
+  histogram_tester.ExpectBucketCount(
+      "PushMessaging.UnregistrationReason",
+      blink::mojom::PushUnregistrationReason::NO_APP_LEVEL_PERMISSION, 1);
+}
+#endif
diff --git a/components/permissions/android/BUILD.gn b/components/permissions/android/BUILD.gn
index a0711ec39bf56..b7c3ff876420f 100644
--- a/components/permissions/android/BUILD.gn
+++ b/components/permissions/android/BUILD.gn
@@ -147,6 +147,7 @@ android_library("core_java") {
     "//base:jni_java",
     "//build/android:build_java",
     "//components/content_settings/android:content_settings_enums_java",
+    "//third_party/androidx:androidx_core_core_java",
     "//ui/android:ui_no_recycler_view_java",
   ]
   annotation_processor_deps = [ "//base/android/jni_generator:jni_processor" ]
diff --git a/components/permissions/android/android_permission_util.cc b/components/permissions/android/android_permission_util.cc
index 303936e1a52aa..a64f09b050577 100644
--- a/components/permissions/android/android_permission_util.cc
+++ b/components/permissions/android/android_permission_util.cc
@@ -73,4 +73,9 @@ bool DoesAppLevelSettingsAllowSiteNotifications() {
   return Java_PermissionUtil_doesAppLevelSettingsAllowSiteNotifications(env);
 }
 
+bool AreAppLevelNotificationsEnabled() {
+  JNIEnv* env = base::android::AttachCurrentThread();
+  return Java_PermissionUtil_areAppLevelNotificationsEnabled(env);
+}
+
 }  // namespace permissions
diff --git a/components/permissions/android/android_permission_util.h b/components/permissions/android/android_permission_util.h
index 9fdae6da8edb9..dc55d9acd6f7e 100644
--- a/components/permissions/android/android_permission_util.h
+++ b/components/permissions/android/android_permission_util.h
@@ -54,10 +54,14 @@ PermissionRepromptState ShouldRepromptUserForPermissions(
     content::WebContents* web_contents,
     const std::vector<ContentSettingsType>& content_settings_types);
 
-// Called to check whether chrome settings and permissions allow requesting site
+// Called to check whether Chrome settings and permissions allow requesting site
 // level notification permission.
 bool DoesAppLevelSettingsAllowSiteNotifications();
 
+// Called to check whether Chrome has enabled app-level Notifications
+// permission.
+bool AreAppLevelNotificationsEnabled();
+
 }  // namespace permissions
 
 #endif  // COMPONENTS_PERMISSIONS_ANDROID_ANDROID_PERMISSION_UTIL_H_
diff --git a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionUtil.java b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionUtil.java
index ec7623ff78763..3c2a232fc1f0c 100644
--- a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionUtil.java
+++ b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionUtil.java
@@ -6,7 +6,10 @@ package org.chromium.components.permissions;
 
 import android.os.Build;
 
+import androidx.core.app.NotificationManagerCompat;
+
 import org.chromium.base.BuildInfo;
+import org.chromium.base.ContextUtils;
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.components.content_settings.ContentSettingsType;
 import org.chromium.ui.permissions.ContextualNotificationPermissionRequester;
@@ -119,4 +122,11 @@ public class PermissionUtil {
         return contextualPermissionRequester != null
                 && contextualPermissionRequester.doesAppLevelSettingsAllowSiteNotifications();
     }
+
+    @CalledByNative
+    private static boolean areAppLevelNotificationsEnabled() {
+        NotificationManagerCompat manager =
+                NotificationManagerCompat.from(ContextUtils.getApplicationContext());
+        return manager.areNotificationsEnabled();
+    }
 }
diff --git a/components/permissions/permission_manager_unittest.cc b/components/permissions/permission_manager_unittest.cc
index ea7cd309b45c8..43cac84c1a602 100644
--- a/components/permissions/permission_manager_unittest.cc
+++ b/components/permissions/permission_manager_unittest.cc
@@ -749,6 +749,45 @@ TEST_F(PermissionManagerTest, KillSwitchOnIsNotOverridable) {
                                                  kLocalHost));
 }
 
+TEST_F(PermissionManagerTest, ResetPermission) {
+#if BUILDFLAG(IS_ANDROID)
+  CheckPermissionStatus(PermissionType::NOTIFICATIONS, PermissionStatus::ASK);
+  SetPermission(ContentSettingsType::NOTIFICATIONS, CONTENT_SETTING_ALLOW);
+  CheckPermissionStatus(PermissionType::NOTIFICATIONS,
+                        PermissionStatus::GRANTED);
+
+  ResetPermission(PermissionType::NOTIFICATIONS, url(), url());
+
+  CheckPermissionStatus(PermissionType::NOTIFICATIONS, PermissionStatus::ASK);
+#else
+  const char* kOrigin1 = "https://example.com";
+
+  NavigateAndCommit(GURL(kOrigin1));
+  content::RenderFrameHost* rfh = main_rfh();
+
+  EXPECT_EQ(PermissionStatus::ASK, GetPermissionStatusForCurrentDocument(
+                                       PermissionType::NOTIFICATIONS, rfh));
+
+  PermissionRequestManager::CreateForWebContents(web_contents());
+  PermissionRequestManager* manager =
+      PermissionRequestManager::FromWebContents(web_contents());
+  auto prompt_factory = std::make_unique<MockPermissionPromptFactory>(manager);
+  prompt_factory->set_response_type(PermissionRequestManager::ACCEPT_ALL);
+  prompt_factory->DocumentOnLoadCompletedInPrimaryMainFrame();
+
+  RequestPermissionFromCurrentDocument(PermissionType::NOTIFICATIONS, rfh);
+
+  EXPECT_EQ(PermissionStatus::GRANTED, GetPermissionStatusForCurrentDocument(
+                                           PermissionType::NOTIFICATIONS, rfh));
+
+  ResetPermission(PermissionType::NOTIFICATIONS, GURL(kOrigin1),
+                  GURL(kOrigin1));
+
+  EXPECT_EQ(PermissionStatus::ASK, GetPermissionStatusForCurrentDocument(
+                                       PermissionType::NOTIFICATIONS, rfh));
+#endif
+}
+
 TEST_F(PermissionManagerTest, GetPermissionStatusDelegation) {
   const char* kOrigin1 = "https://example.com";
   const char* kOrigin2 = "https://google.com";
diff --git a/content/browser/permissions/permission_controller_impl.cc b/content/browser/permissions/permission_controller_impl.cc
index eb4d67e00860b..4f292be8d8535 100644
--- a/content/browser/permissions/permission_controller_impl.cc
+++ b/content/browser/permissions/permission_controller_impl.cc
@@ -329,6 +329,11 @@ void PermissionControllerImpl::RequestPermissionsFromCurrentDocument(
       std::move(wrapper));
 }
 
+void PermissionControllerImpl::ResetPermission(blink::PermissionType permission,
+                                               const url::Origin& origin) {
+  ResetPermission(permission, origin.GetURL(), origin.GetURL());
+}
+
 blink::mojom::PermissionStatus
 PermissionControllerImpl::DeprecatedGetPermissionStatus(
     PermissionType permission,
diff --git a/content/browser/permissions/permission_controller_impl.h b/content/browser/permissions/permission_controller_impl.h
index 15b9dfdbd3256..613867c91b314 100644
--- a/content/browser/permissions/permission_controller_impl.h
+++ b/content/browser/permissions/permission_controller_impl.h
@@ -105,6 +105,8 @@ class CONTENT_EXPORT PermissionControllerImpl : public PermissionController {
       base::OnceCallback<
           void(const std::vector<blink::mojom::PermissionStatus>&)> callback)
       override;
+  void ResetPermission(blink::PermissionType permission,
+                       const url::Origin& origin) override;
 
   struct Subscription;
   using SubscriptionsMap =
diff --git a/content/public/browser/permission_controller.h b/content/public/browser/permission_controller.h
index d31c2be2fba4e..87b87851c64fc 100644
--- a/content/public/browser/permission_controller.h
+++ b/content/public/browser/permission_controller.h
@@ -79,6 +79,10 @@ class CONTENT_EXPORT PermissionController
       bool user_gesture,
       base::OnceCallback<void(
           const std::vector<blink::mojom::PermissionStatus>&)> callback) = 0;
+
+  // Sets the permission back to its default for the `origin`.
+  virtual void ResetPermission(blink::PermissionType permission,
+                               const url::Origin& origin) = 0;
 };
 
 }  // namespace content
diff --git a/content/public/test/mock_permission_controller.cc b/content/public/test/mock_permission_controller.cc
index e5962c340c61a..645e9f9e22857 100644
--- a/content/public/test/mock_permission_controller.cc
+++ b/content/public/test/mock_permission_controller.cc
@@ -22,4 +22,7 @@ void MockPermissionController::RequestPermissionsFromCurrentDocument(
     bool user_gesture,
     base::OnceCallback<void(const std::vector<blink::mojom::PermissionStatus>&)>
         callback) {}
+
+void MockPermissionController::ResetPermission(blink::PermissionType permission,
+                                               const url::Origin& origin) {}
 }  // namespace content
diff --git a/content/public/test/mock_permission_controller.h b/content/public/test/mock_permission_controller.h
index e8c8c1176b367..0a8b14a21312a 100644
--- a/content/public/test/mock_permission_controller.h
+++ b/content/public/test/mock_permission_controller.h
@@ -55,6 +55,8 @@ class MockPermissionController : public PermissionController {
       base::OnceCallback<
           void(const std::vector<blink::mojom::PermissionStatus>&)> callback)
       override;
+  void ResetPermission(blink::PermissionType permission,
+                       const url::Origin& origin) override;
 };
 
 }  // namespace content
diff --git a/third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom b/third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom
index cd01c03e4cd8d..0a2c918be331f 100644
--- a/third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom
+++ b/third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom
@@ -34,6 +34,15 @@ enum PushEventStatus {
   // to origin marked as abusive.
   PERMISSION_REVOKED_ABUSIVE = 8,
 
+  // The event could not be delivered because the browser has no app-level
+  // Notifications permission. The push message was ignored.
+  NO_APP_LEVEL_PERMISSION_IGNORE = 9,
+
+  // The event could not be delivered because the browser has no app-level
+  // Notifications permission. The push message was ignored. The site-level
+  // Notifications permission and FCM were revoked.
+  NO_APP_LEVEL_PERMISSION_UNSUBSCRIBE = 10,
+
   // NOTE: Do not renumber or delete these as that would confuse interpretation
   // of previously logged data. When making changes, also update the enum list
   // in tools/metrics/histograms/histograms.xml to keep it in sync.
@@ -197,6 +206,10 @@ enum PushUnregistrationReason {
   // Unregistering because permissions was auto-revoked due to abuse.
   PERMISSION_REVOKED_ABUSIVE = 13,
 
+  // Unregistering because no app-level Notifications permission after the grace
+  // period is over.
+  NO_APP_LEVEL_PERMISSION = 14,
+
   // NOTE: Do not renumber or delete these as that would confuse interpretation
   // of previously logged data. When making changes, also update the enum list
   // in tools/metrics/histograms/histograms.xml to keep it in sync.
