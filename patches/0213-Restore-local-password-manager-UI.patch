From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: quh4gko8 <88831734+quh4gko8@users.noreply.github.com>
Date: Tue, 29 Jul 2025 15:41:41 +0000
Subject: [PATCH] Restore local password manager UI

Revert "[passwords/android] Remove unused PasswordSettings.java"

This reverts commit 3662471ee9fabd6d1777b1d5316f0b9eede0f115.
---
 chrome/android/chrome_java_resources.gni      |   2 +
 chrome/android/chrome_java_sources.gni        |   1 +
 .../java/res/layout/password_no_result.xml    |  35 +
 ...e_password_preferences_action_bar_menu.xml |  29 +
 .../android/java/res/xml/main_preferences.xml |   1 +
 .../settings/PasswordSettings.java            | 618 ++++++++++++++++++
 .../settings/SettingsNavigationImpl.java      |   4 +
 chrome/android/javatests/BUILD.gn             |   4 +
 .../settings/PasswordSettingsSearchTest.java  | 534 +++++++++++++++
 .../settings/PasswordSettingsTest.java        | 383 +++++++++++
 .../settings/PasswordSettingsTestHelper.java  | 193 ++++++
 .../settings/PasswordViewingTypeTest.java     | 107 +++
 .../settings/MainSettingsFragmentTest.java    |   3 +-
 chrome/browser/BUILD.gn                       |   2 +
 .../browser/password_manager/android/BUILD.gn |  10 +
 .../PasswordManagerHelper.java                |   3 +
 .../password_manager/settings/ExportFlow.java | 606 +++++++++++++++++
 .../settings/ExportFlowInterface.java         |  92 +++
 .../settings/PasswordListObserver.java        |  28 +
 .../settings/PasswordManagerHandler.java      |  83 +++
 .../PasswordManagerHandlerProvider.java       | 144 ++++
 .../settings/PasswordUiView.java              | 191 ++++++
 .../settings/ProgressBarDialogFragment.java   |  70 ++
 .../settings/SavedPasswordEntry.java          |  41 ++
 .../settings/ReauthenticationManagerTest.java |   2 +-
 .../android/password_ui_view_android.cc       | 365 +++++++++++
 .../android/password_ui_view_android.h        | 170 +++++
 .../password_ui_view_android_unittest.cc      | 198 ++++++
 .../FakePasswordManagerHandler.java           | 135 ++++
 .../strings/android_chrome_strings.grd        |  51 ++
 ...NDROID_TRUSTED_VAULT_BANNER_LABEL.png.sha1 |   1 +
 ...ULT_BANNER_SUB_LABEL_OFFER_OPT_IN.png.sha1 |   1 +
 ...D_VAULT_BANNER_SUB_LABEL_OPTED_IN.png.sha1 |   1 +
 .../IDS_PASSWORDS_CHECK_DESCRIPTION.png.sha1  |   1 +
 .../IDS_PASSWORD_NO_RESULT.png.sha1           |   1 +
 chrome/test/BUILD.gn                          |   1 +
 .../settings/SettingsNavigation.java          |  11 +-
 37 files changed, 4116 insertions(+), 6 deletions(-)
 create mode 100644 chrome/android/java/res/layout/password_no_result.xml
 create mode 100644 chrome/android/java/res/menu/save_password_preferences_action_bar_menu.xml
 create mode 100644 chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
 create mode 100644 chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsSearchTest.java
 create mode 100644 chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTest.java
 create mode 100644 chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTestHelper.java
 create mode 100644 chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordViewingTypeTest.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlow.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlowInterface.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordListObserver.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandler.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandlerProvider.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ProgressBarDialogFragment.java
 create mode 100644 chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/SavedPasswordEntry.java
 create mode 100644 chrome/browser/password_manager/android/password_ui_view_android.cc
 create mode 100644 chrome/browser/password_manager/android/password_ui_view_android.h
 create mode 100644 chrome/browser/password_manager/android/password_ui_view_android_unittest.cc
 create mode 100644 chrome/browser/password_manager/android/test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordManagerHandler.java
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_LABEL.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OFFER_OPT_IN.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OPTED_IN.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORDS_CHECK_DESCRIPTION.png.sha1
 create mode 100644 chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_NO_RESULT.png.sha1

diff --git a/chrome/android/chrome_java_resources.gni b/chrome/android/chrome_java_resources.gni
index f76740aa156eb..77dca0f14071c 100644
--- a/chrome/android/chrome_java_resources.gni
+++ b/chrome/android/chrome_java_resources.gni
@@ -556,6 +556,7 @@ chrome_java_resources = [
   "java/res/layout/password_manager_dialog.xml",
   "java/res/layout/page_zoom_menu_item.xml",
   "java/res/layout/password_manager_dialog_with_help_button.xml",
+  "java/res/layout/password_no_result.xml",
   "java/res/layout/powered_by_chrome_footer.xml",
   "java/res/layout/radio_button_group_homepage_preference.xml",
   "java/res/layout/reader_mode_bottom_sheet.xml",
@@ -599,6 +600,7 @@ chrome_java_resources = [
   "java/res/menu/bookmark_folder_picker_menu.xml",
   "java/res/menu/bookmark_toolbar_menu_improved.xml",
   "java/res/menu/history_manager_menu.xml",
+  "java/res/menu/save_password_preferences_action_bar_menu.xml",
   "java/res/raw/composeplate_loop_dark.json",
   "java/res/raw/composeplate_loop_light.json",
   "java/res/transition/fade.xml",
diff --git a/chrome/android/chrome_java_sources.gni b/chrome/android/chrome_java_sources.gni
index 3ec1acbe4b234..86cc1f719e7a2 100644
--- a/chrome/android/chrome_java_sources.gni
+++ b/chrome/android/chrome_java_sources.gni
@@ -876,6 +876,7 @@ chrome_java_sources = [
   "java/src/org/chromium/chrome/browser/password_manager/PasswordManagerErrorMessageHelperBridge.java",
   "java/src/org/chromium/chrome/browser/password_manager/PasswordManagerLauncher.java",
   "java/src/org/chromium/chrome/browser/password_manager/settings/ManualCallbackDelayer.java",
+  "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java",
   "java/src/org/chromium/chrome/browser/payments/AddressEditor.java",
   "java/src/org/chromium/chrome/browser/payments/AutofillContact.java",
   "java/src/org/chromium/chrome/browser/payments/ChromePaymentRequestFactory.java",
diff --git a/chrome/android/java/res/layout/password_no_result.xml b/chrome/android/java/res/layout/password_no_result.xml
new file mode 100644
index 0000000000000..91b0d4e44c00e
--- /dev/null
+++ b/chrome/android/java/res/layout/password_no_result.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2020 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <org.chromium.components.browser_ui.widget.MaterialCardViewNoShadow
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"
+        android:layout_marginStart="16dp"
+        android:layout_marginEnd="16dp"
+        android:foreground="@drawable/button_borderless_compat"
+        style="@style/MaterialCardStyle">
+
+        <org.chromium.ui.widget.TextViewWithLeading
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:padding="@dimen/card_padding"
+            android:text="@string/password_no_result"
+            android:textAlignment="center"
+            android:textAppearance="@style/TextAppearance.TextMedium.Secondary"
+            app:leading="@dimen/text_size_medium_leading" />
+
+    </org.chromium.components.browser_ui.widget.MaterialCardViewNoShadow>
+
+</FrameLayout>
diff --git a/chrome/android/java/res/menu/save_password_preferences_action_bar_menu.xml b/chrome/android/java/res/menu/save_password_preferences_action_bar_menu.xml
new file mode 100644
index 0000000000000..36fa645fa6cb7
--- /dev/null
+++ b/chrome/android/java/res/menu/save_password_preferences_action_bar_menu.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+Copyright 2017 The Chromium Authors
+Use of this source code is governed by a BSD-style license that can be
+found in the LICENSE file.
+-->
+
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto" >
+
+    <item
+        android:id="@+id/menu_id_search"
+        android:icon="@drawable/ic_search"
+        android:title="@string/search"
+        app:showAsAction="always"
+        app:actionViewClass="androidx.appcompat.widget.SearchView" />
+
+    <item
+        android:id="@id/menu_id_targeted_help"
+        android:icon="@drawable/ic_help_and_feedback"
+        android:title="@string/menu_help"
+        app:showAsAction="ifRoom"/>
+
+    <item
+        android:id="@+id/export_passwords"
+        android:title="@string/password_settings_export_action_title"
+        android:contentDescription="@string/password_settings_export_action_description"
+        app:showAsAction="never"/>
+</menu>
diff --git a/chrome/android/java/res/xml/main_preferences.xml b/chrome/android/java/res/xml/main_preferences.xml
index 7a5712a911f45..2666cbec4e52e 100644
--- a/chrome/android/java/res/xml/main_preferences.xml
+++ b/chrome/android/java/res/xml/main_preferences.xml
@@ -61,6 +61,7 @@ found in the LICENSE file.
         android:order="11"
         android:title="@string/prefs_section_autofill"/>
     <org.chromium.chrome.browser.password_manager.settings.PasswordsPreference
+        android:fragment="org.chromium.chrome.browser.password_manager.settings.PasswordSettings"
         android:key="passwords"
         android:order="12"
         android:title="@string/password_manager_settings_title"/>
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java b/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
new file mode 100644
index 0000000000000..da1bd2e95e619
--- /dev/null
+++ b/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
@@ -0,0 +1,618 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static org.chromium.build.NullUtil.assumeNonNull;
+import static org.chromium.chrome.browser.password_manager.PasswordMetricsUtil.PASSWORD_SETTINGS_EXPORT_METRICS_ID;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.text.SpannableString;
+import android.text.style.ForegroundColorSpan;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.StringRes;
+import androidx.appcompat.widget.Toolbar;
+import androidx.fragment.app.FragmentManager;
+import androidx.preference.Preference;
+import androidx.preference.PreferenceCategory;
+import androidx.preference.PreferenceGroup;
+
+import org.chromium.base.DeviceInfo;
+import org.chromium.base.metrics.RecordHistogram;
+import org.chromium.base.supplier.ObservableSupplier;
+import org.chromium.base.supplier.ObservableSupplierImpl;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.chrome.R;
+import org.chromium.chrome.browser.password_manager.ManagePasswordsReferrer;
+import org.chromium.chrome.browser.password_manager.PasswordManagerHelper;
+import org.chromium.chrome.browser.preferences.Pref;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.chrome.browser.settings.ChromeBaseSettingsFragment;
+import org.chromium.chrome.browser.settings.ChromeManagedPreferenceDelegate;
+import org.chromium.chrome.browser.sync.SyncServiceFactory;
+import org.chromium.chrome.browser.sync.settings.SyncSettingsUtils;
+import org.chromium.components.browser_ui.settings.ChromeBasePreference;
+import org.chromium.components.browser_ui.settings.ChromeSwitchPreference;
+import org.chromium.components.browser_ui.settings.SearchUtils;
+import org.chromium.components.browser_ui.settings.TextMessagePreference;
+import org.chromium.components.browser_ui.styles.SemanticColorUtils;
+import org.chromium.components.prefs.PrefService;
+import org.chromium.components.signin.base.CoreAccountInfo;
+import org.chromium.components.sync.PassphraseType;
+import org.chromium.components.sync.SyncService;
+import org.chromium.components.user_prefs.UserPrefs;
+import org.chromium.ui.text.SpanApplier;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Locale;
+
+/**
+ * The "Passwords" screen in Settings, which allows the user to enable or disable password saving,
+ * to view saved passwords (just the username and URL), and to delete saved passwords.
+ *
+ * <p>TODO: crbug.com/372657804 - Make sure that the PasswordSettings is not created in UPM M4.1
+ */
+@NullMarked
+public class PasswordSettings extends ChromeBaseSettingsFragment
+        implements PasswordListObserver,
+                Preference.OnPreferenceClickListener,
+                SyncService.SyncStateChangedListener {
+
+    // Keys for name/password dictionaries.
+    public static final String PASSWORD_LIST_URL = "url";
+    public static final String PASSWORD_LIST_NAME = "name";
+    public static final String PASSWORD_LIST_PASSWORD = "password";
+
+    // Used to pass the password id into a new activity.
+    public static final String PASSWORD_LIST_ID = "id";
+
+    // The key for saving |mSearchQuery| to instance bundle.
+    private static final String SAVED_STATE_SEARCH_QUERY = "saved-state-search-query";
+
+    public static final String PREF_SAVE_PASSWORDS_SWITCH = "save_passwords_switch";
+    public static final String PREF_AUTOSIGNIN_SWITCH = "autosignin_switch";
+    public static final String PREF_CHECK_PASSWORDS = "check_passwords";
+    public static final String PREF_TRUSTED_VAULT_BANNER = "trusted_vault_banner";
+    public static final String PREF_KEY_MANAGE_ACCOUNT_LINK = "manage_account_link";
+
+    private static final String PREF_KEY_CATEGORY_SAVED_PASSWORDS = "saved_passwords";
+    private static final String PREF_KEY_CATEGORY_EXCEPTIONS = "exceptions";
+    private static final String PREF_KEY_SAVED_PASSWORDS_NO_TEXT = "saved_passwords_no_text";
+
+    private static final int ORDER_SWITCH = 0;
+    private static final int ORDER_AUTO_SIGNIN_CHECKBOX = 1;
+    private static final int ORDER_CHECK_PASSWORDS = 2;
+    private static final int ORDER_TRUSTED_VAULT_BANNER = 3;
+    private static final int ORDER_MANAGE_ACCOUNT_LINK = 4;
+    private static final int ORDER_SAVED_PASSWORDS = 6;
+    private static final int ORDER_EXCEPTIONS = 7;
+    private static final int ORDER_SAVED_PASSWORDS_NO_TEXT = 8;
+
+    // This request code is not actually consumed today in onActivityResult() but is defined here to
+    // avoid bugs in the future if the request code is reused.
+    private static final int REQUEST_CODE_TRUSTED_VAULT_OPT_IN = 1;
+
+    // Unique request code for the password exporting activity.
+    private static final int PASSWORD_EXPORT_INTENT_REQUEST_CODE = 3485764;
+
+    private boolean mNoPasswords;
+    private boolean mNoPasswordExceptions;
+
+    private @Nullable MenuItem mHelpItem;
+    private @Nullable MenuItem mSearchItem;
+
+    private @Nullable String mSearchQuery;
+    private @Nullable Preference mLinkPref;
+    private @Nullable Menu mMenu;
+
+    private @ManagePasswordsReferrer int mManagePasswordsReferrer;
+    private final ObservableSupplierImpl<String> mPageTitle = new ObservableSupplierImpl<>();
+
+    /** For controlling the UX flow of exporting passwords. */
+    private final ExportFlow mExportFlow = new ExportFlow();
+
+    public ExportFlow getExportFlowForTesting() {
+        return mExportFlow;
+    }
+
+    @Override
+    public void onCreatePreferences(@Nullable Bundle savedInstanceState, @Nullable String rootKey) {
+        mExportFlow.onCreate(
+                savedInstanceState,
+                new ExportFlow.Delegate() {
+                    @Override
+                    public Activity getActivity() {
+                        return PasswordSettings.this.getActivity();
+                    }
+
+                    @Override
+                    public FragmentManager getFragmentManager() {
+                        FragmentManager fragmentManager =
+                                PasswordSettings.this.getFragmentManager();
+                        assert fragmentManager != null;
+                        return fragmentManager;
+                    }
+
+                    @Override
+                    public int getViewId() {
+                        View view = getView();
+                        assert view != null;
+                        return view.getId();
+                    }
+
+                    @Override
+                    public void runCreateFileOnDiskIntent(Intent intent) {
+                        startActivityForResult(intent, PASSWORD_EXPORT_INTENT_REQUEST_CODE);
+                    }
+
+                    @Override
+                    public Profile getProfile() {
+                        return PasswordSettings.this.getProfile();
+                    }
+                },
+                PASSWORD_SETTINGS_EXPORT_METRICS_ID);
+        mPageTitle.set(getString(R.string.password_manager_settings_title));
+        setPreferenceScreen(getPreferenceManager().createPreferenceScreen(getStyledContext()));
+        PasswordManagerHandlerProvider.getForProfile(getProfile()).addObserver(this);
+
+        SyncService syncService = SyncServiceFactory.getForProfile(getProfile());
+        if (syncService != null) {
+            syncService.addSyncStateChangedListener(this);
+        }
+
+        setHasOptionsMenu(true); // Password Export might be optional but Search is always present.
+
+        mManagePasswordsReferrer = getReferrerFromInstanceStateOrLaunchBundle(savedInstanceState);
+
+        if (savedInstanceState == null) return;
+
+        if (savedInstanceState.containsKey(SAVED_STATE_SEARCH_QUERY)) {
+            mSearchQuery = savedInstanceState.getString(SAVED_STATE_SEARCH_QUERY);
+        }
+    }
+
+    @Override
+    public ObservableSupplier<String> getPageTitle() {
+        return mPageTitle;
+    }
+
+    private @ManagePasswordsReferrer int getReferrerFromInstanceStateOrLaunchBundle(
+            @Nullable Bundle savedInstanceState) {
+        if (savedInstanceState != null
+                && savedInstanceState.containsKey(
+                        PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER)) {
+            return savedInstanceState.getInt(PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER);
+        }
+        Bundle extras = getArguments();
+        assert extras.containsKey(PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER)
+                : "PasswordSettings must be launched with a manage-passwords-referrer fragment"
+                        + "argument, but none was provided.";
+        return extras.getInt(PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER);
+    }
+
+    @Override
+    public void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+    }
+
+    @Override
+    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+
+        // Disable animations of preference changes.
+        getListView().setItemAnimator(null);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        menu.clear();
+        mMenu = menu;
+        inflater.inflate(R.menu.save_password_preferences_action_bar_menu, menu);
+        menu.findItem(R.id.export_passwords).setVisible(ExportFlow.providesPasswordExport());
+        menu.findItem(R.id.export_passwords).setEnabled(false);
+        mSearchItem = menu.findItem(R.id.menu_id_search);
+        mSearchItem.setVisible(true);
+        mHelpItem = menu.findItem(R.id.menu_id_targeted_help);
+        SearchUtils.initializeSearchView(
+                mSearchItem, mSearchQuery, getActivity(), this::filterPasswords);
+    }
+
+    @Override
+    public void onPrepareOptionsMenu(Menu menu) {
+        menu.findItem(R.id.export_passwords).setEnabled(!mNoPasswords && !mExportFlow.isActive());
+        super.onPrepareOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        int id = item.getItemId();
+        if (id == R.id.export_passwords) {
+            RecordHistogram.recordEnumeratedHistogram(
+                    mExportFlow.getExportEventHistogramName(),
+                    ExportFlow.PasswordExportEvent.EXPORT_OPTION_SELECTED,
+                    ExportFlow.PasswordExportEvent.COUNT);
+            mExportFlow.startExporting();
+            return true;
+        }
+
+        assumeNonNull(mSearchItem);
+        if (SearchUtils.handleSearchNavigation(item, mSearchItem, mSearchQuery, getActivity())) {
+            filterPasswords(/* query= */ null);
+            return true;
+        }
+        if (id == R.id.menu_id_targeted_help) {
+            getHelpAndFeedbackLauncher()
+                    .show(getActivity(), getString(R.string.help_context_passwords), null);
+            return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    private void filterPasswords(@Nullable String query) {
+        assert mHelpItem != null;
+
+        mSearchQuery = query;
+        mHelpItem.setShowAsAction(
+                mSearchQuery == null
+                        ? MenuItem.SHOW_AS_ACTION_IF_ROOM
+                        : MenuItem.SHOW_AS_ACTION_NEVER);
+        rebuildPasswordLists();
+    }
+
+    /** Empty screen message when no passwords or exceptions are stored. */
+    private void displayEmptyScreenMessage() {
+        TextMessagePreference emptyView = new TextMessagePreference(getStyledContext(), null);
+        emptyView.setSummary(R.string.saved_passwords_none_text);
+        emptyView.setKey(PREF_KEY_SAVED_PASSWORDS_NO_TEXT);
+        emptyView.setOrder(ORDER_SAVED_PASSWORDS_NO_TEXT);
+        emptyView.setDividerAllowedAbove(false);
+        emptyView.setDividerAllowedBelow(false);
+        getPreferenceScreen().addPreference(emptyView);
+    }
+
+    /** Include a message when there's no match. */
+    private void displayPasswordNoResultScreenMessage() {
+        Preference noResultView = new Preference(getStyledContext());
+        noResultView.setLayoutResource(R.layout.password_no_result);
+        noResultView.setSelectable(false);
+        getPreferenceScreen().addPreference(noResultView);
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+        ReauthenticationManager.resetLastReauth();
+    }
+
+    void rebuildPasswordLists() {
+        mNoPasswords = false;
+        mNoPasswordExceptions = false;
+        getPreferenceScreen().removeAll();
+        PasswordManagerHandlerProvider passwordManagerHandlerProvider =
+                PasswordManagerHandlerProvider.getForProfile(getProfile());
+        assert passwordManagerHandlerProvider != null;
+        PasswordManagerHandler passwordManagerHandler =
+                passwordManagerHandlerProvider.getPasswordManagerHandler();
+        assert passwordManagerHandler != null;
+        if (mSearchQuery != null) {
+            // Only the filtered passwords and exceptions should be shown.
+            passwordManagerHandler.updatePasswordLists();
+            return;
+        }
+
+        createSavePasswordsSwitch();
+        if (shouldShowAutoSigninOption()) {
+            createAutoSignInCheckbox();
+        }
+        passwordManagerHandler.updatePasswordLists();
+    }
+
+    private boolean shouldShowAutoSigninOption() {
+        return !DeviceInfo.isAutomotive();
+    }
+
+    /**
+     * Removes the UI displaying the list of saved passwords or exceptions.
+     * @param preferenceCategoryKey The key string identifying the PreferenceCategory to be removed.
+     */
+    private void resetList(String preferenceCategoryKey) {
+        PreferenceCategory profileCategory =
+                (PreferenceCategory) getPreferenceScreen().findPreference(preferenceCategoryKey);
+        if (profileCategory != null) {
+            profileCategory.removeAll();
+            getPreferenceScreen().removePreference(profileCategory);
+        }
+    }
+
+    /** Removes the message informing the user that there are no saved entries to display. */
+    private void resetNoEntriesTextMessage() {
+        Preference message = getPreferenceScreen().findPreference(PREF_KEY_SAVED_PASSWORDS_NO_TEXT);
+        if (message != null) {
+            getPreferenceScreen().removePreference(message);
+        }
+    }
+
+    @Override
+    public void passwordListAvailable(int count) {
+        resetList(PREF_KEY_CATEGORY_SAVED_PASSWORDS);
+        resetNoEntriesTextMessage();
+
+        mNoPasswords = count == 0;
+        if (mNoPasswords) {
+            if (mNoPasswordExceptions) displayEmptyScreenMessage();
+            return;
+        }
+
+        PreferenceGroup passwordParent;
+        if (mSearchQuery == null) {
+            PreferenceCategory profileCategory = new PreferenceCategory(getStyledContext());
+            profileCategory.setKey(PREF_KEY_CATEGORY_SAVED_PASSWORDS);
+            profileCategory.setTitle(R.string.password_list_title);
+            profileCategory.setOrder(ORDER_SAVED_PASSWORDS);
+            getPreferenceScreen().addPreference(profileCategory);
+            passwordParent = profileCategory;
+        } else {
+            passwordParent = getPreferenceScreen();
+        }
+        for (int i = 0; i < count; i++) {
+            PasswordManagerHandler passwordManagerHandler =
+                    PasswordManagerHandlerProvider.getForProfile(getProfile())
+                            .getPasswordManagerHandler();
+            assert passwordManagerHandler != null;
+            SavedPasswordEntry saved = passwordManagerHandler.getSavedPasswordEntry(i);
+            String url = saved.getUrl();
+            String name = saved.getUserName();
+            String password = saved.getPassword();
+            if (shouldBeFiltered(url, name)) {
+                continue; // The current password won't show with the active filter, try the next.
+            }
+            Preference preference = new Preference(getStyledContext());
+            preference.setTitle(url);
+            preference.setOnPreferenceClickListener(this);
+            preference.setSummary(name);
+            Bundle args = preference.getExtras();
+            args.putString(PASSWORD_LIST_NAME, name);
+            args.putString(PASSWORD_LIST_URL, url);
+            args.putString(PASSWORD_LIST_PASSWORD, password);
+            args.putInt(PASSWORD_LIST_ID, i);
+            passwordParent.addPreference(preference);
+        }
+        mNoPasswords = passwordParent.getPreferenceCount() == 0;
+        if (mMenu != null) {
+            MenuItem menuItem = mMenu.findItem(R.id.export_passwords);
+            if (menuItem != null) {
+                menuItem.setEnabled(!mNoPasswords && !mExportFlow.isActive());
+            }
+        }
+        if (mNoPasswords) {
+            if (count == 0) displayEmptyScreenMessage(); // Show if the list was already empty.
+            if (mSearchQuery == null) {
+                // If not searching, the category needs to be removed again.
+                getPreferenceScreen().removePreference(passwordParent);
+            } else {
+                displayPasswordNoResultScreenMessage();
+            }
+        }
+    }
+
+    /**
+     * Returns true if there is a search query that requires the exclusion of an entry based on
+     * the passed url or name.
+     * @param url the visible URL of the entry to check. May be empty but must not be null.
+     * @param name the visible user name of the entry to check. May be empty but must not be null.
+     * @return Returns whether the entry with the passed url and name should be filtered.
+     */
+    private boolean shouldBeFiltered(final String url, final String name) {
+        if (mSearchQuery == null) {
+            return false;
+        }
+        return !url.toLowerCase(Locale.ENGLISH).contains(mSearchQuery.toLowerCase(Locale.ENGLISH))
+                && !name.toLowerCase(Locale.getDefault())
+                        .contains(mSearchQuery.toLowerCase(Locale.getDefault()));
+    }
+
+    @Override
+    public void passwordExceptionListAvailable(int count) {
+        if (mSearchQuery != null) return; // Don't show exceptions if a search is ongoing.
+        resetList(PREF_KEY_CATEGORY_EXCEPTIONS);
+        resetNoEntriesTextMessage();
+
+        mNoPasswordExceptions = count == 0;
+        if (mNoPasswordExceptions) {
+            if (mNoPasswords) displayEmptyScreenMessage();
+            return;
+        }
+
+        PreferenceCategory profileCategory = new PreferenceCategory(getStyledContext());
+        profileCategory.setKey(PREF_KEY_CATEGORY_EXCEPTIONS);
+        profileCategory.setTitle(R.string.section_saved_passwords_exceptions);
+        profileCategory.setOrder(ORDER_EXCEPTIONS);
+        getPreferenceScreen().addPreference(profileCategory);
+        for (int i = 0; i < count; i++) {
+            PasswordManagerHandler passwordManagerHandler =
+                    PasswordManagerHandlerProvider.getForProfile(getProfile())
+                            .getPasswordManagerHandler();
+            assert passwordManagerHandler != null;
+            String exception = passwordManagerHandler.getSavedPasswordException(i);
+            Preference preference = new Preference(getStyledContext());
+            preference.setTitle(exception);
+            preference.setOnPreferenceClickListener(this);
+            Bundle args = preference.getExtras();
+            args.putString(PASSWORD_LIST_URL, exception);
+            args.putInt(PASSWORD_LIST_ID, i);
+            profileCategory.addPreference(preference);
+        }
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        rebuildPasswordLists();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mExportFlow.onResume();
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, @Nullable Intent intent) {
+        super.onActivityResult(requestCode, resultCode, intent);
+        if (requestCode != PASSWORD_EXPORT_INTENT_REQUEST_CODE) return;
+        if (resultCode != Activity.RESULT_OK) return;
+        if (intent == null || intent.getData() == null) return;
+
+        mExportFlow.savePasswordsToDownloads(intent.getData());
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        mExportFlow.onSaveInstanceState(outState);
+        if (mSearchQuery != null) {
+            outState.putString(SAVED_STATE_SEARCH_QUERY, mSearchQuery);
+        }
+        outState.putInt(PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER, mManagePasswordsReferrer);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        SyncService syncService = SyncServiceFactory.getForProfile(getProfile());
+        if (syncService != null) {
+            syncService.removeSyncStateChangedListener(this);
+        }
+        // The component should only be destroyed when the activity has been closed by the user
+        // (e.g. by pressing on the back button) and not when the activity is temporarily destroyed
+        // by the system.
+        if (getActivity().isFinishing()) {
+            PasswordManagerHandlerProvider.getForProfile(getProfile()).removeObserver(this);
+        }
+    }
+
+    /**
+     *  Preference was clicked. Either navigate to manage account site or launch the PasswordEditor
+     *  depending on which preference it was.
+     */
+    @Override
+    public boolean onPreferenceClick(Preference preference) {
+        if (preference == mLinkPref) {
+            Intent intent =
+                    new Intent(
+                            Intent.ACTION_VIEW, Uri.parse(PasswordUiView.getAccountDashboardURL()));
+            intent.setPackage(getActivity().getPackageName());
+            getActivity().startActivity(intent);
+        } else {
+            boolean isBlockedCredential =
+                    !preference.getExtras().containsKey(PasswordSettings.PASSWORD_LIST_NAME);
+            PasswordManagerHandler passwordManagerHandler =
+                    PasswordManagerHandlerProvider.getForProfile(getProfile())
+                            .getPasswordManagerHandler();
+            assert passwordManagerHandler != null;
+            passwordManagerHandler.showPasswordEntryEditingView(
+                    getActivity(),
+                    preference.getExtras().getInt(PasswordSettings.PASSWORD_LIST_ID),
+                    isBlockedCredential);
+        }
+        return true;
+    }
+
+    private void createSavePasswordsSwitch() {
+        ChromeSwitchPreference savePasswordsSwitch =
+                new ChromeSwitchPreference(getStyledContext(), null);
+        savePasswordsSwitch.setKey(PREF_SAVE_PASSWORDS_SWITCH);
+        savePasswordsSwitch.setTitle(R.string.password_settings_save_passwords);
+        savePasswordsSwitch.setOrder(ORDER_SWITCH);
+        savePasswordsSwitch.setSummaryOn(R.string.text_on);
+        savePasswordsSwitch.setSummaryOff(R.string.text_off);
+        savePasswordsSwitch.setOnPreferenceChangeListener(
+                (preference, newValue) -> {
+                    getPrefService()
+                            .setBoolean(Pref.CREDENTIALS_ENABLE_SERVICE, (boolean) newValue);
+                    return true;
+                });
+        savePasswordsSwitch.setManagedPreferenceDelegate(
+                new ChromeManagedPreferenceDelegate(getProfile()) {
+                    @Override
+                    public boolean isPreferenceControlledByPolicy(Preference preference) {
+                        return getPrefService()
+                                .isManagedPreference(Pref.CREDENTIALS_ENABLE_SERVICE);
+                    }
+                });
+
+        getPreferenceScreen().addPreference(savePasswordsSwitch);
+
+        // Note: setting the switch state before the preference is added to the screen results in
+        // some odd behavior where the switch state doesn't always match the internal enabled state
+        // (e.g. the switch will say "On" when save passwords is really turned off), so
+        // .setChecked() should be called after .addPreference()
+        savePasswordsSwitch.setChecked(
+                getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_SERVICE));
+    }
+
+    private void createAutoSignInCheckbox() {
+        ChromeSwitchPreference autoSignInSwitch =
+                new ChromeSwitchPreference(getStyledContext(), null);
+        autoSignInSwitch.setKey(PREF_AUTOSIGNIN_SWITCH);
+        autoSignInSwitch.setTitle(R.string.passwords_auto_signin_title);
+        autoSignInSwitch.setOrder(ORDER_AUTO_SIGNIN_CHECKBOX);
+        autoSignInSwitch.setSummary(R.string.passwords_auto_signin_description);
+        autoSignInSwitch.setOnPreferenceChangeListener(
+                (preference, newValue) -> {
+                    getPrefService()
+                            .setBoolean(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN, (boolean) newValue);
+                    return true;
+                });
+        autoSignInSwitch.setManagedPreferenceDelegate(
+                new ChromeManagedPreferenceDelegate(getProfile()) {
+                    @Override
+                    public boolean isPreferenceControlledByPolicy(Preference preference) {
+                        return getPrefService()
+                                .isManagedPreference(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN);
+                    }
+                });
+        getPreferenceScreen().addPreference(autoSignInSwitch);
+        autoSignInSwitch.setChecked(
+                getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN));
+    }
+
+    private Context getStyledContext() {
+        return getPreferenceManager().getContext();
+    }
+
+    private PrefService getPrefService() {
+        return UserPrefs.get(getProfile());
+    }
+
+    @Override
+    public void syncStateChanged() {
+        rebuildPasswordLists();
+    }
+
+    @Nullable Menu getMenuForTesting() {
+        return mMenu;
+    }
+
+    Toolbar getToolbarForTesting() {
+        return getActivity().findViewById(R.id.action_bar);
+    }
+
+    @Override
+    public @AnimationType int getAnimationType() {
+        return AnimationType.PROPERTY;
+    }
+}
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/settings/SettingsNavigationImpl.java b/chrome/android/java/src/org/chromium/chrome/browser/settings/SettingsNavigationImpl.java
index 57e27db344ad9..7e4cfd09e2788 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/settings/SettingsNavigationImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/settings/SettingsNavigationImpl.java
@@ -18,6 +18,7 @@ import org.chromium.chrome.browser.autofill.settings.AutofillPaymentMethodsFragm
 import org.chromium.chrome.browser.autofill.settings.FinancialAccountsManagementFragment;
 import org.chromium.chrome.browser.autofill.settings.NonCardPaymentMethodsManagementFragment;
 import org.chromium.chrome.browser.browsing_data.ClearBrowsingDataFragment;
+import org.chromium.chrome.browser.password_manager.settings.PasswordSettings;
 import org.chromium.chrome.browser.safety_hub.SafetyHubFragment;
 import org.chromium.chrome.browser.sync.settings.GoogleServicesSettings;
 import org.chromium.chrome.browser.sync.settings.ManageSyncSettings;
@@ -50,6 +51,7 @@ public class SettingsNavigationImpl implements SettingsNavigation {
             case SettingsFragment.SAFETY_CHECK:
             case SettingsFragment.SITE:
             case SettingsFragment.ACCESSIBILITY:
+            case SettingsFragment.PASSWORDS:
             case SettingsFragment.GOOGLE_SERVICES:
             case SettingsFragment.MANAGE_SYNC:
             case SettingsFragment.FINANCIAL_ACCOUNTS:
@@ -109,6 +111,8 @@ public class SettingsNavigationImpl implements SettingsNavigation {
                 return SiteSettings.class;
             case SettingsFragment.ACCESSIBILITY:
                 return AccessibilitySettings.class;
+            case SettingsFragment.PASSWORDS:
+                return PasswordSettings.class;
             case SettingsFragment.GOOGLE_SERVICES:
                 return GoogleServicesSettings.class;
             case SettingsFragment.MANAGE_SYNC:
diff --git a/chrome/android/javatests/BUILD.gn b/chrome/android/javatests/BUILD.gn
index 32f0bece2a138..aaaaf84207669 100644
--- a/chrome/android/javatests/BUILD.gn
+++ b/chrome/android/javatests/BUILD.gn
@@ -977,6 +977,10 @@ android_library(
     "src/org/chromium/chrome/browser/password_manager/TouchToFillMainFlowIntegrationTest.java",
     "src/org/chromium/chrome/browser/password_manager/VirtualViewStructureInstrumentationTest.java",
     "src/org/chromium/chrome/browser/password_manager/settings/CredentialManagerIntegrationTest.java",
+    "src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsSearchTest.java",
+    "src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTest.java",
+    "src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTestHelper.java",
+    "src/org/chromium/chrome/browser/password_manager/settings/PasswordViewingTypeTest.java",
     "src/org/chromium/chrome/browser/password_manager/settings/PasswordsPreferenceTest.java",
   ]
 
diff --git a/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsSearchTest.java b/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsSearchTest.java
new file mode 100644
index 0000000000000..4d913ae875122
--- /dev/null
+++ b/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsSearchTest.java
@@ -0,0 +1,534 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static androidx.test.espresso.Espresso.onView;
+import static androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu;
+import static androidx.test.espresso.action.ViewActions.click;
+import static androidx.test.espresso.action.ViewActions.closeSoftKeyboard;
+import static androidx.test.espresso.action.ViewActions.typeText;
+import static androidx.test.espresso.assertion.ViewAssertions.doesNotExist;
+import static androidx.test.espresso.assertion.ViewAssertions.matches;
+import static androidx.test.espresso.matcher.ViewMatchers.assertThat;
+import static androidx.test.espresso.matcher.ViewMatchers.isAssignableFrom;
+import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
+import static androidx.test.espresso.matcher.ViewMatchers.withContentDescription;
+import static androidx.test.espresso.matcher.ViewMatchers.withId;
+import static androidx.test.espresso.matcher.ViewMatchers.withParent;
+import static androidx.test.espresso.matcher.ViewMatchers.withText;
+
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.anyOf;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.not;
+import static org.hamcrest.Matchers.nullValue;
+import static org.hamcrest.Matchers.sameInstance;
+
+import static org.chromium.chrome.browser.password_manager.settings.PasswordSettingsTestHelper.ARES_AT_OLYMP;
+import static org.chromium.chrome.browser.password_manager.settings.PasswordSettingsTestHelper.DEIMOS_AT_OLYMP;
+import static org.chromium.chrome.browser.password_manager.settings.PasswordSettingsTestHelper.GREEK_GODS;
+import static org.chromium.chrome.browser.password_manager.settings.PasswordSettingsTestHelper.HADES_AT_UNDERWORLD;
+import static org.chromium.chrome.browser.password_manager.settings.PasswordSettingsTestHelper.PHOBOS_AT_OLYMP;
+import static org.chromium.chrome.browser.password_manager.settings.PasswordSettingsTestHelper.ZEUS_ON_EARTH;
+import static org.chromium.ui.test.util.ViewUtils.VIEW_GONE;
+import static org.chromium.ui.test.util.ViewUtils.VIEW_INVISIBLE;
+import static org.chromium.ui.test.util.ViewUtils.VIEW_NULL;
+import static org.chromium.ui.test.util.ViewUtils.onViewWaiting;
+
+import android.app.Instrumentation;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.graphics.ColorFilter;
+import android.graphics.drawable.Drawable;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.LinearLayout;
+
+import androidx.annotation.IdRes;
+import androidx.annotation.StringRes;
+import androidx.appcompat.view.menu.ActionMenuItemView;
+import androidx.core.graphics.drawable.DrawableCompat;
+import androidx.test.espresso.Espresso;
+import androidx.test.filters.SmallTest;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import org.hamcrest.Matcher;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import org.chromium.base.ThreadUtils;
+import org.chromium.base.test.BaseActivityTestRule;
+import org.chromium.base.test.util.Batch;
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.base.test.util.DisabledTest;
+import org.chromium.base.test.util.Feature;
+import org.chromium.base.test.util.RequiresRestart;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.browser.history.HistoryActivity;
+import org.chromium.chrome.browser.history.HistoryContentManager;
+import org.chromium.chrome.browser.history.StubbedHistoryProvider;
+import org.chromium.chrome.browser.settings.SettingsActivityTestRule;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.R;
+import org.chromium.ui.test.util.ViewUtils;
+
+import java.util.Date;
+import java.util.concurrent.atomic.AtomicReference;
+
+/** Tests for the search feature of the "Passwords" settings screen. */
+@RunWith(ChromeJUnit4ClassRunner.class)
+@Batch(Batch.PER_CLASS)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class PasswordSettingsSearchTest {
+    private static final long UI_UPDATING_TIMEOUT_MS = 3000;
+
+    @Rule public MockitoRule mMockitoRule = MockitoJUnit.rule();
+
+    @Rule
+    public BaseActivityTestRule<HistoryActivity> mHistoryActivityTestRule =
+            new BaseActivityTestRule<>(HistoryActivity.class);
+
+    @Rule
+    public SettingsActivityTestRule<PasswordSettings> mSettingsActivityTestRule =
+            new SettingsActivityTestRule<>(PasswordSettings.class);
+
+    private final PasswordSettingsTestHelper mTestHelper = new PasswordSettingsTestHelper();
+
+    @Before
+    public void setUp() {
+    }
+
+    @After
+    public void tearDown() {
+        mTestHelper.tearDown();
+    }
+
+    /** Check that the search item is visible in the action bar. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    @SuppressWarnings("AlwaysShowAction") // We need to ensure the icon is in the action bar.
+    public void testSearchIconVisibleInActionBar() {
+        mTestHelper.setPasswordSource(null); // Initialize empty preferences.
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+        onViewWaiting(withText(R.string.password_manager_settings_title));
+        PasswordSettings f = mSettingsActivityTestRule.getFragment();
+
+        // Force the search option into the action bar.
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    f.getMenuForTesting()
+                            .findItem(R.id.menu_id_search)
+                            .setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+                });
+
+        onView(withId(R.id.menu_id_search)).check(matches(isDisplayed()));
+    }
+
+    /** Check that the search item is visible in the overflow menu. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSearchTextInOverflowMenuVisible() {
+        mTestHelper.setPasswordSource(
+                null); // Initialize empty preferences.mSettingsActivityTestRule
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+        onViewWaiting(withText(R.string.password_manager_settings_title));
+        PasswordSettings f = mSettingsActivityTestRule.getFragment();
+
+        // Force the search option into the overflow menu.
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    f.getMenuForTesting()
+                            .findItem(R.id.menu_id_search)
+                            .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
+                });
+
+        // Open the overflow menu.
+        openActionBarOverflowOrOptionsMenu(
+                InstrumentationRegistry.getInstrumentation().getTargetContext());
+
+        onView(withText(R.string.search)).check(matches(isDisplayed()));
+    }
+
+    /**
+     * Check that searching doesn't push the help icon into the overflow menu permanently. On screen
+     * sizes where the help item starts out in the overflow menu, ensure it stays there.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testTriggeringSearchRestoresHelpIcon() {
+        mTestHelper.setPasswordSource(null);
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+        onViewWaiting(withText(R.string.password_manager_settings_title));
+
+        // Retrieve the initial status and ensure that the help option is there at all.
+        final AtomicReference<Boolean> helpInOverflowMenu = new AtomicReference<>(false);
+        onView(withId(R.id.menu_id_targeted_help))
+                .check(
+                        (helpMenuItem, e) -> {
+                            ActionMenuItemView view = (ActionMenuItemView) helpMenuItem;
+                            helpInOverflowMenu.set(view == null || !view.showsIcon());
+                        });
+        if (helpInOverflowMenu.get()) {
+            openActionBarOverflowOrOptionsMenu(
+                    InstrumentationRegistry.getInstrumentation().getTargetContext());
+            onView(withText(R.string.menu_help)).check(matches(isDisplayed()));
+            Espresso.pressBack(); // to close the Overflow menu.
+        } else {
+            onView(withId(R.id.menu_id_targeted_help)).check(matches(isDisplayed()));
+        }
+
+        // Trigger the search, close it and wait for UI to be restored.
+        onView(withSearchMenuIdOrText()).perform(click());
+        onView(withContentDescription(R.string.abc_action_bar_up_description)).perform(click());
+        onViewWaiting(withText(R.string.password_manager_settings_title));
+
+        // Check that the help option is exactly where it was to begin with.
+        if (helpInOverflowMenu.get()) {
+            openActionBarOverflowOrOptionsMenu(
+                    InstrumentationRegistry.getInstrumentation().getTargetContext());
+            onView(withText(R.string.menu_help)).check(matches(isDisplayed()));
+            onView(withId(R.id.menu_id_targeted_help)).check(doesNotExist());
+        } else {
+            onView(withText(R.string.menu_help)).check(doesNotExist());
+            onView(withId(R.id.menu_id_targeted_help)).check(matches(isDisplayed()));
+        }
+    }
+
+    /** Check that the search filters the list by name. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSearchFiltersByUserName() {
+        mTestHelper.setPasswordSourceWithMultipleEntries(GREEK_GODS);
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+
+        // Search for a string matching multiple user names. Case doesn't need to match.
+        onView(withSearchMenuIdOrText()).perform(click());
+        onView(withId(R.id.search_src_text))
+                .perform(click(), typeText("aREs"), closeSoftKeyboard());
+
+        onView(withText(ARES_AT_OLYMP.getUserName())).check(matches(isDisplayed()));
+        onView(withText(PHOBOS_AT_OLYMP.getUserName())).check(matches(isDisplayed()));
+        onView(withText(DEIMOS_AT_OLYMP.getUserName())).check(matches(isDisplayed()));
+        onView(withText(ZEUS_ON_EARTH.getUserName())).check(doesNotExist());
+        onView(withText(HADES_AT_UNDERWORLD.getUrl())).check(doesNotExist());
+    }
+
+    /** Check that the search filters the list by URL. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSearchFiltersByUrl() {
+        mTestHelper.setPasswordSourceWithMultipleEntries(GREEK_GODS);
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+
+        // Search for a string that matches multiple URLs. Case doesn't need to match.
+        onView(withSearchMenuIdOrText()).perform(click());
+        onView(withId(R.id.search_src_text))
+                .perform(click(), typeText("Olymp"), closeSoftKeyboard());
+
+        onView(withText(ARES_AT_OLYMP.getUserName())).check(matches(isDisplayed()));
+        onView(withText(PHOBOS_AT_OLYMP.getUserName())).check(matches(isDisplayed()));
+        onView(withText(DEIMOS_AT_OLYMP.getUserName())).check(matches(isDisplayed()));
+        onView(withText(ZEUS_ON_EARTH.getUserName())).check(doesNotExist());
+        onView(withText(HADES_AT_UNDERWORLD.getUrl())).check(doesNotExist());
+    }
+
+    /** Check that the search filters the list by URL. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSearchDisplaysNoResultMessageIfSearchTurnsUpEmpty() {
+        mTestHelper.setPasswordSourceWithMultipleEntries(GREEK_GODS);
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+
+        // Open the search which should hide the Account link.
+        onView(withSearchMenuIdOrText()).perform(click());
+
+        // Search for a string that matches nothing which should leave the results entirely blank.
+        onView(withId(R.id.search_src_text))
+                .perform(click(), typeText("Mars"), closeSoftKeyboard());
+
+        for (SavedPasswordEntry god : GREEK_GODS) {
+            onView(allOf(withText(god.getUserName()), withText(god.getUrl())))
+                    .check(doesNotExist());
+        }
+        onView(withText(R.string.saved_passwords_none_text)).check(doesNotExist());
+        // Check that the section header for saved passwords is not present. Do not confuse it with
+        // the toolbar label which contains the same string, look for the one inside a linear
+        // layout.
+        onView(
+                        allOf(
+                                withParent(isAssignableFrom(LinearLayout.class)),
+                                withText(R.string.password_manager_settings_title)))
+                .check(doesNotExist());
+        // Check the message for no result.
+        onView(withText(R.string.password_no_result)).check(matches(isDisplayed()));
+    }
+
+    /** Check that triggering the search hides all non-password prefs. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSearchIconClickedHidesExceptionsTemporarily() {
+        mTestHelper.setPasswordExceptions(new String[] {"http://exclu.de", "http://not-inclu.de"});
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+
+        onView(withText(R.string.section_saved_passwords_exceptions)).check(matches(isDisplayed()));
+
+        onView(withSearchMenuIdOrText()).perform(click());
+        onView(withId(R.id.search_src_text)).perform(click(), closeSoftKeyboard());
+
+        onView(withText(R.string.section_saved_passwords_exceptions)).check(doesNotExist());
+
+        onView(withContentDescription(R.string.abc_action_bar_up_description)).perform(click());
+        InstrumentationRegistry.getInstrumentation().waitForIdleSync(); // Close search view.
+
+        onView(withText(R.string.section_saved_passwords_exceptions)).check(matches(isDisplayed()));
+    }
+
+    /** Check that triggering the search hides all non-password prefs. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSearchIconClickedHidesGeneralPrefs() {
+        mTestHelper.setPasswordSource(ZEUS_ON_EARTH);
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+        final PasswordSettings prefs = mSettingsActivityTestRule.getFragment();
+        final AtomicReference<Boolean> menuInitiallyVisible = new AtomicReference<>();
+        ThreadUtils.runOnUiThreadBlocking(
+                () ->
+                        menuInitiallyVisible.set(
+                                prefs.getToolbarForTesting().isOverflowMenuShowing()));
+
+        onView(withText(R.string.password_settings_save_passwords)).check(matches(isDisplayed()));
+
+        if (menuInitiallyVisible.get()) { // Check overflow menu only on large screens that have it.
+            onView(withContentDescription(R.string.abc_action_menu_overflow_description))
+                    .check(matches(isDisplayed()));
+        }
+
+        onView(withSearchMenuIdOrText()).perform(click());
+
+        onView(withText(R.string.password_settings_save_passwords)).check(doesNotExist());
+        ViewUtils.waitForViewCheckingState(
+                withParent(withContentDescription(R.string.abc_action_menu_overflow_description)),
+                VIEW_INVISIBLE | VIEW_GONE | VIEW_NULL);
+
+        onView(withContentDescription(R.string.abc_action_bar_up_description)).perform(click());
+        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
+        if (menuInitiallyVisible.get()) { // If the overflow menu was there, it should be restored.
+            onView(withContentDescription(R.string.abc_action_menu_overflow_description))
+                    .check(matches(isDisplayed()));
+        }
+    }
+
+    /** Check that closing the search via back button brings back all non-password prefs. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSearchBarBackButtonRestoresGeneralPrefs() {
+        mTestHelper.setPasswordSourceWithMultipleEntries(GREEK_GODS);
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+
+        onView(withSearchMenuIdOrText()).perform(click());
+        onView(withId(R.id.search_src_text)).perform(click(), typeText("Zeu"), closeSoftKeyboard());
+
+        onView(withText(R.string.password_settings_save_passwords)).check(doesNotExist());
+
+        onView(withContentDescription(R.string.abc_action_bar_up_description)).perform(click());
+        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
+
+        onView(withText(R.string.password_settings_save_passwords)).check(matches(isDisplayed()));
+
+        onView(withId(R.id.menu_id_search)).check(matches(isDisplayed()));
+    }
+
+    /** Check that clearing the search also hides the clear button. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSearchViewCloseIconExistsOnlyToClearQueries() {
+        mTestHelper.setPasswordSourceWithMultipleEntries(GREEK_GODS);
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+
+        // Trigger search which shouldn't have the button yet.
+        onView(withSearchMenuIdOrText()).perform(click());
+        ViewUtils.waitForViewCheckingState(
+                withId(R.id.search_close_btn), VIEW_INVISIBLE | VIEW_GONE | VIEW_NULL);
+
+        // Type something and see the button appear.
+        onView(withId(R.id.search_src_text))
+                // Trigger search which shouldn't have the button yet.
+                .perform(click(), typeText("Zeu"), closeSoftKeyboard());
+        onView(withId(R.id.search_close_btn)).check(matches(isDisplayed()));
+
+        // Clear the search which should hide the button again.
+        onView(withId(R.id.search_close_btn)).perform(click()); // Clear search.
+        ViewUtils.waitForViewCheckingState(
+                withId(R.id.search_close_btn), VIEW_INVISIBLE | VIEW_GONE | VIEW_NULL);
+    }
+
+    /**
+     * Check that the changed color of the loaded Drawable does not persist for other uses of the
+     * drawable. This is not implicitly true as a loaded Drawable is by default only a reference to
+     * the globally defined resource.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSearchIconColorAffectsOnlyLocalSearchDrawable() {
+        // Open the password preferences and remember the applied color filter.
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+        final PasswordSettings f = mSettingsActivityTestRule.getFragment();
+        onView(withId(R.id.search_button)).check(matches(isDisplayed()));
+        final AtomicReference<ColorFilter> passwordSearchFilter = new AtomicReference<>();
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    Drawable drawable =
+                            f.getMenuForTesting().findItem(R.id.menu_id_search).getIcon();
+                    passwordSearchFilter.set(DrawableCompat.getColorFilter(drawable));
+                });
+
+        // Now launch a non-empty History activity.
+        StubbedHistoryProvider mHistoryProvider = new StubbedHistoryProvider();
+        mHistoryProvider.addItem(StubbedHistoryProvider.createHistoryItem(0, new Date().getTime()));
+        mHistoryProvider.addItem(StubbedHistoryProvider.createHistoryItem(1, new Date().getTime()));
+        HistoryContentManager.setProviderForTests(mHistoryProvider);
+        mHistoryActivityTestRule.launchActivity(null);
+
+        // Find the search view to ensure that the set color filter is different from the saved one.
+        final AtomicReference<ColorFilter> historySearchFilter = new AtomicReference<>();
+        onView(withId(R.id.search_menu_id)).check(matches(isDisplayed()));
+        onView(withId(R.id.search_menu_id))
+                .check(
+                        (searchMenuItem, e) -> {
+                            Drawable drawable =
+                                    ((ActionMenuItemView) searchMenuItem).getItemData().getIcon();
+                            historySearchFilter.set(DrawableCompat.getColorFilter(drawable));
+                            assertThat(
+                                    historySearchFilter.get(),
+                                    anyOf(
+                                            is(nullValue()),
+                                            is(not(sameInstance(passwordSearchFilter.get())))));
+                        });
+
+        // Close the activity and check that the icon in the password preferences has not changed.
+        mHistoryActivityTestRule.getActivity().finish();
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    ColorFilter colorFilter =
+                            DrawableCompat.getColorFilter(
+                                    f.getMenuForTesting().findItem(R.id.menu_id_search).getIcon());
+                    assertThat(
+                            colorFilter,
+                            anyOf(is(nullValue()), is(sameInstance(passwordSearchFilter.get()))));
+                    assertThat(
+                            colorFilter,
+                            anyOf(
+                                    is(nullValue()),
+                                    is(not(sameInstance(historySearchFilter.get())))));
+                });
+    }
+
+    /**
+     * Check that the filtered password list persists after the user had inspected a single result.
+     *
+     * <p>TODO(crbug.com/40763233): Move this test to a full integration test which spins up native
+     * and actually has stored passwords.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    @DisabledTest(message = "crbug/1202907 - The edit UI is now launched via native.")
+    @RequiresRestart("crbug/1137002 - Figure out why this flakes as a batched test.")
+    public void testSearchResultsPersistAfterEntryInspection() {
+        mTestHelper.setPasswordSourceWithMultipleEntries(GREEK_GODS);
+        mTestHelper.setPasswordExceptions(new String[] {"http://exclu.de", "http://not-inclu.de"});
+        ReauthenticationManager.setApiOverride(ReauthenticationManager.OverrideState.AVAILABLE);
+        ReauthenticationManager.setScreenLockSetUpOverride(
+                ReauthenticationManager.OverrideState.AVAILABLE);
+        mTestHelper.startPasswordSettingsFromMainSettings(mSettingsActivityTestRule);
+
+        // Open the search and filter all but "Zeus".
+        onView(withSearchMenuIdOrText()).perform(click());
+
+        onViewWaiting(withId(R.id.search_src_text));
+        onView(withId(R.id.search_src_text)).perform(click(), typeText("Zeu"), closeSoftKeyboard());
+        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
+
+        onView(withText(R.string.passwords_auto_signin_title)).check(doesNotExist());
+        onView(withText(ZEUS_ON_EARTH.getUserName())).check(matches(isDisplayed()));
+        onView(withText(PHOBOS_AT_OLYMP.getUserName())).check(doesNotExist());
+        onView(withText(HADES_AT_UNDERWORLD.getUrl())).check(doesNotExist());
+
+        // Click "Zeus" to open edit field and verify the password. Pretend the user just passed the
+        // reauthentication challenge.
+        ReauthenticationManager.recordLastReauth(
+                System.currentTimeMillis(), ReauthenticationManager.ReauthScope.ONE_AT_A_TIME);
+        Instrumentation.ActivityMonitor monitor =
+                InstrumentationRegistry.getInstrumentation()
+                        .addMonitor(new IntentFilter(Intent.ACTION_VIEW), null, false);
+        onView(withText(ZEUS_ON_EARTH.getUserName())).perform(click());
+        monitor.waitForActivityWithTimeout(UI_UPDATING_TIMEOUT_MS);
+        Assert.assertEquals("Monitor for has not been called", 1, monitor.getHits());
+        InstrumentationRegistry.getInstrumentation().removeMonitor(monitor);
+        onView(withContentDescription(R.string.password_entry_viewer_show_stored_password))
+                .perform(click());
+        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
+
+        onView(withText(ZEUS_ON_EARTH.getPassword())).check(matches(isDisplayed()));
+        onView(withContentDescription(R.string.abc_action_bar_up_description))
+                .perform(click()); // Go back to the search list.
+        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
+
+        onView(withText(R.string.passwords_auto_signin_title)).check(doesNotExist());
+        onView(withText(ZEUS_ON_EARTH.getUserName())).check(matches(isDisplayed()));
+        onView(withText(PHOBOS_AT_OLYMP.getUserName())).check(doesNotExist());
+        onView(withText(HADES_AT_UNDERWORLD.getUrl())).check(doesNotExist());
+        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
+
+        // The search bar should still be open and still display the search query.
+        onViewWaiting(allOf(withId(R.id.search_src_text), withText("Zeu")));
+        onView(withId(R.id.search_src_text)).check(matches(withText("Zeu")));
+    }
+
+    /**
+     * Looks for the search icon by id or by its title.
+     *
+     * @return Returns either the icon button or the menu option.
+     */
+    private static Matcher<View> withSearchMenuIdOrText() {
+        return withMenuIdOrText(R.id.menu_id_search, R.string.search);
+    }
+
+    /**
+     * Looks for the icon by id. If it cannot be found, it's probably hidden in the overflow menu.
+     * In that case, open the menu and search for its title.
+     *
+     * @return Returns either the icon button or the menu option.
+     */
+    private static Matcher<View> withMenuIdOrText(@IdRes int actionId, @StringRes int actionLabel) {
+        Matcher<View> matcher = withId(actionId);
+        try {
+            Espresso.onView(matcher).check(matches(isDisplayed()));
+            return matcher;
+        } catch (Exception NoMatchingViewException) {
+            openActionBarOverflowOrOptionsMenu(
+                    InstrumentationRegistry.getInstrumentation().getTargetContext());
+            return withText(actionLabel);
+        }
+    }
+}
diff --git a/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTest.java b/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTest.java
new file mode 100644
index 0000000000000..988649e2635c8
--- /dev/null
+++ b/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTest.java
@@ -0,0 +1,383 @@
+// Copyright 2014 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static androidx.test.espresso.matcher.ViewMatchers.withText;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.when;
+
+import static org.chromium.ui.test.util.ViewUtils.onViewWaiting;
+
+import android.os.Bundle;
+
+import androidx.test.filters.MediumTest;
+import androidx.test.filters.SmallTest;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import org.chromium.base.ThreadUtils;
+import org.chromium.base.test.util.CommandLineFlags;
+import org.chromium.base.test.util.Feature;
+import org.chromium.chrome.browser.flags.ChromeSwitches;
+import org.chromium.chrome.browser.password_manager.ManagePasswordsReferrer;
+import org.chromium.chrome.browser.password_manager.PasswordManagerHelper;
+import org.chromium.chrome.browser.preferences.Pref;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.browser.settings.SettingsActivityTestRule;
+import org.chromium.chrome.browser.sync.SyncServiceFactory;
+import org.chromium.chrome.test.ChromeJUnit4ClassRunner;
+import org.chromium.chrome.test.OverrideContextWrapperTestRule;
+import org.chromium.chrome.test.R;
+import org.chromium.components.browser_ui.settings.ChromeSwitchPreference;
+import org.chromium.components.prefs.PrefService;
+import org.chromium.components.sync.DataType;
+import org.chromium.components.sync.PassphraseType;
+import org.chromium.components.sync.SyncService;
+import org.chromium.components.user_prefs.UserPrefs;
+
+import java.util.Set;
+
+/**
+ * Tests for the "Passwords" settings screen. These tests are not batchable (without significant
+ * effort), so consider splitting large new suites into separate classes.
+ */
+@RunWith(ChromeJUnit4ClassRunner.class)
+@CommandLineFlags.Add({ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE})
+public class PasswordSettingsTest {
+    @Rule public MockitoRule mMockitoRule = MockitoJUnit.rule();
+
+    @Rule
+    public SettingsActivityTestRule<PasswordSettings> mPasswordSettingsActivityTestRule =
+            new SettingsActivityTestRule<>(PasswordSettings.class);
+
+    @Rule
+    public OverrideContextWrapperTestRule mAutomotiveContextWrapperTestRule =
+            new OverrideContextWrapperTestRule();
+
+    @Mock private SyncService mMockSyncService;
+
+    private final PasswordSettingsTestHelper mTestHelper = new PasswordSettingsTestHelper();
+
+    @Before
+    public void setUp() {
+        // By default sync is off. Tests can override this later.
+        setSyncServiceState(false, false);
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> SyncServiceFactory.setInstanceForTesting(mMockSyncService));
+
+        // This initializes the browser, so some tests can do setup before PasswordSettings is
+        // launched. ChromeTabbedActivityTestRule.startMainActivityOnBlankPage() is more commonly
+        // used for this end, but using another settings activity instead makes these tests more
+        // isolated, i.e. avoids exercising unnecessary logic. BlankUiTestActivityTestCase also
+        // won't fit here, it doesn't initialize enough of the browser.
+        Bundle fragmentArgs = new Bundle();
+        fragmentArgs.putInt(
+                PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER,
+                ManagePasswordsReferrer.CHROME_SETTINGS);
+        mPasswordSettingsActivityTestRule.startSettingsActivity(fragmentArgs);
+        mPasswordSettingsActivityTestRule.finishActivity();
+    }
+
+    @After
+    public void tearDown() {
+        mTestHelper.tearDown();
+    }
+
+    /** Ensure that resetting of empty passwords list works. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testResetListEmpty() {
+        // Load the preferences, they should show the empty list.
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        onViewWaiting(withText(R.string.password_manager_settings_title));
+
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    PasswordSettings savePasswordPreferences =
+                            mPasswordSettingsActivityTestRule.getFragment();
+                    // Emulate an update from PasswordStore. This should not crash.
+                    savePasswordPreferences.passwordListAvailable(0);
+                });
+    }
+
+    /**
+     * Ensure that the on/off switch in "Save Passwords" settings actually enables and disables
+     * password saving.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testSavePasswordsSwitch() {
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    getPrefService().setBoolean(Pref.CREDENTIALS_ENABLE_SERVICE, true);
+                });
+
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        onViewWaiting(withText(R.string.password_manager_settings_title));
+
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    PasswordSettings savedPasswordPrefs =
+                            mPasswordSettingsActivityTestRule.getFragment();
+                    ChromeSwitchPreference onOffSwitch =
+                            (ChromeSwitchPreference)
+                                    savedPasswordPrefs.findPreference(
+                                            PasswordSettings.PREF_SAVE_PASSWORDS_SWITCH);
+                    assertTrue(onOffSwitch.isChecked());
+
+                    onOffSwitch.performClick();
+                    assertFalse(getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_SERVICE));
+
+                    onOffSwitch.performClick();
+                    assertTrue(getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_SERVICE));
+                });
+
+        mPasswordSettingsActivityTestRule.finishActivity();
+
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    getPrefService().setBoolean(Pref.CREDENTIALS_ENABLE_SERVICE, false);
+                });
+
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        onViewWaiting(withText(R.string.password_manager_settings_title));
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    PasswordSettings savedPasswordPrefs =
+                            mPasswordSettingsActivityTestRule.getFragment();
+                    ChromeSwitchPreference onOffSwitch =
+                            (ChromeSwitchPreference)
+                                    savedPasswordPrefs.findPreference(
+                                            PasswordSettings.PREF_SAVE_PASSWORDS_SWITCH);
+                    assertFalse(onOffSwitch.isChecked());
+                });
+    }
+
+    /**
+     * Tests that the link pointing to managing passwords in the user's account is not displayed for
+     * non signed in users.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testManageAccountLinkNotSignedIn() {
+        // Add a password entry, because the link is only displayed if the password list is not
+        // empty.
+        mTestHelper.setPasswordSource(
+                new SavedPasswordEntry("https://example.com", "test user", "password"));
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        PasswordSettings savedPasswordPrefs = mPasswordSettingsActivityTestRule.getFragment();
+        Assert.assertNull(
+                savedPasswordPrefs.findPreference(PasswordSettings.PREF_KEY_MANAGE_ACCOUNT_LINK));
+    }
+
+    /**
+     * Tests that the link pointing to managing passwords in the user's account is not displayed for
+     * signed in users, not syncing passwords.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testManageAccountLinkSignedInNotSyncing() {
+        // Add a password entry, because the link is only displayed if the password list is not
+        // empty.
+        mTestHelper.setPasswordSource(
+                new SavedPasswordEntry("https://example.com", "test user", "password"));
+        setSyncServiceState(false, false);
+
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        PasswordSettings savedPasswordPrefs = mPasswordSettingsActivityTestRule.getFragment();
+
+        Assert.assertNull(
+                savedPasswordPrefs.findPreference(PasswordSettings.PREF_KEY_MANAGE_ACCOUNT_LINK));
+    }
+
+    /**
+     * Tests that the link pointing to managing passwords in the user's account is displayed for
+     * users syncing passwords.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testManageAccountLinkSyncing() {
+        // Add a password entry, because the link is only displayed if the password list is not
+        // empty.
+        mTestHelper.setPasswordSource(
+                new SavedPasswordEntry("https://example.com", "test user", "password"));
+        setSyncServiceState(false, true);
+
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        PasswordSettings savedPasswordPrefs = mPasswordSettingsActivityTestRule.getFragment();
+
+        Assert.assertNotNull(
+                savedPasswordPrefs.findPreference(PasswordSettings.PREF_KEY_MANAGE_ACCOUNT_LINK));
+    }
+
+    /**
+     * Tests that the link pointing to managing passwords in the user's account is not displayed for
+     * users syncing passwords with custom passphrase.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testManageAccountLinkSyncingWithPassphrase() {
+        // Add a password entry, because the link is only displayed if the password list is not
+        // empty.
+        mTestHelper.setPasswordSource(
+                new SavedPasswordEntry("https://example.com", "test user", "password"));
+        setSyncServiceState(true, true);
+
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        PasswordSettings savedPasswordPrefs = mPasswordSettingsActivityTestRule.getFragment();
+
+        Assert.assertNull(
+                savedPasswordPrefs.findPreference(PasswordSettings.PREF_KEY_MANAGE_ACCOUNT_LINK));
+    }
+
+    /**
+     * Ensure that the "Auto Sign-in" switch in "Save Passwords" settings actually enables and
+     * disables auto sign-in.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testAutoSignInCheckbox() {
+        mAutomotiveContextWrapperTestRule.setIsAutomotive(false);
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    getPrefService().setBoolean(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN, true);
+                });
+
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    PasswordSettings passwordPrefs =
+                            mPasswordSettingsActivityTestRule.getFragment();
+                    ChromeSwitchPreference onOffSwitch =
+                            (ChromeSwitchPreference)
+                                    passwordPrefs.findPreference(
+                                            PasswordSettings.PREF_AUTOSIGNIN_SWITCH);
+                    assertTrue(onOffSwitch.isChecked());
+
+                    onOffSwitch.performClick();
+                    assertFalse(getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN));
+
+                    onOffSwitch.performClick();
+                    assertTrue(getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN));
+                });
+
+        mPasswordSettingsActivityTestRule.finishActivity();
+
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    getPrefService().setBoolean(Pref.CREDENTIALS_ENABLE_AUTOSIGNIN, false);
+                });
+
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    PasswordSettings passwordPrefs =
+                            mPasswordSettingsActivityTestRule.getFragment();
+                    ChromeSwitchPreference onOffSwitch =
+                            (ChromeSwitchPreference)
+                                    passwordPrefs.findPreference(
+                                            PasswordSettings.PREF_AUTOSIGNIN_SWITCH);
+                    assertFalse(onOffSwitch.isChecked());
+                });
+    }
+
+    /**
+     * Ensure that the "Auto Sign-in" switch in "Save Passwords" settings is not present on
+     * automotive.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testAutoSignInCheckboxIsNotPresentOnAutomotive() {
+        mAutomotiveContextWrapperTestRule.setIsAutomotive(true);
+
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    PasswordSettings passwordPrefs =
+                            mPasswordSettingsActivityTestRule.getFragment();
+                    ChromeSwitchPreference onOffSwitch =
+                            (ChromeSwitchPreference)
+                                    passwordPrefs.findPreference(
+                                            PasswordSettings.PREF_AUTOSIGNIN_SWITCH);
+                    assertNull("There should be no autosignin switch.", onOffSwitch);
+                });
+    }
+
+    /** Check that the check passwords preference is shown. */
+    @Test
+    @SmallTest
+    @Feature({"Preferences"})
+    public void testCheckPasswordsEnabled() {
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    PasswordSettings passwordPrefs =
+                            mPasswordSettingsActivityTestRule.getFragment();
+                    Assert.assertNotNull(
+                            passwordPrefs.findPreference(PasswordSettings.PREF_CHECK_PASSWORDS));
+                });
+    }
+
+    @Test
+    @MediumTest
+    @Feature({"Preferences"})
+    public void testDestroysPasswordCheckIfFirstInSettingsStack() {
+        setSyncServiceState(true, true);
+        mTestHelper.startPasswordSettingsDirectly(mPasswordSettingsActivityTestRule);
+        mPasswordSettingsActivityTestRule.finishActivity();
+    }
+
+    @Test
+    @MediumTest
+    @Feature({"Preferences"})
+    public void testDoesNotDestroyPasswordCheckIfNotFirstInSettingsStack() {
+        setSyncServiceState(true, true);
+        mTestHelper.startPasswordSettingsFromMainSettings(mPasswordSettingsActivityTestRule);
+        mPasswordSettingsActivityTestRule.finishActivity();
+    }
+
+    private static PrefService getPrefService() {
+        return UserPrefs.get(ProfileManager.getLastUsedRegularProfile());
+    }
+
+    private void setSyncServiceState(
+            final boolean usingCustomPassphrase, final boolean syncingPasswords) {
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    when(mMockSyncService.hasSyncConsent()).thenReturn(syncingPasswords);
+                    when(mMockSyncService.isEngineInitialized()).thenReturn(true);
+                    when(mMockSyncService.isUsingExplicitPassphrase())
+                            .thenReturn(usingCustomPassphrase);
+                    when(mMockSyncService.getPassphraseType())
+                            .thenReturn(
+                                    usingCustomPassphrase
+                                            ? PassphraseType.CUSTOM_PASSPHRASE
+                                            : PassphraseType.KEYSTORE_PASSPHRASE);
+                    Integer elements = syncingPasswords ? DataType.PASSWORDS : DataType.AUTOFILL;
+                    when(mMockSyncService.getActiveDataTypes()).thenReturn(Set.of(elements));
+                });
+    }
+}
diff --git a/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTestHelper.java b/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTestHelper.java
new file mode 100644
index 0000000000000..7cd9f555fd9cf
--- /dev/null
+++ b/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettingsTestHelper.java
@@ -0,0 +1,193 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import android.os.Bundle;
+import android.view.View;
+
+import androidx.preference.PreferenceViewHolder;
+import androidx.recyclerview.widget.RecyclerView.ViewHolder;
+import androidx.test.espresso.matcher.BoundedMatcher;
+
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+
+import org.chromium.base.ThreadUtils;
+import org.chromium.base.test.util.ApplicationTestUtils;
+import org.chromium.chrome.browser.init.ChromeBrowserInitializer;
+import org.chromium.chrome.browser.password_manager.FakePasswordManagerHandler;
+import org.chromium.chrome.browser.password_manager.ManagePasswordsReferrer;
+import org.chromium.chrome.browser.password_manager.PasswordManagerHelper;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.browser.settings.SettingsActivity;
+import org.chromium.chrome.browser.settings.SettingsActivityTestRule;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+/** Helper functions used in various password settings test suites. */
+class PasswordSettingsTestHelper {
+    static final SavedPasswordEntry ZEUS_ON_EARTH =
+            new SavedPasswordEntry("http://www.phoenicia.gr", "Zeus", "Europa");
+    static final SavedPasswordEntry ARES_AT_OLYMP =
+            new SavedPasswordEntry("https://1-of-12.olymp.gr", "Ares", "God-o'w@r");
+    static final SavedPasswordEntry PHOBOS_AT_OLYMP =
+            new SavedPasswordEntry("https://visitor.olymp.gr", "Phobos-son-of-ares", "G0d0fF34r");
+    static final SavedPasswordEntry DEIMOS_AT_OLYMP =
+            new SavedPasswordEntry("https://visitor.olymp.gr", "Deimops-Ares-son", "G0d0fT3rr0r");
+    static final SavedPasswordEntry HADES_AT_UNDERWORLD =
+            new SavedPasswordEntry("https://underworld.gr", "", "C3rb3rus");
+    static final SavedPasswordEntry[] GREEK_GODS = {
+        ZEUS_ON_EARTH, ARES_AT_OLYMP, PHOBOS_AT_OLYMP, DEIMOS_AT_OLYMP, HADES_AT_UNDERWORLD,
+    };
+
+    private SettingsActivity mActivityToCleanUp;
+
+    /**
+     * Used to provide fake lists of stored passwords. Tests which need it can use setPasswordSource
+     */
+    private FakePasswordManagerHandler mHandler;
+
+    /**
+     * Delayer controlling hiding the progress bar during exporting passwords. This replaces a time
+     * delay used in production.
+     */
+    private final ManualCallbackDelayer mManualDelayer = new ManualCallbackDelayer();
+
+    void tearDown() {
+        try {
+            ApplicationTestUtils.finishActivity(mActivityToCleanUp);
+        } catch (Exception e) {
+            // Activity was already finished by test framework. Any exception is not test-related.
+        }
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    if (!ProfileManager.isInitialized()) return;
+                    PasswordManagerHandlerProvider.getForProfile(
+                                    ProfileManager.getLastUsedRegularProfile())
+                            .resetPasswordManagerHandlerForTest();
+                });
+        setPasswordSource(null);
+    }
+
+    ManualCallbackDelayer getManualDelayer() {
+        return mManualDelayer;
+    }
+
+    FakePasswordManagerHandler getHandler() {
+        return mHandler;
+    }
+
+    /**
+     * Helper to set up a fake source of displayed passwords.
+     *
+     * @param entry An entry to be added to saved passwords. Can be null.
+     */
+    void setPasswordSource(SavedPasswordEntry entry) {
+        SavedPasswordEntry[] entries = {};
+        if (entry != null) {
+            entries = new SavedPasswordEntry[] {entry};
+        }
+        setPasswordSourceWithMultipleEntries(entries);
+    }
+
+    /**
+     * Helper to set up a fake source of displayed passwords with multiple initial passwords.
+     *
+     * @param initialEntries All entries to be added to saved passwords. Can not be null.
+     */
+    void setPasswordSourceWithMultipleEntries(SavedPasswordEntry[] initialEntries) {
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    if (!ChromeBrowserInitializer.getInstance().isFullBrowserInitialized()) {
+                        ChromeBrowserInitializer.getInstance().handleSynchronousStartup();
+                    }
+                });
+
+        PasswordManagerHandlerProvider handlerProvider =
+                ThreadUtils.runOnUiThreadBlocking(
+                        () ->
+                                PasswordManagerHandlerProvider.getForProfile(
+                                        ProfileManager.getLastUsedRegularProfile()));
+        if (mHandler == null) {
+            mHandler = new FakePasswordManagerHandler(handlerProvider);
+        }
+        ArrayList<SavedPasswordEntry> entries = new ArrayList<>(Arrays.asList(initialEntries));
+        mHandler.setSavedPasswords(entries);
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> handlerProvider.setPasswordManagerHandlerForTest(mHandler));
+    }
+
+    /**
+     * Helper to set up a fake source of displayed passwords without passwords but with exceptions.
+     *
+     * @param exceptions All exceptions to be added to saved exceptions. Can not be null.
+     */
+    void setPasswordExceptions(String[] exceptions) {
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> {
+                    if (!ChromeBrowserInitializer.getInstance().isFullBrowserInitialized()) {
+                        ChromeBrowserInitializer.getInstance().handleSynchronousStartup();
+                    }
+                });
+
+        PasswordManagerHandlerProvider handlerProvider =
+                ThreadUtils.runOnUiThreadBlocking(
+                        () ->
+                                PasswordManagerHandlerProvider.getForProfile(
+                                        ProfileManager.getLastUsedRegularProfile()));
+        if (mHandler == null) {
+            mHandler = new FakePasswordManagerHandler(handlerProvider);
+        }
+        mHandler.setSavedPasswordExceptions(new ArrayList<>(Arrays.asList(exceptions)));
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> handlerProvider.setPasswordManagerHandlerForTest(mHandler));
+    }
+
+    SettingsActivity startPasswordSettingsFromMainSettings(
+            SettingsActivityTestRule<PasswordSettings> testRule) {
+        Bundle fragmentArgs = new Bundle();
+        fragmentArgs.putInt(
+                PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER,
+                ManagePasswordsReferrer.CHROME_SETTINGS);
+        mActivityToCleanUp = testRule.startSettingsActivity(fragmentArgs);
+        return mActivityToCleanUp;
+    }
+
+    SettingsActivity startPasswordSettingsDirectly(
+            SettingsActivityTestRule<PasswordSettings> testRule) {
+        Bundle fragmentArgs = new Bundle();
+        // The passwords accessory sheet is one of the places that can launch password settings
+        // directly (without passing through main settings).
+        fragmentArgs.putInt(
+                PasswordManagerHelper.MANAGE_PASSWORDS_REFERRER,
+                ManagePasswordsReferrer.PASSWORDS_ACCESSORY_SHEET);
+        mActivityToCleanUp = testRule.startSettingsActivity(fragmentArgs);
+        return mActivityToCleanUp;
+    }
+
+    /**
+     * Returns a matcher that checks whether a given view contains another view with the given text.
+     *
+     * @param text The text that the view holder has in its view hierarchy.
+     * @return A Matcher to find a particular {@link ViewHolder} that contains certain text.
+     */
+    static Matcher<ViewHolder> hasTextInViewHolder(String text) {
+        return new BoundedMatcher<>(PreferenceViewHolder.class) {
+            @Override
+            public void describeTo(Description description) {
+                description.appendText("has text: " + text);
+            }
+
+            @Override
+            protected boolean matchesSafely(PreferenceViewHolder preferenceViewHolder) {
+                ArrayList<View> outViews = new ArrayList<>();
+                preferenceViewHolder.itemView.findViewsWithText(
+                        outViews, text, View.FIND_VIEWS_WITH_TEXT);
+                return !outViews.isEmpty();
+            }
+        };
+    }
+}
diff --git a/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordViewingTypeTest.java b/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordViewingTypeTest.java
new file mode 100644
index 0000000000000..ff56edb455fb0
--- /dev/null
+++ b/chrome/android/javatests/src/org/chromium/chrome/browser/password_manager/settings/PasswordViewingTypeTest.java
@@ -0,0 +1,107 @@
+// Copyright 2016 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static org.mockito.Mockito.when;
+
+import androidx.test.filters.SmallTest;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.RuleChain;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import org.chromium.base.ThreadUtils;
+import org.chromium.base.test.BaseJUnit4ClassRunner;
+import org.chromium.base.test.util.Feature;
+import org.chromium.chrome.browser.settings.MainSettings;
+import org.chromium.chrome.browser.settings.SettingsActivityTestRule;
+import org.chromium.chrome.browser.sync.SyncServiceFactory;
+import org.chromium.chrome.test.ChromeBrowserTestRule;
+import org.chromium.components.browser_ui.settings.ChromeBasePreference;
+import org.chromium.components.sync.SyncService;
+
+/**
+ * Tests for verifying whether users are presented with the correct option of viewing passwords
+ * according to the user group they belong to (syncing with sync passphrase, syncing without sync
+ * passsphrase, non-syncing).
+ */
+@RunWith(BaseJUnit4ClassRunner.class)
+public class PasswordViewingTypeTest {
+    private final ChromeBrowserTestRule mChromeBrowserTestRule = new ChromeBrowserTestRule();
+
+    private final SettingsActivityTestRule<MainSettings> mSettingsActivityTestRule =
+            new SettingsActivityTestRule<>(MainSettings.class);
+
+    // We need to destroy the SettingsActivity before tearing down the mock sign-in environment
+    // setup in ChromeBrowserTestRule to avoid code crash.
+    @Rule
+    public final RuleChain mRuleChain =
+            RuleChain.outerRule(mChromeBrowserTestRule).around(mSettingsActivityTestRule);
+
+    @Rule public final MockitoRule mMockitoRule = MockitoJUnit.rule();
+
+    private ChromeBasePreference mPasswordsPref;
+    @Mock private SyncService mSyncService;
+
+    @Before
+    public void setUp() {
+        mChromeBrowserTestRule.addAccount("account@example.com");
+        mSettingsActivityTestRule.startSettingsActivity();
+        MainSettings mainSettings = mSettingsActivityTestRule.getFragment();
+        mPasswordsPref =
+                (ChromeBasePreference) mainSettings.findPreference(MainSettings.PREF_PASSWORDS);
+        ThreadUtils.runOnUiThreadBlocking(
+                () -> SyncServiceFactory.setInstanceForTesting(mSyncService));
+    }
+
+    /**
+     * Verifies that sync settings are being set up correctly in the case of redirecting users.
+     * Checks that sync users are allowed to view passwords natively.
+     */
+    @Test
+    @SmallTest
+    @Feature({"Sync"})
+    public void testUserRedirectSyncSettings() {
+        when(mSyncService.isSyncFeatureEnabled()).thenReturn(true);
+        when(mSyncService.isEngineInitialized()).thenReturn(true);
+        when(mSyncService.isUsingExplicitPassphrase()).thenReturn(false);
+
+        Assert.assertEquals(
+                PasswordSettings.class.getCanonicalName(), mPasswordsPref.getFragment());
+    }
+
+    /**
+     * Verifies that syncing users with a custom passphrase are allowed to natively view passwords.
+     */
+    @Test
+    @SmallTest
+    public void testSyncingNativePasswordView() {
+        when(mSyncService.isSyncFeatureEnabled()).thenReturn(true);
+        when(mSyncService.isEngineInitialized()).thenReturn(true);
+        when(mSyncService.isUsingExplicitPassphrase()).thenReturn(true);
+
+        Assert.assertEquals(
+                PasswordSettings.class.getCanonicalName(), mPasswordsPref.getFragment());
+        Assert.assertNotNull(mSettingsActivityTestRule.getActivity().getIntent());
+    }
+
+    /** Verifies that non-syncing users are allowed to natively view passwords. */
+    @Test
+    @SmallTest
+    public void testNonSyncingNativePasswordView() {
+        when(mSyncService.isSyncFeatureEnabled()).thenReturn(false);
+        when(mSyncService.isEngineInitialized()).thenReturn(false);
+        when(mSyncService.isUsingExplicitPassphrase()).thenReturn(false);
+
+        Assert.assertEquals(
+                PasswordSettings.class.getCanonicalName(), mPasswordsPref.getFragment());
+    }
+}
diff --git a/chrome/android/javatests/src/org/chromium/chrome/browser/settings/MainSettingsFragmentTest.java b/chrome/android/javatests/src/org/chromium/chrome/browser/settings/MainSettingsFragmentTest.java
index ba960c3d77559..2cb7d7896bb61 100644
--- a/chrome/android/javatests/src/org/chromium/chrome/browser/settings/MainSettingsFragmentTest.java
+++ b/chrome/android/javatests/src/org/chromium/chrome/browser/settings/MainSettingsFragmentTest.java
@@ -97,6 +97,7 @@ import org.chromium.chrome.browser.night_mode.NightModeMetrics.ThemeSettingsEntr
 import org.chromium.chrome.browser.night_mode.settings.ThemeSettingsFragment;
 import org.chromium.chrome.browser.password_manager.PasswordManagerUtilBridge;
 import org.chromium.chrome.browser.password_manager.PasswordManagerUtilBridgeJni;
+import org.chromium.chrome.browser.password_manager.settings.PasswordSettings;
 import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;
 import org.chromium.chrome.browser.preferences.ChromeSharedPreferences;
 import org.chromium.chrome.browser.privacy.settings.PrivacySettings;
@@ -286,7 +287,7 @@ public class MainSettingsFragmentTest {
         assertSettingsExists(MainSettings.PREF_SEARCH_ENGINE, SearchEngineSettings.class);
         assertSettingsExists(MainSettings.PREF_AUTOFILL_OPTIONS, null);
         assertSettingsExists(MainSettings.PREF_AUTOFILL_SECTION, null);
-        assertSettingsExists(MainSettings.PREF_PASSWORDS, null);
+        assertSettingsExists(MainSettings.PREF_PASSWORDS, PasswordSettings.class);
         assertSettingsExists("autofill_payment_methods", AutofillPaymentMethodsFragment.class);
         assertSettingsExists("autofill_addresses", AutofillProfilesFragment.class);
         if (supportNotificationSettings()) {
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index e0aa9a70e2f80..b5c8376d6153e 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -3203,6 +3203,8 @@ static_library("browser") {
       "password_manager/android/password_manager_launcher_android.cc",
       "password_manager/android/password_store_bridge.cc",
       "password_manager/android/password_store_bridge.h",
+      "password_manager/android/password_ui_view_android.cc",
+      "password_manager/android/password_ui_view_android.h",
       "password_manager/android/save_update_password_message_delegate.cc",
       "password_manager/android/save_update_password_message_delegate.h",
       "payments/android/service_worker_payment_app_bridge.cc",
diff --git a/chrome/browser/password_manager/android/BUILD.gn b/chrome/browser/password_manager/android/BUILD.gn
index 3324ab9bb3e3e..014eaa48197e8 100644
--- a/chrome/browser/password_manager/android/BUILD.gn
+++ b/chrome/browser/password_manager/android/BUILD.gn
@@ -185,10 +185,18 @@ android_library("java") {
     "java/src/org/chromium/chrome/browser/password_manager/PasswordStoreBridge.java",
     "java/src/org/chromium/chrome/browser/password_manager/PasswordStoreCredential.java",
     "java/src/org/chromium/chrome/browser/password_manager/PasswordSyncControllerDelegateBridgeImpl.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlow.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlowInterface.java",
     "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordAccessReauthenticationHelper.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordListObserver.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandler.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandlerProvider.java",
     "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordReauthenticationFragment.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java",
     "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordsPreference.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/ProgressBarDialogFragment.java",
     "java/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManager.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/SavedPasswordEntry.java",
   ]
 
   resources_package = "org.chromium.chrome.browser.password_manager"
@@ -211,6 +219,7 @@ generate_jni("jni_headers") {
     "java/src/org/chromium/chrome/browser/password_manager/PasswordStoreBridge.java",
     "java/src/org/chromium/chrome/browser/password_manager/PasswordStoreCredential.java",
     "java/src/org/chromium/chrome/browser/password_manager/PasswordSyncControllerDelegateBridgeImpl.java",
+    "java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java",
   ]
 }
 
@@ -453,6 +462,7 @@ android_library("test_support_java") {
     "test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordCheckupClientHelper.java",
     "test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordCheckupClientHelperFactoryImpl.java",
     "test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordManagerBackendSupportHelper.java",
+    "test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordManagerHandler.java",
     "test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordSettingsAccessor.java",
     "test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordSettingsAccessorFactoryImpl.java",
     "test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordStoreAndroidBackend.java",
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/PasswordManagerHelper.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/PasswordManagerHelper.java
index 15a9e9e6e97a4..8a7d2cfe24d78 100644
--- a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/PasswordManagerHelper.java
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/PasswordManagerHelper.java
@@ -51,6 +51,9 @@ import java.util.function.Supplier;
 /** A helper class for showing PasswordSettings. TODO(crbug.com/40853413): Split up this class */
 @NullMarked
 public class PasswordManagerHelper {
+
+    public static final String MANAGE_PASSWORDS_REFERRER = "manage-passwords-referrer";
+
     // Indicates the operation that was requested from the {@link PasswordCheckupClientHelper}.
     @IntDef({
         PasswordCheckOperation.RUN_PASSWORD_CHECKUP,
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlow.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlow.java
new file mode 100644
index 0000000000000..62bdc5ed82cf0
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlow.java
@@ -0,0 +1,606 @@
+// Copyright 2018 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static org.chromium.build.NullUtil.assumeNonNull;
+import static org.chromium.chrome.browser.password_manager.PasswordMetricsUtil.logPasswordsExportResult;
+
+import android.content.ActivityNotFoundException;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.VisibleForTesting;
+import androidx.appcompat.app.AlertDialog;
+
+import org.chromium.base.CallbackUtils;
+import org.chromium.base.ContextUtils;
+import org.chromium.base.FileProviderUtils;
+import org.chromium.base.FileUtils;
+import org.chromium.base.metrics.RecordHistogram;
+import org.chromium.base.task.AsyncTask;
+import org.chromium.build.annotations.Initializer;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.chrome.browser.password_manager.PasswordMetricsUtil;
+import org.chromium.chrome.browser.password_manager.PasswordMetricsUtil.HistogramExportResult;
+import org.chromium.chrome.browser.password_manager.R;
+import org.chromium.ui.widget.Toast;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * This class allows to trigger and complete the UX flow for exporting passwords. A {@link Fragment}
+ * can use it to display the flow UI over the fragment.
+ *
+ * <pre>
+ * Internally, the flow is represented by the following calls:
+ * (1)  {@link #startExporting}, which triggers both preparing of stored passwords in the background
+ *      and reauthentication of the user.
+ * (2a) {@link #shareSerializedPasswords}, which is the final part of the preparation of passwords
+ *      which otherwise runs in the native code.
+ * (2b) {@link #exportAfterReauth} is the user-visible next step after reauthentication.
+ * (3)  {@link #tryExporting} merges the flow of the in-parallel-running (2a) and (2b). In the rare
+ *      case when (2b) finishes before (2a), it also displays a progress bar.
+ * (4)  {@link #sendExportIntent} creates an intent chooser for sharing the exported passwords with
+ *      an app of user's choice.
+ * </pre>
+ */
+@NullMarked
+public class ExportFlow implements ExportFlowInterface {
+    @IntDef({ExportState.INACTIVE, ExportState.REQUESTED, ExportState.CONFIRMED})
+    @Retention(RetentionPolicy.SOURCE)
+    private @interface ExportState {
+        /**
+         * INACTIVE: there is no currently running export. Either the user did not request
+         * one, or the last one completed (i.e., a share intent picker or an error message were
+         * displayed or the user cancelled it).
+         */
+        int INACTIVE = 0;
+
+        /**
+         * REQUESTED: the user requested the export in the menu but did not authenticate
+         * and confirm it yet.
+         */
+        int REQUESTED = 1;
+
+        /**
+         * CONFIRMED: the user confirmed the export and Chrome is still busy preparing the
+         * data for the share intent.
+         */
+        int CONFIRMED = 2;
+    }
+
+    /** Describes at which state the password export flow is. */
+    @ExportState private int mExportState;
+
+    /** Name of the subdirectory in cache which stores the exported passwords file. */
+    private static final String PASSWORDS_CACHE_DIR = "/passwords";
+
+    /** The key for saving {@link #mExportState} to instance bundle. */
+    private static final String SAVED_STATE_EXPORT_STATE = "saved-state-export-state";
+
+    /** The key for saving {@link #mEntriesCount}|to instance bundle. */
+    private static final String SAVED_STATE_ENTRIES_COUNT = "saved-state-entries-count";
+
+    /** The key for saving {@link #mExportFileUri} to instance bundle. */
+    private static final String SAVED_STATE_EXPORT_FILE_URI = "saved-state-export-file-uri";
+
+    /** The delay after which the progress bar will be displayed. */
+    private static final int PROGRESS_BAR_DELAY_MS = 500;
+
+    // Values of the histogram recording password export related events.
+    @IntDef({
+        PasswordExportEvent.EXPORT_OPTION_SELECTED,
+        PasswordExportEvent.EXPORT_DISMISSED,
+        PasswordExportEvent.EXPORT_CONFIRMED,
+        PasswordExportEvent.COUNT
+    })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface PasswordExportEvent {
+        int EXPORT_OPTION_SELECTED = 0;
+        int EXPORT_DISMISSED = 1;
+        int EXPORT_CONFIRMED = 2;
+        int COUNT = 3;
+    }
+
+    /**
+     * When the user requests that passwords are exported and once the passwords are sent over from
+     * native code and stored in a cache file, this variable contains the content:// URI for that
+     * cache file, or an empty URI if there was a problem with storing to that file. During all
+     * other times, this variable is null. In particular, after the export is requested, the
+     * variable being null means that the passwords have not arrived from the native code yet.
+     */
+    private @Nullable Uri mExportFileUri;
+
+    /**
+     * The number of password entries contained in the most recent serialized data for password
+     * export. The null value indicates that serialization has not completed since the last request
+     * (or there was no request at all).
+     */
+    private @Nullable Integer mEntriesCount;
+
+    // Histogram values for "PasswordManager.Android.ExportPasswordsProgressBarUsage". Never remove
+    // or reuse them, only add new ones if needed to keep past and future UMA reports compatible.
+    @VisibleForTesting public static final int PROGRESS_NOT_SHOWN = 0;
+    @VisibleForTesting public static final int PROGRESS_HIDDEN_DIRECTLY = 1;
+    @VisibleForTesting public static final int PROGRESS_HIDDEN_DELAYED = 2;
+
+    // Takes care of displaying and hiding the progress bar for exporting, while avoiding
+    // flickering.
+    private final DialogManager mProgressBarManager = new DialogManager(null);
+
+    /**
+     * If an error dialog should be shown, this contains the arguments for it, such as the error
+     * message. If no error dialog should be shown, this is null.
+     */
+    private ExportErrorDialogFragment.@Nullable ErrorDialogParams mErrorDialogParams;
+
+    public DialogManager getDialogManagerForTesting() {
+        return mProgressBarManager;
+    }
+
+    /** The concrete delegate instance. It is (re)set in {@link #onCreate}. */
+    private Delegate mDelegate;
+
+    /** Histogram names for metrics logging. */
+    private String mCallerMetricsId;
+
+    private boolean mPasswordSerializationStarted;
+
+    public ExportFlow() {}
+
+    public String getExportEventHistogramName() {
+        return mCallerMetricsId + ".Event";
+    }
+
+    public String getExportResultHistogramName2ForTesting() {
+        return mCallerMetricsId + PasswordMetricsUtil.EXPORT_RESULT_HISTOGRAM_SUFFIX;
+    }
+
+    @Initializer
+    @Override
+    public void onCreate(
+            @Nullable Bundle savedInstanceState, Delegate delegate, String callerMetricsId) {
+        mDelegate = delegate;
+        mCallerMetricsId = callerMetricsId;
+
+        if (savedInstanceState == null) return;
+
+        if (savedInstanceState.containsKey(SAVED_STATE_EXPORT_STATE)) {
+            mExportState = savedInstanceState.getInt(SAVED_STATE_EXPORT_STATE);
+            if (mExportState == ExportState.CONFIRMED) {
+                // If export is underway, ensure that the UI is updated.
+                tryExporting();
+            }
+        }
+        if (savedInstanceState.containsKey(SAVED_STATE_EXPORT_FILE_URI)) {
+            String uriString = savedInstanceState.getString(SAVED_STATE_EXPORT_FILE_URI);
+            assumeNonNull(uriString);
+            if (uriString.isEmpty()) {
+                mExportFileUri = Uri.EMPTY;
+            } else {
+                mExportFileUri = Uri.parse(uriString);
+            }
+        }
+        if (savedInstanceState.containsKey(SAVED_STATE_ENTRIES_COUNT)) {
+            mEntriesCount = savedInstanceState.getInt(SAVED_STATE_ENTRIES_COUNT);
+        }
+    }
+
+    /**
+     * Returns true if the export flow is in progress, i.e., when the user interacts with some of
+     * its UI.
+     * @return True if in progress, false otherwise.
+     */
+    public boolean isActive() {
+        return mExportState != ExportState.INACTIVE;
+    }
+
+    /**
+     * A helper method which processes the signal that serialized passwords have been stored in the
+     * temporary file. It produces a sharing URI for that file, registers that file for deletion at
+     * the shutdown of the Java VM, logs some metrics and continues the flow.
+     * @param pathToPasswordsFile The filesystem path to the file containing the serialized
+     *                            passwords.
+     */
+    private void shareSerializedPasswords(String pathToPasswordsFile) {
+        // Don't display any UI if the user cancelled the export in the meantime.
+        if (mExportState == ExportState.INACTIVE) return;
+
+        File passwordsFile = new File(pathToPasswordsFile);
+        passwordsFile.deleteOnExit();
+
+        try {
+            mExportFileUri = FileProviderUtils.getContentUriFromFile(passwordsFile);
+        } catch (IllegalArgumentException e) {
+            showExportErrorAndAbort(
+                    R.string.password_settings_export_tips,
+                    e.getMessage(),
+                    getPositiveButtonLabelId(),
+                    HistogramExportResult.WRITE_FAILED);
+            return;
+        }
+
+        tryExporting();
+    }
+
+    /**
+     * Returns the path to the directory where serialized passwords are stored.
+     *
+     * @return A subdirectory of the cache, where serialized passwords are stored.
+     */
+    @VisibleForTesting
+    public static String getTargetDirectory() {
+        return ContextUtils.getApplicationContext().getCacheDir() + PASSWORDS_CACHE_DIR;
+    }
+
+    @Override
+    public void startExporting() {
+        assert mExportState == ExportState.INACTIVE;
+        mPasswordSerializationStarted = false;
+        // Disable re-triggering exporting until the current exporting finishes.
+        mExportState = ExportState.REQUESTED;
+
+        // Start fetching the serialized passwords now to use the time the user spends
+        // reauthenticating and reading the warning message. If the user cancels the export or
+        // fails the reauthentication, the serialized passwords will simply get ignored when
+        // they arrive.
+        mEntriesCount = null;
+        PasswordManagerHandler handler =
+                PasswordManagerHandlerProvider.getForProfile(mDelegate.getProfile())
+                        .getPasswordManagerHandler();
+        assumeNonNull(handler);
+        if (!handler.isWaitingForPasswordStore()) {
+            serializePasswords();
+        }
+        if (!ReauthenticationManager.isScreenLockSetUp(
+                mDelegate.getActivity().getApplicationContext())) {
+            Toast.makeText(
+                            mDelegate.getActivity().getApplicationContext(),
+                            R.string.password_export_set_lock_screen,
+                            Toast.LENGTH_LONG)
+                    .show();
+            // Re-enable exporting, the current one was cancelled by Chrome.
+            mExportState = ExportState.INACTIVE;
+        } else {
+            // Always trigger reauthentication at the start of the exporting flow, even if the last
+            // one succeeded recently.
+            ReauthenticationManager.displayReauthenticationFragment(
+                    R.string.lockscreen_description_export,
+                    mDelegate.getViewId(),
+                    mDelegate.getFragmentManager(),
+                    ReauthenticationManager.ReauthScope.BULK);
+        }
+    }
+
+    /** Starts fetching the serialized passwords. */
+    void serializePasswords() {
+        if (mPasswordSerializationStarted) return;
+        mPasswordSerializationStarted = true;
+        PasswordManagerHandler handler =
+                PasswordManagerHandlerProvider.getForProfile(mDelegate.getProfile())
+                        .getPasswordManagerHandler();
+        assumeNonNull(handler);
+        handler.serializePasswords(
+                getTargetDirectory(),
+                (int entriesCount, String pathToPasswordsFile) -> {
+                    mEntriesCount = entriesCount;
+                    shareSerializedPasswords(pathToPasswordsFile);
+                },
+                (String errorMessage) -> {
+                    showExportErrorAndAbort(
+                            R.string.password_settings_export_tips,
+                            errorMessage,
+                            getPositiveButtonLabelId(),
+                            HistogramExportResult.WRITE_FAILED);
+                });
+    }
+
+    @Override
+    public void passwordsAvailable() {
+        if (mExportState == ExportState.REQUESTED) {
+            serializePasswords();
+        }
+    }
+
+    /**
+     * Continues with the password export flow after the user successfully reauthenticated. Current
+     * state of export flow: the user tapped the menu item for export and passed reauthentication.
+     * The next steps are: confirming the export, waiting for exported data (if needed) and choosing
+     * a consumer app for the data.
+     */
+    private void exportAfterReauth() {
+        RecordHistogram.recordEnumeratedHistogram(
+                getExportEventHistogramName(),
+                PasswordExportEvent.EXPORT_CONFIRMED,
+                PasswordExportEvent.COUNT);
+        mExportState = ExportState.CONFIRMED;
+        // If the error dialog has been waiting (e. g. because password serialization failed while
+        // the user was authenticating), display it now, otherwise continue the export flow.
+        if (mErrorDialogParams != null) {
+            showExportErrorDialogFragment();
+        } else {
+            tryExporting();
+        }
+    }
+
+    /**
+     * Starts the exporting intent if both blocking events are completed: serializing and the
+     * confirmation flow. At this point, the user has tapped the menu item for export and passed
+     * reauthentication. Upon calling this method, the user has either also confirmed the export, or
+     * the exported data have been prepared. The method is called twice, once for each of those
+     * events. The next step after both the export is confirmed and the data is ready is to create
+     * document intent.
+     */
+    private void tryExporting() {
+        if (mExportState != ExportState.CONFIRMED) return;
+        if (mEntriesCount == null) {
+            // The serialization has not finished. Until this finishes, a progress bar is
+            // displayed with an option to cancel the export.
+            ProgressBarDialogFragment progressBarDialogFragment = new ProgressBarDialogFragment();
+            progressBarDialogFragment.setCancelProgressHandler(
+                    (unusedDialogInterface, button) -> {
+                        if (button == AlertDialog.BUTTON_NEGATIVE) {
+                            mExportState = ExportState.INACTIVE;
+                        }
+                    });
+            mProgressBarManager.show(progressBarDialogFragment, mDelegate.getFragmentManager());
+        } else {
+            // Note: if the serialization is quicker than the user interacting with the
+            // confirmation dialog, then there is no progress bar shown, in which case hide() is
+            // just calling the callback synchronously.
+            mProgressBarManager.hide(this::sendExportIntent);
+        }
+    }
+
+    /**
+     * Call this to abort the export UI flow and display an error description to the user.
+     *
+     * @param descriptionId The resource ID of a string with a brief explanation of the error.
+     * @param detailedDescription An optional string with more technical details about the error.
+     * @param positiveButtonLabelId The resource ID of the label of the positive button in the error
+     *     dialog.
+     */
+    @VisibleForTesting
+    void showExportErrorAndAbort(
+            int descriptionId,
+            @Nullable String detailedDescription,
+            int positiveButtonLabelId,
+            @HistogramExportResult int histogramExportResult) {
+        assert mErrorDialogParams == null;
+        mDelegate.onExportFlowFailed();
+        mProgressBarManager.hide(
+                () -> {
+                    showExportErrorAndAbortImmediately(
+                            descriptionId,
+                            detailedDescription,
+                            positiveButtonLabelId,
+                            histogramExportResult);
+                });
+    }
+
+    public void showExportErrorAndAbortImmediately(
+            int descriptionId,
+            @Nullable String detailedDescription,
+            int positiveButtonLabelId,
+            @HistogramExportResult int histogramExportResult) {
+        mErrorDialogParams = new ExportErrorDialogFragment.ErrorDialogParams();
+        mErrorDialogParams.positiveButtonLabelId = positiveButtonLabelId;
+        mErrorDialogParams.description =
+                mDelegate.getActivity().getResources().getString(descriptionId);
+
+        if (detailedDescription != null) {
+            mErrorDialogParams.detailedDescription =
+                    mDelegate
+                            .getActivity()
+                            .getResources()
+                            .getString(
+                                    R.string.password_settings_export_error_details,
+                                    detailedDescription);
+        }
+
+        showExportErrorDialogFragment();
+    }
+
+    /**
+     * This is a helper method to {@link #showExportErrorAndAbort}, responsible for showing the
+     * actual UI.
+     */
+    private void showExportErrorDialogFragment() {
+        assert mErrorDialogParams != null;
+
+        ExportErrorDialogFragment exportErrorDialogFragment = new ExportErrorDialogFragment();
+        int positiveButtonLabelId = mErrorDialogParams.positiveButtonLabelId;
+        exportErrorDialogFragment.initialize(mErrorDialogParams);
+        mErrorDialogParams = null;
+
+        exportErrorDialogFragment.setExportErrorHandler(
+                new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        if (which == AlertDialog.BUTTON_POSITIVE) {
+                            if (positiveButtonLabelId
+                                    == R.string.password_settings_export_learn_google_drive) {
+                                // Link to the help article about how to use Google Drive.
+                                Intent intent =
+                                        new Intent(
+                                                Intent.ACTION_VIEW,
+                                                Uri.parse(
+                                                        "https://support.google.com/drive/answer/2424384"));
+                                intent.setPackage(mDelegate.getActivity().getPackageName());
+                                mDelegate.getActivity().startActivity(intent);
+                            } else if (positiveButtonLabelId == R.string.try_again) {
+                                mExportState = ExportState.REQUESTED;
+                                // If `mExportFileUri` is null, it means that serialization has
+                                // failed. Need to restart it too.
+                                if (mExportFileUri == null) {
+                                    mPasswordSerializationStarted = false;
+                                    serializePasswords();
+                                }
+                                exportAfterReauth();
+                            }
+                        } else if (which == AlertDialog.BUTTON_NEGATIVE) {
+                            // Re-enable exporting, the current one was just cancelled.
+                            mDelegate.onExportFlowCanceled();
+                            mProgressBarManager.hide(CallbackUtils.emptyRunnable());
+                            mExportState = ExportState.INACTIVE;
+                            mExportFileUri = null;
+                        }
+                    }
+                });
+        exportErrorDialogFragment.show(mDelegate.getFragmentManager(), null);
+    }
+
+    /**
+     * If the URI of the file with exported passwords is not null, passes it into an implicit
+     * intent, so that the user can use a storage app to save the exported passwords.
+     */
+    private void sendExportIntent() {
+        assert mExportState == ExportState.CONFIRMED;
+        mExportState = ExportState.INACTIVE;
+
+        if (mExportFileUri != null && mExportFileUri.equals(Uri.EMPTY)) return;
+
+        runCreateFileOnDiskIntent();
+    }
+
+    private void runCreateFileOnDiskIntent() {
+        Intent saveToDownloads = new Intent(Intent.ACTION_CREATE_DOCUMENT);
+        saveToDownloads.setType("text/csv");
+        saveToDownloads.addCategory(Intent.CATEGORY_OPENABLE);
+        saveToDownloads.putExtra(
+                Intent.EXTRA_TITLE,
+                mDelegate
+                        .getActivity()
+                        .getResources()
+                        .getString(R.string.password_manager_default_export_filename));
+        try {
+            mDelegate.runCreateFileOnDiskIntent(saveToDownloads);
+        } catch (ActivityNotFoundException e) {
+            showExportErrorAndAbort(
+                    R.string.password_settings_export_no_app,
+                    e.getMessage(),
+                    getPositiveButtonLabelId(),
+                    HistogramExportResult.NO_CONSUMER);
+        }
+    }
+
+    @Override
+    public void savePasswordsToDownloads(Uri passwordsFile) {
+        if (passwordsFile == null) {
+            showExportErrorAndAbort(
+                    R.string.password_settings_export_tips,
+                    "Could not create file.",
+                    getPositiveButtonLabelId(),
+                    HistogramExportResult.WRITE_FAILED);
+            return;
+        }
+        new AsyncTask<@Nullable String>() {
+            @Override
+            protected @Nullable String doInBackground() {
+                assumeNonNull(mExportFileUri);
+                try {
+                    writeToInternalStorage(mExportFileUri, passwordsFile);
+                } catch (IOException e) {
+                    return e.getMessage();
+                }
+                return null;
+            }
+
+            @Override
+            protected void onPostExecute(@Nullable String exceptionMessage) {
+                mProgressBarManager.hide(
+                        () -> {
+                            if (exceptionMessage != null) {
+                                showExportErrorAndAbort(
+                                        R.string.password_settings_export_tips,
+                                        exceptionMessage,
+                                        getPositiveButtonLabelId(),
+                                        HistogramExportResult.WRITE_FAILED);
+                            } else {
+                                mDelegate.onExportFlowSucceeded();
+                                mExportFileUri = null;
+                                logPasswordsExportResult(
+                                        mCallerMetricsId, HistogramExportResult.SUCCESS);
+                            }
+                        });
+            }
+        }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+        mProgressBarManager.showWithDelay(
+                new NonCancelableProgressBar(R.string.passwords_export_in_progress_title),
+                mDelegate.getFragmentManager(),
+                PROGRESS_BAR_DELAY_MS);
+    }
+
+    private static void writeToInternalStorage(Uri exportedPasswordsUri, Uri savedPasswordsFileUri)
+            throws IOException {
+        try (InputStream fileInputStream =
+                ContextUtils.getApplicationContext()
+                        .getContentResolver()
+                        .openInputStream(exportedPasswordsUri)) {
+            try (OutputStream fileOutputStream =
+                    ContextUtils.getApplicationContext()
+                            .getContentResolver()
+                            .openOutputStream(savedPasswordsFileUri)) {
+                assumeNonNull(fileInputStream);
+                assumeNonNull(fileOutputStream);
+                FileUtils.copyStream(fileInputStream, fileOutputStream);
+            }
+        }
+    }
+
+    @Override
+    public void onResume() {
+        if (mExportState == ExportState.REQUESTED) {
+            if (ReauthenticationManager.authenticationStillValid(
+                    ReauthenticationManager.ReauthScope.BULK)) {
+                exportAfterReauth();
+            } else {
+                mExportState = ExportState.INACTIVE;
+            }
+        }
+    }
+
+    /**
+     * A hook to be used in a {@link Fragment}'s onSaveInstanceState method. I saves the state of
+     * the flow.
+     */
+    public void onSaveInstanceState(Bundle outState) {
+        outState.putInt(SAVED_STATE_EXPORT_STATE, mExportState);
+        if (mEntriesCount != null) {
+            outState.putInt(SAVED_STATE_ENTRIES_COUNT, mEntriesCount);
+        }
+        if (mExportFileUri != null) {
+            outState.putString(SAVED_STATE_EXPORT_FILE_URI, mExportFileUri.toString());
+        }
+    }
+
+    /**
+     * Returns whether the password export feature is ready to use.
+     * @return Returns true if the Reauthentication Api is available.
+     */
+    public static boolean providesPasswordExport() {
+        return ReauthenticationManager.isReauthenticationApiAvailable();
+    }
+
+    private int getPositiveButtonLabelId() {
+        // Don't allow to try restarting the export flow. The reason: it won't be able to create the
+        // file for saving passwords on disk because the dialog, which owns the export flow would be
+        // dismissed. There is a workaround: clicking on Google Password Manager will propose to
+        // restart the export flow.
+        // TODO (crbug.com/364530583): returning 0 here means there should be only one "Close"
+        // button in the dialog. Make error dialog configurable instead of passing a 0 resource into
+        // it.
+        return 0;
+    }
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlowInterface.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlowInterface.java
new file mode 100644
index 0000000000000..b586b4fcbbb4f
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ExportFlowInterface.java
@@ -0,0 +1,92 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.chrome.browser.profiles.Profile;
+
+/** An interface for the implementations of {@link ExportFlow}. */
+@NullMarked
+public interface ExportFlowInterface {
+    /** The delegate to provide ExportFlow with essential information from the owning fragment. */
+    public interface Delegate {
+        /**
+         * @return The activity associated with the owning fragment.
+         */
+        Activity getActivity();
+
+        /**
+         * @return The fragment manager associated with the owning fragment.
+         */
+        FragmentManager getFragmentManager();
+
+        /**
+         * @return The ID of the root view of the owning fragment.
+         */
+        int getViewId();
+
+        /**
+         * Runs the activity on the fragment owning the export flow.
+         *
+         * @param intent The intent to start an activity.
+         */
+        void runCreateFileOnDiskIntent(Intent intent);
+
+        /**
+         * Performs the actions that should happen after the export flow has successfully finished.
+         */
+        default void onExportFlowSucceeded() {}
+
+        /** Performs the actions that should happen after the export flow has failed. */
+        default void onExportFlowFailed() {}
+
+        /** Notifies about that export flow has been canceled. */
+        default void onExportFlowCanceled() {}
+
+        /** Return the {@link Profile} associated with the passwords. */
+        Profile getProfile();
+    }
+
+    /**
+     * A hook to be used in the onCreate method of the owning {@link Fragment}. I restores the state
+     * of the flow.
+     *
+     * @param savedInstanceState The {@link Bundle} passed from the fragment's onCreate method.
+     * @param delegate The {@link Delegate} for this ExportFlow.
+     * @param callerMetricsId The unique string, which identifies the caller. This will be used as
+     *     the prefix for metrics histograms names.
+     */
+    public void onCreate(
+            @Nullable Bundle savedInstanceState, Delegate delegate, String callerMetricsId);
+
+    /** Starts the password export flow. */
+    public void startExporting();
+
+    /**
+     * A hook to be used in a {@link Fragment}'s onResume method. I processes the result of the
+     * reauthentication.
+     */
+    public void onResume();
+
+    /** Continues the export flow when password list is available. */
+    public void passwordsAvailable();
+
+    /**
+     * Saves the passwords into the file (in the form of Uri) passed in.
+     *
+     * @param passwordsFile The file into which the passwords will be written (expected to be a file
+     *         Uri).
+     */
+    void savePasswordsToDownloads(Uri passwordsFile);
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordListObserver.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordListObserver.java
new file mode 100644
index 0000000000000..773d1f17a7389
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordListObserver.java
@@ -0,0 +1,28 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import org.chromium.build.annotations.NullMarked;
+
+/**
+ * An interface which a client can use to listen to changes to password and password exception
+ * lists.
+ */
+@NullMarked
+public interface PasswordListObserver {
+    /**
+     * Called when passwords list is updated.
+     *
+     * @param count Number of entries in the password list.
+     */
+    void passwordListAvailable(int count);
+
+    /**
+     * Called when password exceptions list is updated.
+     *
+     * @param count Number of entries in the password exception list.
+     */
+    void passwordExceptionListAvailable(int count);
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandler.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandler.java
new file mode 100644
index 0000000000000..49f2ac8b97812
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandler.java
@@ -0,0 +1,83 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import android.content.Context;
+
+import org.chromium.base.Callback;
+import org.chromium.base.IntStringCallback;
+import org.chromium.build.annotations.NullMarked;
+
+/**
+ * Interface for retrieving passwords and password exceptions (websites for which Chrome should not
+ * save password) from native code.
+ */
+@NullMarked
+public interface PasswordManagerHandler {
+    /** Called to insert a password entry into the password store. */
+    public void insertPasswordEntryForTesting(String origin, String username, String password);
+
+    /** Called to start fetching password and exception lists. */
+    void updatePasswordLists();
+
+    /**
+     * Get the saved password entry at index.
+     *
+     * @param index Index of Password.
+     * @return SavedPasswordEntry at index.
+     */
+    SavedPasswordEntry getSavedPasswordEntry(int index);
+
+    /**
+     * Get saved password exception at index.
+     *
+     * @param index of exception
+     * @return Origin of password exception.
+     */
+    String getSavedPasswordException(int index);
+
+    /**
+     * Remove saved password entry at index.
+     *
+     * @param index of password entry to remove.
+     */
+    void removeSavedPasswordEntry(int index);
+
+    /**
+     * Remove saved exception entry at index.
+     *
+     * @param index of exception entry.
+     */
+    void removeSavedPasswordException(int index);
+
+    /**
+     * Trigger serializing the saved passwords in the background.
+     *
+     * @param targetPath is the file to which the serialized passwords should be written.
+     * @param successCallback is called on successful completion, with the count of the serialized
+     * passwords and the path to the file containing them as argument.
+     * @param errorCallback is called on failure, with the error message as argument.
+     */
+    void serializePasswords(
+            String targetPath, IntStringCallback successCallback, Callback<String> errorCallback);
+
+    /**
+     * Show the UI that allows to edit saved credentials.
+     *
+     * @param context the current Activity to launch the edit view from, or an application context
+     *     if no Activity is available.
+     * @param index the index of the password entry to edit
+     * @param isBlockedCredential whether this credential is blocked for saving
+     */
+    void showPasswordEntryEditingView(Context context, int index, boolean isBlockedCredential);
+
+    /**
+     * Calls C++ to check whether the PasswordManagerHandler is still waiting for the passwords to
+     * be fetched from the password store.
+     *
+     * @return Returns true if the request to fetch the passwords is still pending.
+     */
+    boolean isWaitingForPasswordStore();
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandlerProvider.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandlerProvider.java
new file mode 100644
index 0000000000000..1b5da0ff5f0bf
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordManagerHandlerProvider.java
@@ -0,0 +1,144 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import static org.chromium.build.NullUtil.assumeNonNull;
+
+import org.chromium.base.ObserverList;
+import org.chromium.base.ThreadUtils;
+import org.chromium.base.lifetime.Destroyable;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.build.annotations.Nullable;
+import org.chromium.chrome.browser.profiles.Profile;
+import org.chromium.chrome.browser.profiles.ProfileKeyedMap;
+
+/**
+ * A provider for PasswordManagerHandler implementations, handling the choice of the proper one
+ * (production vs. testing), its lifetime and multiple observers.
+ *
+ * <p>This class is used by the code responsible for Chrome's passwords settings. There can only be
+ * one instance of Chrome's passwords settings opened at a time (although more clients of
+ * PasswordManagerHandler can live as nested settings pages).
+ */
+@NullMarked
+public class PasswordManagerHandlerProvider implements PasswordListObserver, Destroyable {
+    private static @Nullable ProfileKeyedMap<PasswordManagerHandlerProvider> sProfileMap;
+
+    /** Return the {@link PasswordManagerHandlerProvider} for the given {@link Profile}. */
+    public static PasswordManagerHandlerProvider getForProfile(Profile profile) {
+        if (sProfileMap == null) {
+            sProfileMap =
+                    ProfileKeyedMap.createMapOfDestroyables(
+                            ProfileKeyedMap.ProfileSelection.REDIRECTED_TO_ORIGINAL);
+        }
+        return sProfileMap.getForProfile(profile, PasswordManagerHandlerProvider::new);
+    }
+
+    private final Profile mProfile;
+
+    // The production implementation of PasswordManagerHandler is |sPasswordUiView|, instantiated on
+    // demand. Tests might want to override that by providing a fake implementation through
+    // setPasswordManagerHandlerForTest, which is then kept in |mTestPasswordManagerHandler|.
+    private @Nullable PasswordUiView mPasswordUiView;
+    private @Nullable PasswordManagerHandler mTestPasswordManagerHandler;
+
+    // This class is itself a PasswordListObserver, listening directly to a PasswordManagerHandler
+    // implementation. But it also keeps a list of other observers, to which it forwards the events.
+    private final ObserverList<PasswordListObserver> mObservers = new ObserverList<>();
+
+    private PasswordManagerHandlerProvider(Profile profile) {
+        mProfile = profile;
+    }
+
+    /**
+     * Sets a testing implementation of PasswordManagerHandler to be used. It overrides the
+     * production one even if it exists. The caller needs to ensure that |this| becomes an observer
+     * of |passwordManagerHandler|. Also, this must not be called when there are already some
+     * observers in |mObservers|, because of special handling of the production implementation of
+     * PasswordManagerHandler on removing the last observer.
+     */
+    public void setPasswordManagerHandlerForTest(PasswordManagerHandler passwordManagerHandler) {
+        ThreadUtils.assertOnUiThread();
+        assert mObservers.isEmpty();
+        mTestPasswordManagerHandler = passwordManagerHandler;
+    }
+
+    /**
+     * Resets the testing implementation of PasswordManagerHandler, clears all observers and ensures
+     * that the view is cleaned up properly.
+     */
+    public void resetPasswordManagerHandlerForTest() {
+        ThreadUtils.assertOnUiThread();
+        mObservers.clear();
+        mTestPasswordManagerHandler = null;
+        if (mPasswordUiView != null) {
+            mPasswordUiView.destroy();
+            mPasswordUiView = null;
+        }
+    }
+
+    @Override
+    public void destroy() {
+        if (mPasswordUiView != null) {
+            mPasswordUiView.destroy();
+            mPasswordUiView = null;
+        }
+    }
+
+    /**
+     * A convenience function to choose between the production and test PasswordManagerHandler
+     * implementation.
+     */
+    public @Nullable PasswordManagerHandler getPasswordManagerHandler() {
+        ThreadUtils.assertOnUiThread();
+        if (mTestPasswordManagerHandler != null) return mTestPasswordManagerHandler;
+        return mPasswordUiView;
+    }
+
+    /**
+     * This method creates the production implementation of PasswordManagerHandler and saves it into
+     * mPasswordUiView.
+     */
+    private void createPasswordManagerHandler() {
+        ThreadUtils.assertOnUiThread();
+        assert mPasswordUiView == null;
+        mPasswordUiView = new PasswordUiView(this, mProfile);
+    }
+
+    /** Starts forwarding events from the PasswordManagerHandler implementation to |observer|. */
+    public void addObserver(PasswordListObserver observer) {
+        ThreadUtils.assertOnUiThread();
+        if (getPasswordManagerHandler() == null) createPasswordManagerHandler();
+        mObservers.addObserver(observer);
+    }
+
+    public void removeObserver(PasswordListObserver observer) {
+        ThreadUtils.assertOnUiThread();
+        mObservers.removeObserver(observer);
+        // If this was the last observer of the production implementation of PasswordManagerHandler,
+        // call destroy on it to close the connection to the native C++ code.
+        if (mObservers.isEmpty() && mTestPasswordManagerHandler == null) {
+            assumeNonNull(mPasswordUiView);
+            mPasswordUiView.destroy();
+            mPasswordUiView = null;
+        }
+    }
+
+    @Override
+    public void passwordListAvailable(int count) {
+        ThreadUtils.assertOnUiThread();
+        for (PasswordListObserver observer : mObservers) {
+            observer.passwordListAvailable(count);
+        }
+    }
+
+    @Override
+    public void passwordExceptionListAvailable(int count) {
+        ThreadUtils.assertOnUiThread();
+        for (PasswordListObserver observer : mObservers) {
+            observer.passwordExceptionListAvailable(count);
+        }
+    }
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java
new file mode 100644
index 0000000000000..3ecf4fcab81d0
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordUiView.java
@@ -0,0 +1,191 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import android.content.Context;
+
+import org.jni_zero.CalledByNative;
+import org.jni_zero.JniType;
+import org.jni_zero.NativeMethods;
+
+import org.chromium.base.Callback;
+import org.chromium.base.IntStringCallback;
+import org.chromium.build.annotations.NullMarked;
+import org.chromium.chrome.browser.profiles.Profile;
+
+/**
+ * Production implementation of PasswordManagerHandler, making calls to native C++ code to retrieve
+ * the data.
+ */
+@NullMarked
+public final class PasswordUiView implements PasswordManagerHandler {
+    @CalledByNative
+    private static SavedPasswordEntry createSavedPasswordEntry(
+            @JniType("std::string") String url,
+            @JniType("std::u16string") String name,
+            @JniType("std::u16string") String password) {
+        return new SavedPasswordEntry(url, name, password);
+    }
+
+    // Pointer to native implementation, set to 0 in destroy().
+    private long mNativePasswordUiViewAndroid;
+
+    // This class has exactly one observer, set on construction and expected to last at least as
+    // long as this object (a good candidate is the owner of this object).
+    private final PasswordListObserver mObserver;
+
+    /**
+     * Constructor creates the native object as well. Callers should call destroy() after usage.
+     *
+     * @param observer The only observer.
+     * @param profile The {@link Profile} associated with these passwords.
+     */
+    public PasswordUiView(PasswordListObserver observer, Profile profile) {
+        mNativePasswordUiViewAndroid = PasswordUiViewJni.get().init(this, profile);
+        mObserver = observer;
+    }
+
+    @CalledByNative
+    private void passwordListAvailable(int count) {
+        mObserver.passwordListAvailable(count);
+    }
+
+    @CalledByNative
+    private void passwordExceptionListAvailable(int count) {
+        mObserver.passwordExceptionListAvailable(count);
+    }
+
+    @Override
+    public void insertPasswordEntryForTesting(String origin, String username, String password) {
+        PasswordUiViewJni.get()
+                .insertPasswordEntryForTesting(
+                        mNativePasswordUiViewAndroid, origin, username, password);
+    }
+
+    // Calls native to refresh password and exception lists. The native code calls back into
+    // passwordListAvailable and passwordExceptionListAvailable.
+    @Override
+    public void updatePasswordLists() {
+        PasswordUiViewJni.get().updatePasswordLists(mNativePasswordUiViewAndroid);
+    }
+
+    @Override
+    public SavedPasswordEntry getSavedPasswordEntry(int index) {
+        return PasswordUiViewJni.get().getSavedPasswordEntry(mNativePasswordUiViewAndroid, index);
+    }
+
+    @Override
+    public String getSavedPasswordException(int index) {
+        return PasswordUiViewJni.get()
+                .getSavedPasswordException(mNativePasswordUiViewAndroid, index);
+    }
+
+    @Override
+    public void removeSavedPasswordEntry(int index) {
+        PasswordUiViewJni.get().handleRemoveSavedPasswordEntry(mNativePasswordUiViewAndroid, index);
+    }
+
+    @Override
+    public void removeSavedPasswordException(int index) {
+        PasswordUiViewJni.get()
+                .handleRemoveSavedPasswordException(mNativePasswordUiViewAndroid, index);
+    }
+
+    @Override
+    public void serializePasswords(
+            String targetPath, IntStringCallback successCallback, Callback<String> errorCallback) {
+        PasswordUiViewJni.get()
+                .handleSerializePasswords(
+                        mNativePasswordUiViewAndroid, targetPath, successCallback, errorCallback);
+    }
+
+    @Override
+    public void showPasswordEntryEditingView(
+            Context context, int index, boolean isBlockedCredential) {
+        if (isBlockedCredential) {
+            PasswordUiViewJni.get()
+                    .handleShowBlockedCredentialView(mNativePasswordUiViewAndroid, context, index);
+            return;
+        }
+        PasswordUiViewJni.get()
+                .handleShowPasswordEntryEditingView(mNativePasswordUiViewAndroid, context, index);
+    }
+
+    /**
+     * Returns the URL for the website for managing one's passwords without the need to use Chrome
+     * with the user's profile signed in.
+     *
+     * @return The string with the URL.
+     */
+    public static String getAccountDashboardURL() {
+        return PasswordUiViewJni.get().getAccountDashboardURL();
+    }
+
+    /**
+     * Returns the URL of the help center article about trusted vault encryption.
+     *
+     * @return The string with the URL.
+     */
+    public static String getTrustedVaultLearnMoreURL() {
+        return PasswordUiViewJni.get().getTrustedVaultLearnMoreURL();
+    }
+
+    @Override
+    public boolean isWaitingForPasswordStore() {
+        return PasswordUiViewJni.get().isWaitingForPasswordStore(mNativePasswordUiViewAndroid);
+    }
+
+    /** Destroy the native object. */
+    public void destroy() {
+        if (mNativePasswordUiViewAndroid != 0) {
+            PasswordUiViewJni.get().destroy(mNativePasswordUiViewAndroid);
+            mNativePasswordUiViewAndroid = 0;
+        }
+    }
+
+    @NativeMethods
+    interface Natives {
+        long init(PasswordUiView self, @JniType("Profile*") Profile profile);
+
+        void insertPasswordEntryForTesting(
+                long nativePasswordUiViewAndroid,
+                @JniType("std::u16string") String origin,
+                @JniType("std::u16string") String username,
+                @JniType("std::u16string") String password);
+
+        void updatePasswordLists(long nativePasswordUiViewAndroid);
+
+        SavedPasswordEntry getSavedPasswordEntry(long nativePasswordUiViewAndroid, int index);
+
+        @JniType("std::string")
+        String getSavedPasswordException(long nativePasswordUiViewAndroid, int index);
+
+        void handleRemoveSavedPasswordEntry(long nativePasswordUiViewAndroid, int index);
+
+        void handleRemoveSavedPasswordException(long nativePasswordUiViewAndroid, int index);
+
+        @JniType("std::string")
+        String getAccountDashboardURL();
+
+        @JniType("std::string")
+        String getTrustedVaultLearnMoreURL();
+
+        boolean isWaitingForPasswordStore(long nativePasswordUiViewAndroid);
+
+        void destroy(long nativePasswordUiViewAndroid);
+
+        void handleSerializePasswords(
+                long nativePasswordUiViewAndroid,
+                @JniType("std::string") String targetPath,
+                IntStringCallback successCallback,
+                Callback<String> errorCallback);
+
+        void handleShowPasswordEntryEditingView(
+                long nativePasswordUiViewAndroid, Context context, int index);
+
+        void handleShowBlockedCredentialView(
+                long nativePasswordUiViewAndroid, Context context, int index);
+    }
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ProgressBarDialogFragment.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ProgressBarDialogFragment.java
new file mode 100644
index 0000000000000..a4312640f9275
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/ProgressBarDialogFragment.java
@@ -0,0 +1,70 @@
+// Copyright 2018 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+import org.chromium.build.annotations.Initializer;
+import org.chromium.build.annotations.NullMarked;
+
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import android.view.View;
+
+import androidx.appcompat.app.AlertDialog;
+import androidx.fragment.app.DialogFragment;
+
+//import org.chromium.chrome.R;
+import org.chromium.chrome.browser.password_manager.R;
+import org.chromium.components.browser_ui.widget.MaterialProgressBar;
+import org.chromium.build.annotations.Nullable;
+
+/**
+ * Shows the dialog that informs the user about the progress of preparing passwords for export and
+ * allows the user to cancel that operation.
+ */
+@NullMarked
+public class ProgressBarDialogFragment extends DialogFragment {
+    // This handler is used to perform the user-triggered cancellation of the password preparation.
+    private DialogInterface.OnClickListener mHandler;
+
+    @Initializer
+    public void setCancelProgressHandler(DialogInterface.OnClickListener handler) {
+        mHandler = handler;
+    }
+
+    /**
+     * Opens the dialog with the progress bar, hooks up the cancel button handler and sets the
+     * progress indicator to being indeterminate, because the background operation does not easily
+     * allow to signal its own progress.
+     */
+    @Override
+    public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) {
+        View dialog =
+                getActivity().getLayoutInflater().inflate(R.layout.passwords_progress_dialog, null);
+        MaterialProgressBar bar = dialog.findViewById(R.id.passwords_progress_bar);
+        bar.setIndeterminate(true);
+        return new AlertDialog.Builder(
+                        getActivity(), R.style.ThemeOverlay_BrowserUI_AlertDialog_NoActionBar)
+                .setView(dialog)
+                .setNegativeButton(R.string.cancel, mHandler)
+                .setTitle(
+                        getActivity()
+                                .getResources()
+                                .getString(R.string.settings_passwords_preparing_export))
+                .create();
+    }
+
+    @Override
+    public void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        // If there is a |savedInstanceState|, then the dialog is being recreated
+        // by Android and will lack the necessary click handler. Dismiss
+        // immediately, the settings page will recreate it with the appropriate
+        // click handler.
+        if (savedInstanceState != null) {
+            dismiss();
+            return;
+        }
+    }
+}
diff --git a/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/SavedPasswordEntry.java b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/SavedPasswordEntry.java
new file mode 100644
index 0000000000000..7a42dad83cf11
--- /dev/null
+++ b/chrome/browser/password_manager/android/java/src/org/chromium/chrome/browser/password_manager/settings/SavedPasswordEntry.java
@@ -0,0 +1,41 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager.settings;
+
+import org.chromium.build.annotations.NullMarked;
+
+/**
+ * A class representing information about a saved password entry in Chrome's settngs.
+ *
+ * <p>Note: This could be a nested class in the PasswordManagerHandler interface, but that would
+ * mean that PasswordUiView, which implements that interface and references SavedPasswordEntry in
+ * some of its JNI-registered methods, would need an explicit import of PasswordManagerHandler. That
+ * again would violate our presubmit checks, and https://crbug.com/424792 indicates that the
+ * preferred solution is to move the nested class to top-level.
+ */
+@NullMarked
+public final class SavedPasswordEntry {
+    private final String mUrl;
+    private final String mName;
+    private final String mPassword;
+
+    public SavedPasswordEntry(String url, String name, String password) {
+        mUrl = url;
+        mName = name;
+        mPassword = password;
+    }
+
+    public String getUrl() {
+        return mUrl;
+    }
+
+    public String getUserName() {
+        return mName;
+    }
+
+    public String getPassword() {
+        return mPassword;
+    }
+}
diff --git a/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManagerTest.java b/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManagerTest.java
index 88ec374ecfe66..6295521915520 100644
--- a/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManagerTest.java
+++ b/chrome/browser/password_manager/android/junit/src/org/chromium/chrome/browser/password_manager/settings/ReauthenticationManagerTest.java
@@ -151,7 +151,7 @@ public class ReauthenticationManagerTest {
                         ReauthenticationManager.ReauthScope.BULK));
 
         ReauthenticationManager.displayReauthenticationFragment(
-                R.string.lockscreen_description_view,
+                R.string.lockscreen_description_export,
                 View.NO_ID,
                 mFragmentManager,
                 ReauthenticationManager.ReauthScope.BULK);
diff --git a/chrome/browser/password_manager/android/password_ui_view_android.cc b/chrome/browser/password_manager/android/password_ui_view_android.cc
new file mode 100644
index 0000000000000..b56304b9b5466
--- /dev/null
+++ b/chrome/browser/password_manager/android/password_ui_view_android.cc
@@ -0,0 +1,365 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/password_manager/android/password_ui_view_android.h"
+
+#include <algorithm>
+#include <memory>
+#include <vector>
+
+#include "base/android/callback_android.h"
+#include "base/android/int_string_callback.h"
+#include "base/android/jni_string.h"
+#include "base/android/jni_weak_ref.h"
+#include "base/android/scoped_java_ref.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/functional/bind.h"
+#include "base/functional/callback_helpers.h"
+#include "base/logging.h"
+#include "base/metrics/field_trial.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/user_metrics.h"
+#include "base/metrics/user_metrics_action.h"
+#include "base/numerics/safe_conversions.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/common/url_constants.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/password_manager/core/browser/export/password_csv_writer.h"
+#include "components/password_manager/core/browser/form_parsing/form_data_parser.h"
+#include "components/password_manager/core/browser/leak_detection/leak_detection_check_impl.h"
+#include "components/password_manager/core/browser/password_form.h"
+#include "components/password_manager/core/browser/password_ui_utils.h"
+#include "components/password_manager/core/browser/ui/credential_provider_interface.h"
+#include "components/password_manager/core/browser/ui/credential_ui_entry.h"
+#include "content/public/browser/browser_thread.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "url/gurl.h"
+
+// Must come after other includes, because FromJniType() uses Profile.
+#include "chrome/browser/password_manager/android/jni_headers/PasswordUiView_jni.h"
+
+namespace {
+
+using base::android::JavaParamRef;
+using base::android::JavaRef;
+using base::android::ScopedJavaLocalRef;
+using IsInsecureCredential = CredentialEditBridge::IsInsecureCredential;
+
+PasswordUiViewAndroid::SerializationResult SerializePasswords(
+    const base::FilePath& target_directory,
+    std::vector<password_manager::CredentialUIEntry> credentials) {
+  // The UI should not trigger serialization if there are no passwords.
+  base::UmaHistogramBoolean(
+      "PasswordManager.ExportAndroid.MoreThanZeroPasswords",
+      credentials.size() > 0);
+
+  // Creating a file will block the execution on I/O.
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::WILL_BLOCK);
+
+  // Ensure that the target directory exists.
+  base::File::Error error = base::File::FILE_OK;
+  if (!base::CreateDirectoryAndGetError(target_directory, &error)) {
+    base::UmaHistogramExactLinear(
+        "PasswordManager.ExportAndroid.CreateDirectoryError", -error,
+        -base::File::Error::FILE_ERROR_MAX);
+    return {0, std::string(), base::File::ErrorToString(error)};
+  }
+
+  // Create a temporary file in the target directory to hold the serialized
+  // passwords.
+  base::FilePath export_file;
+  if (!base::CreateTemporaryFileInDir(target_directory, &export_file)) {
+    logging::SystemErrorCode error_code = logging::GetLastSystemErrorCode();
+    base::UmaHistogramExactLinear(
+        "PasswordManager.ExportAndroid.CreateTempFileError",
+        -base::File::OSErrorToFileError(error_code),
+        -base::File::Error::FILE_ERROR_MAX);
+    return {0, std::string(), logging::SystemErrorCodeToString(error_code)};
+  }
+
+  // Write the serialized data in CSV.
+  std::string data =
+      password_manager::PasswordCSVWriter::SerializePasswords(credentials);
+  if (!base::WriteFile(export_file, data)) {
+    logging::SystemErrorCode error_code = logging::GetLastSystemErrorCode();
+    base::UmaHistogramExactLinear(
+        "PasswordManager.ExportAndroid.WriteToTempFileError",
+        -base::File::OSErrorToFileError(error_code),
+        -base::File::Error::FILE_ERROR_MAX);
+    return {0, std::string(), logging::SystemErrorCodeToString(error_code)};
+  }
+
+  return {static_cast<int>(credentials.size()), export_file.value(),
+          std::string()};
+}
+
+}  // namespace
+
+PasswordUiViewAndroid::PasswordUiViewAndroid(
+    JNIEnv* env,
+    const jni_zero::JavaRef<jobject>& obj,
+    Profile* profile)
+    : profile_(profile),
+      profile_store_(ProfilePasswordStoreFactory::GetForProfile(
+          profile,
+          ServiceAccessType::EXPLICIT_ACCESS)),
+      saved_passwords_presenter_(
+          AffiliationServiceFactory::GetForProfile(profile),
+          profile_store_,
+          AccountPasswordStoreFactory::GetForProfile(
+              profile,
+              ServiceAccessType::EXPLICIT_ACCESS)),
+      weak_java_ui_controller_(env, obj) {
+  saved_passwords_presenter_.AddObserver(this);
+  saved_passwords_presenter_.Init();
+}
+
+PasswordUiViewAndroid::~PasswordUiViewAndroid() {
+  saved_passwords_presenter_.RemoveObserver(this);
+}
+
+void PasswordUiViewAndroid::Destroy(JNIEnv* env) {
+  switch (state_) {
+    case State::ALIVE:
+      delete this;
+      break;
+    case State::ALIVE_SERIALIZATION_PENDING:
+      // Postpone the deletion until the pending tasks are completed, so that
+      // the tasks do not attempt a use after free while reading data from
+      // |this|.
+      state_ = State::DELETION_PENDING;
+      break;
+    case State::DELETION_PENDING:
+      NOTREACHED();
+  }
+}
+
+void PasswordUiViewAndroid::InsertPasswordEntryForTesting(
+    JNIEnv* env,
+    const std::u16string& origin,
+    const std::u16string& username,
+    const std::u16string& password) {
+  password_manager::PasswordForm form;
+  form.url = GURL(origin);
+  form.signon_realm = password_manager::GetSignonRealm(form.url);
+  form.username_value = username;
+  form.password_value = password;
+
+  profile_store_->AddLogin(form);
+}
+
+void PasswordUiViewAndroid::UpdatePasswordLists(JNIEnv* env) {
+  DCHECK_EQ(State::ALIVE, state_);
+  UpdatePasswordLists();
+}
+
+ScopedJavaLocalRef<jobject> PasswordUiViewAndroid::GetSavedPasswordEntry(
+    JNIEnv* env,
+    int index) {
+  DCHECK_EQ(State::ALIVE, state_);
+  if (static_cast<size_t>(index) >= passwords_.size()) {
+    return Java_PasswordUiView_createSavedPasswordEntry(
+        env, std::string(), std::u16string(), std::u16string());
+  }
+  return Java_PasswordUiView_createSavedPasswordEntry(
+      env, password_manager::GetShownOrigin(passwords_[index]),
+      passwords_[index].username, passwords_[index].password);
+}
+
+std::string PasswordUiViewAndroid::GetSavedPasswordException(JNIEnv* env,
+                                                             int index) {
+  DCHECK_EQ(State::ALIVE, state_);
+  if (static_cast<size_t>(index) >= blocked_sites_.size()) {
+    return "";
+  }
+  return password_manager::GetShownOrigin(blocked_sites_[index]);
+}
+
+void PasswordUiViewAndroid::HandleRemoveSavedPasswordEntry(JNIEnv* env,
+                                                           int index) {
+  DCHECK_EQ(State::ALIVE, state_);
+  if (static_cast<size_t>(index) >= passwords_.size()) {
+    return;
+  }
+  if (saved_passwords_presenter_.RemoveCredential(passwords_[index])) {
+    base::RecordAction(
+        base::UserMetricsAction("PasswordManager_RemoveSavedPassword"));
+  }
+}
+
+void PasswordUiViewAndroid::HandleRemoveSavedPasswordException(JNIEnv* env,
+                                                               int index) {
+  DCHECK_EQ(State::ALIVE, state_);
+  if (static_cast<size_t>(index) >= passwords_.size()) {
+    return;
+  }
+  if (saved_passwords_presenter_.RemoveCredential(passwords_[index])) {
+    base::RecordAction(
+        base::UserMetricsAction("PasswordManager_RemovePasswordException"));
+  }
+}
+
+void PasswordUiViewAndroid::HandleSerializePasswords(
+    JNIEnv* env,
+    const std::string& java_target_directory,
+    const JavaRef<jobject>& success_callback,
+    const JavaRef<jobject>& error_callback) {
+  switch (state_) {
+    case State::ALIVE:
+      state_ = State::ALIVE_SERIALIZATION_PENDING;
+      break;
+    case State::ALIVE_SERIALIZATION_PENDING:
+      // The UI should not allow the user to re-request export before finishing
+      // or cancelling the pending one.
+      NOTREACHED();
+    case State::DELETION_PENDING:
+      // The Java part should not first request destroying of |this| and then
+      // ask |this| for serialized passwords.
+      NOTREACHED();
+  }
+  std::vector<password_manager::CredentialUIEntry> credentials =
+      saved_passwords_presenter_.GetSavedCredentials();
+  std::erase_if(credentials, [](const auto& credential) {
+    return credential.blocked_by_user;
+  });
+
+  // The tasks are posted with base::Unretained, because deletion is postponed
+  // until the reply arrives (look for the occurrences of DELETION_PENDING in
+  // this file). The background processing is not expected to take very long,
+  // but still long enough not to block the UI thread. The main concern here is
+  // not to avoid the background computation if |this| is about to be deleted
+  // but to simply avoid use after free from the background task runner.
+  base::ThreadPool::PostTaskAndReplyWithResult(
+      FROM_HERE, {base::TaskPriority::USER_VISIBLE, base::MayBlock()},
+      base::BindOnce(&SerializePasswords, base::FilePath(java_target_directory),
+                     std::move(credentials)),
+      base::BindOnce(
+          &PasswordUiViewAndroid::PostSerializedPasswords,
+          base::Unretained(this),
+          base::android::ScopedJavaGlobalRef<jobject>(env, success_callback),
+          base::android::ScopedJavaGlobalRef<jobject>(env, error_callback)));
+}
+
+void PasswordUiViewAndroid::HandleShowPasswordEntryEditingView(
+    JNIEnv* env,
+    const JavaParamRef<jobject>& context,
+    int index) {
+  if (static_cast<size_t>(index) >= passwords_.size() ||
+      credential_edit_bridge_) {
+    return;
+  }
+  bool is_using_account_store = passwords_[index].stored_in.contains(
+      password_manager::PasswordForm::Store::kAccountStore);
+  credential_edit_bridge_ = CredentialEditBridge::MaybeCreate(
+      passwords_[index], IsInsecureCredential(false),
+      GetUsernamesForRealm(saved_passwords_presenter_.GetSavedCredentials(),
+                           passwords_[index].GetFirstSignonRealm(),
+                           is_using_account_store),
+      &saved_passwords_presenter_,
+      base::BindOnce(&PasswordUiViewAndroid::OnEditUIDismissed,
+                     base::Unretained(this)),
+      context);
+}
+
+void PasswordUiViewAndroid::HandleShowBlockedCredentialView(
+    JNIEnv* env,
+    const JavaParamRef<jobject>& context,
+    int index) {
+  if (static_cast<size_t>(index) >= blocked_sites_.size() ||
+      credential_edit_bridge_) {
+    return;
+  }
+  credential_edit_bridge_ = CredentialEditBridge::MaybeCreate(
+      blocked_sites_[index], IsInsecureCredential(false),
+      std::vector<std::u16string>(), &saved_passwords_presenter_,
+      base::BindOnce(&PasswordUiViewAndroid::OnEditUIDismissed,
+                     base::Unretained(this)),
+      context);
+}
+
+void PasswordUiViewAndroid::OnEditUIDismissed() {
+  credential_edit_bridge_.reset();
+}
+
+std::string JNI_PasswordUiView_GetAccountDashboardURL(JNIEnv* env) {
+  return l10n_util::GetStringUTF8(IDS_PASSWORDS_WEB_LINK);
+}
+
+std::string JNI_PasswordUiView_GetTrustedVaultLearnMoreURL(JNIEnv* env) {
+  return chrome::kSyncTrustedVaultLearnMoreURL;
+}
+
+jboolean PasswordUiViewAndroid::IsWaitingForPasswordStore(JNIEnv* env) {
+  return saved_passwords_presenter_.IsWaitingForPasswordStore();
+}
+
+// static
+static jlong JNI_PasswordUiView_Init(
+    JNIEnv* env,
+    const base::android::JavaParamRef<jobject>& obj,
+    Profile* profile) {
+  PasswordUiViewAndroid* controller =
+      new PasswordUiViewAndroid(env, obj, profile);
+  return reinterpret_cast<intptr_t>(controller);
+}
+
+void PasswordUiViewAndroid::OnSavedPasswordsChanged(
+    const password_manager::PasswordStoreChangeList& changes) {
+  UpdatePasswordLists();
+}
+
+void PasswordUiViewAndroid::UpdatePasswordLists() {
+  passwords_.clear();
+  blocked_sites_.clear();
+  for (auto& credential : saved_passwords_presenter_.GetSavedCredentials()) {
+    if (credential.blocked_by_user) {
+      blocked_sites_.push_back(std::move(credential));
+    } else {
+      passwords_.push_back(std::move(credential));
+    }
+  }
+  JNIEnv* env = base::android::AttachCurrentThread();
+  ScopedJavaLocalRef<jobject> ui_controller = weak_java_ui_controller_.get(env);
+  if (!ui_controller.is_null()) {
+    Java_PasswordUiView_passwordListAvailable(
+        env, ui_controller, static_cast<int>(passwords_.size()));
+    Java_PasswordUiView_passwordExceptionListAvailable(
+        env, ui_controller, static_cast<int>(blocked_sites_.size()));
+  }
+}
+
+void PasswordUiViewAndroid::PostSerializedPasswords(
+    const base::android::JavaRef<jobject>& success_callback,
+    const base::android::JavaRef<jobject>& error_callback,
+    SerializationResult serialization_result) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  switch (state_) {
+    case State::ALIVE:
+      NOTREACHED();
+    case State::ALIVE_SERIALIZATION_PENDING: {
+      state_ = State::ALIVE;
+      if (export_target_for_testing_) {
+        *export_target_for_testing_ = serialization_result;
+      } else {
+        if (serialization_result.entries_count) {
+          base::android::RunIntStringCallbackAndroid(
+              success_callback, serialization_result.entries_count,
+              serialization_result.exported_file_path);
+        } else {
+          base::android::RunStringCallbackAndroid(error_callback,
+                                                  serialization_result.error);
+        }
+      }
+      break;
+    }
+    case State::DELETION_PENDING:
+      delete this;
+      break;
+  }
+}
diff --git a/chrome/browser/password_manager/android/password_ui_view_android.h b/chrome/browser/password_manager/android/password_ui_view_android.h
new file mode 100644
index 0000000000000..64d4d29fe6a50
--- /dev/null
+++ b/chrome/browser/password_manager/android/password_ui_view_android.h
@@ -0,0 +1,170 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_PASSWORD_MANAGER_ANDROID_PASSWORD_UI_VIEW_ANDROID_H_
+#define CHROME_BROWSER_PASSWORD_MANAGER_ANDROID_PASSWORD_UI_VIEW_ANDROID_H_
+
+#include <stddef.h>
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/android/jni_weak_ref.h"
+#include "base/android/scoped_java_ref.h"
+#include "base/memory/raw_ptr.h"
+#include "chrome/browser/affiliations/affiliation_service_factory.h"
+#include "chrome/browser/password_entry_edit/android/credential_edit_bridge.h"
+#include "chrome/browser/password_manager/account_password_store_factory.h"
+#include "chrome/browser/password_manager/profile_password_store_factory.h"
+#include "chrome/browser/signin/identity_manager_factory.h"
+#include "components/password_manager/core/browser/password_store/password_store_consumer.h"
+#include "components/password_manager/core/browser/ui/saved_passwords_presenter.h"
+
+class Profile;
+
+namespace password_manager {
+class CredentialProviderInterface;
+}
+
+// PasswordUIView for Android, contains jni hooks that allows Android UI to
+// display passwords and route UI commands back to SavedPasswordsPresenter.
+class PasswordUiViewAndroid
+    : public password_manager::SavedPasswordsPresenter::Observer {
+ public:
+  // Result of transforming a vector of PasswordForms into their CSV
+  // description and writing that to disk.
+  struct SerializationResult {
+    // The number of password entries written. 0 if error encountered.
+    int entries_count;
+
+    // The path to the temporary file containing the serialized passwords. Empty
+    // if error encountered.
+    std::string exported_file_path;
+
+    // The error description recorded after the last write operation. Empty if
+    // no error encountered.
+    std::string error;
+  };
+
+  PasswordUiViewAndroid(JNIEnv* env,
+                        const jni_zero::JavaRef<jobject>& obj,
+                        Profile* profile);
+
+  PasswordUiViewAndroid(const PasswordUiViewAndroid&) = delete;
+  PasswordUiViewAndroid& operator=(const PasswordUiViewAndroid&) = delete;
+
+  ~PasswordUiViewAndroid() override;
+
+  // Calls from Java.
+  base::android::ScopedJavaLocalRef<jobject> GetSavedPasswordEntry(
+      JNIEnv* env,
+      int index);
+  std::string GetSavedPasswordException(JNIEnv* env,
+                                        int index);
+  void InsertPasswordEntryForTesting(JNIEnv* env,
+                                     const std::u16string& origin,
+                                     const std::u16string& username,
+                                     const std::u16string& password);
+  void UpdatePasswordLists(JNIEnv* env);
+  void HandleRemoveSavedPasswordEntry(JNIEnv* env,
+                                      int index);
+  void HandleRemoveSavedPasswordException(
+      JNIEnv* env,
+      int index);
+  void HandleSerializePasswords(
+      JNIEnv* env,
+      const std::string& java_target_directory,
+      const base::android::JavaRef<jobject>& success_callback,
+      const base::android::JavaRef<jobject>& error_callback);
+  void HandleShowPasswordEntryEditingView(
+      JNIEnv* env,
+      const base::android::JavaParamRef<jobject>& context,
+      int index);
+  void HandleShowBlockedCredentialView(
+      JNIEnv* env,
+      const base::android::JavaParamRef<jobject>& context,
+      int index);
+  jboolean IsWaitingForPasswordStore(JNIEnv* env);
+  // Destroy the native implementation.
+  void Destroy(JNIEnv*);
+
+  void OnEditUIDismissed();
+
+  void set_export_target_for_testing(
+      SerializationResult* export_target_for_testing) {
+    export_target_for_testing_ = export_target_for_testing;
+  }
+
+  void set_credential_provider_for_testing(
+      password_manager::CredentialProviderInterface* provider) {
+    credential_provider_for_testing_ = provider;
+  }
+
+ private:
+  // Possible states in the life of PasswordUiViewAndroid.
+  // ALIVE:
+  //   * Destroy was not called and no background tasks are pending.
+  //   * All data members can be used on the main task runner.
+  // ALIVE_SERIALIZATION_PENDING:
+  //   * Destroy was not called, password serialization task on another task
+  //     runner is running.
+  //   * All data members can be used on the main task runner, except for
+  //     |saved_passwords_presenter_| which can only be used inside
+  //     ObtainAndSerializePasswords, which is being run on a backend task
+  //     runner.
+  // DELETION_PENDING:
+  //   * Destroy() was called, a background task is pending and |this| should
+  //     be deleted once the tasks complete.
+  //   * This state should not be reached anywhere but in the completion call
+  //     of the pending task.
+  enum class State { ALIVE, ALIVE_SERIALIZATION_PENDING, DELETION_PENDING };
+
+  // password_manager::SavedPasswordsPresenter::Observer implementation.
+  void OnSavedPasswordsChanged(
+      const password_manager::PasswordStoreChangeList& changes) override;
+
+  void UpdatePasswordLists();
+
+  // Sends |serialization_result| to Java via |success_callback| or
+  // |error_callback|, depending on whether the result is a success or an error.
+  void PostSerializedPasswords(
+      const base::android::JavaRef<jobject>& success_callback,
+      const base::android::JavaRef<jobject>& error_callback,
+      SerializationResult serialization_result);
+
+  // The |state_| must only be accessed on the main task runner.
+  State state_ = State::ALIVE;
+
+  // If not null, PostSerializedPasswords will write the serialized passwords to
+  // |*export_target_for_testing_| instead of passing them to Java. This must
+  // remain null in production code.
+  raw_ptr<SerializationResult> export_target_for_testing_ = nullptr;
+
+  raw_ptr<Profile> profile_;
+
+  // Pointer to the password store, powering |saved_passwords_presenter_|.
+  scoped_refptr<password_manager::PasswordStoreInterface> profile_store_;
+
+  // Manages the list of saved passwords, including updates.
+  password_manager::SavedPasswordsPresenter saved_passwords_presenter_;
+
+  // Cached passwords and blocked sites.
+  std::vector<password_manager::CredentialUIEntry> passwords_;
+  std::vector<password_manager::CredentialUIEntry> blocked_sites_;
+
+  // If not null, passwords for exporting will be obtained from
+  // |*credential_provider_for_testing_|, otherwise from
+  // |saved_passwords_presenter_|. This must remain null in production code.
+  raw_ptr<password_manager::CredentialProviderInterface>
+      credential_provider_for_testing_ = nullptr;
+
+  // Java side of UI controller.
+  JavaObjectWeakGlobalRef weak_java_ui_controller_;
+
+  // Used to open the view/edit/delete UI.
+  std::unique_ptr<CredentialEditBridge> credential_edit_bridge_;
+};
+
+#endif  // CHROME_BROWSER_PASSWORD_MANAGER_ANDROID_PASSWORD_UI_VIEW_ANDROID_H_
diff --git a/chrome/browser/password_manager/android/password_ui_view_android_unittest.cc b/chrome/browser/password_manager/android/password_ui_view_android_unittest.cc
new file mode 100644
index 0000000000000..26acb30b4b173
--- /dev/null
+++ b/chrome/browser/password_manager/android/password_ui_view_android_unittest.cc
@@ -0,0 +1,198 @@
+// Copyright 2017 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/password_manager/android/password_ui_view_android.h"
+
+#include <jni.h>
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/android/jni_android.h"
+#include "base/android/jni_string.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/memory/raw_ptr.h"
+#include "base/run_loop.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/types/fixed_array.h"
+#include "chrome/browser/password_manager/password_manager_test_util.h"
+#include "chrome/browser/profiles/profile_manager.h"
+#include "chrome/browser/profiles/profiles_state.h"
+#include "chrome/test/base/testing_browser_process.h"
+#include "chrome/test/base/testing_profile.h"
+#include "chrome/test/base/testing_profile_manager.h"
+#include "components/password_manager/core/browser/export/password_csv_writer.h"
+#include "components/password_manager/core/browser/password_form.h"
+#include "components/password_manager/core/browser/password_store/test_password_store.h"
+#include "components/password_manager/core/browser/ui/credential_ui_entry.h"
+#include "content/public/test/browser_task_environment.h"
+#include "content/public/test/test_utils.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "url/gurl.h"
+
+namespace android {
+
+using base::android::AttachCurrentThread;
+using base::android::JavaParamRef;
+using password_manager::PasswordForm;
+using password_manager::TestPasswordStore;
+
+namespace {
+
+// Specific deleter for PasswordUiViewAndroid, which calls
+// PasswordUiViewAndroid::Destroy on the object. Use this with a
+// std::unique_ptr.
+struct PasswordUiViewAndroidDestroyDeleter {
+  inline void operator()(void* ptr) const {
+    (static_cast<PasswordUiViewAndroid*>(ptr)->Destroy(nullptr));
+  }
+};
+
+}  // namespace
+
+class PasswordUiViewAndroidTest : public ::testing::Test {
+ protected:
+  PasswordUiViewAndroidTest()
+      : testing_profile_manager_(TestingBrowserProcess::GetGlobal()),
+        env_(AttachCurrentThread()) {}
+
+  void SetUp() override {
+    ASSERT_TRUE(testing_profile_manager_.SetUp());
+    testing_profile_ =
+        testing_profile_manager_.CreateTestingProfile("TestProfile");
+    profiles::SetLastUsedProfile(testing_profile_->GetBaseName());
+
+    store_ = CreateAndUseTestPasswordStore(testing_profile_);
+    store_->Init(/*prefs=*/nullptr, /*affiliated_match_helper=*/nullptr);
+    ASSERT_TRUE(temp_dir().CreateUniqueTempDir());
+  }
+
+  void TearDown() override {
+    store_->ShutdownOnUIThread();
+    RunUntilIdle();
+  }
+
+  PasswordForm AddPasswordEntry(const std::string& origin,
+                                const std::string& username,
+                                const std::string& password) {
+    PasswordForm form;
+    form.url = GURL(origin);
+    form.signon_realm = origin;
+    form.username_value = base::UTF8ToUTF16(username);
+    form.password_value = base::UTF8ToUTF16(password);
+    store_->AddLogin(form);
+    RunUntilIdle();
+    return form;
+  }
+
+  void RunUntilIdle() { task_environment_.RunUntilIdle(); }
+
+  raw_ptr<JNIEnv> env() { return env_; }
+  base::ScopedTempDir& temp_dir() { return temp_dir_; }
+
+ protected:
+  raw_ptr<TestingProfile> testing_profile_;
+
+ private:
+  content::BrowserTaskEnvironment task_environment_;
+  TestingProfileManager testing_profile_manager_;
+  scoped_refptr<TestPasswordStore> store_;
+  raw_ptr<JNIEnv> env_;
+  base::ScopedTempDir temp_dir_;
+};
+
+// Test that the asynchronous processing of password serialization controlled by
+// PasswordUiViewAndroid arrives at the same result as synchronous way to
+// serialize the passwords.
+TEST_F(PasswordUiViewAndroidTest, GetSerializedPasswords) {
+  PasswordForm form =
+      AddPasswordEntry("https://example.com", "username", "password");
+
+  // Let the PasswordCSVWriter compute the result instead of hard-coding it,
+  // because this test focuses on PasswordUIView and not on detecting changes in
+  // PasswordCSVWriter.
+  const std::string expected_result =
+      password_manager::PasswordCSVWriter::SerializePasswords(
+          {password_manager::CredentialUIEntry(form)});
+
+  std::unique_ptr<PasswordUiViewAndroid, PasswordUiViewAndroidDestroyDeleter>
+      password_ui_view(new PasswordUiViewAndroid(
+          env(), JavaParamRef<jobject>(nullptr), testing_profile_));
+  // SavedPasswordsPresenter needs time to initialize and fetch passwords.
+  RunUntilIdle();
+
+  PasswordUiViewAndroid::SerializationResult serialized_passwords;
+  password_ui_view->set_export_target_for_testing(&serialized_passwords);
+  password_ui_view->HandleSerializePasswords(
+      env(), temp_dir().GetPath().AsUTF8Unsafe(), nullptr, nullptr);
+
+  content::RunAllTasksUntilIdle();
+  // The buffer for actual result is 1 byte longer than the expected data to be
+  // able to detect when the actual data are too long.
+  base::FixedArray<char> actual_result(expected_result.size() + 1);
+  int number_of_bytes_read = base::ReadFile(
+      base::FilePath::FromUTF8Unsafe(serialized_passwords.exported_file_path),
+      actual_result.data(), expected_result.size() + 1);
+  EXPECT_EQ(static_cast<int>(expected_result.size()), number_of_bytes_read);
+  EXPECT_EQ(expected_result,
+            std::string(actual_result.data(),
+                        (number_of_bytes_read < 0) ? 0 : number_of_bytes_read));
+  EXPECT_EQ(1, serialized_passwords.entries_count);
+  EXPECT_FALSE(serialized_passwords.exported_file_path.empty());
+  EXPECT_EQ(std::string(), serialized_passwords.error);
+}
+
+// Test that destroying the PasswordUIView when tasks are pending does not lead
+// to crashes.
+TEST_F(PasswordUiViewAndroidTest, GetSerializedPasswords_Cancelled) {
+  AddPasswordEntry("https://example.com", "username", "password");
+
+  std::unique_ptr<PasswordUiViewAndroid, PasswordUiViewAndroidDestroyDeleter>
+      password_ui_view(new PasswordUiViewAndroid(
+          env(), JavaParamRef<jobject>(nullptr), testing_profile_));
+  // SavedPasswordsPresenter needs time to initialize and fetch passwords.
+  RunUntilIdle();
+
+  PasswordUiViewAndroid::SerializationResult serialized_passwords;
+  serialized_passwords.entries_count = 123;
+  serialized_passwords.exported_file_path = "somepath";
+  password_ui_view->set_export_target_for_testing(&serialized_passwords);
+  password_ui_view->HandleSerializePasswords(
+      env(), temp_dir().GetPath().AsUTF8Unsafe(), nullptr, nullptr);
+  // Register the PasswordUIView for deletion. It should not destruct itself
+  // before the background tasks are run. The results of the background tasks
+  // are waited for and then thrown out, so |serialized_passwords| should not be
+  // overwritten.
+  password_ui_view.reset();
+  // Now run the background tasks (and the subsequent deletion).
+  content::RunAllTasksUntilIdle();
+  EXPECT_EQ(123, serialized_passwords.entries_count);
+  EXPECT_EQ("somepath", serialized_passwords.exported_file_path);
+  EXPECT_EQ(std::string(), serialized_passwords.error);
+}
+
+// Test that an I/O error is reported.
+TEST_F(PasswordUiViewAndroidTest, GetSerializedPasswords_WriteFailed) {
+  AddPasswordEntry("https://example.com", "username", "password");
+
+  std::unique_ptr<PasswordUiViewAndroid, PasswordUiViewAndroidDestroyDeleter>
+      password_ui_view(new PasswordUiViewAndroid(
+          env(), JavaParamRef<jobject>(nullptr), testing_profile_));
+  // SavedPasswordsPresenter needs time to initialize and fetch passwords.
+  RunUntilIdle();
+
+  PasswordUiViewAndroid::SerializationResult serialized_passwords;
+  password_ui_view->set_export_target_for_testing(&serialized_passwords);
+  password_ui_view->HandleSerializePasswords(
+      env(), "/This directory cannot be created", nullptr, nullptr);
+  content::RunAllTasksUntilIdle();
+  EXPECT_EQ(0, serialized_passwords.entries_count);
+  EXPECT_FALSE(serialized_passwords.error.empty());
+}
+
+}  //  namespace android
diff --git a/chrome/browser/password_manager/android/test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordManagerHandler.java b/chrome/browser/password_manager/android/test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordManagerHandler.java
new file mode 100644
index 0000000000000..6f187c60ac7ea
--- /dev/null
+++ b/chrome/browser/password_manager/android/test_support/java/src/org/chromium/chrome/browser/password_manager/FakePasswordManagerHandler.java
@@ -0,0 +1,135 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.chrome.browser.password_manager;
+
+import android.content.Context;
+
+import androidx.annotation.Nullable;
+
+import org.chromium.base.Callback;
+import org.chromium.base.IntStringCallback;
+import org.chromium.chrome.browser.password_manager.settings.PasswordListObserver;
+import org.chromium.chrome.browser.password_manager.settings.PasswordManagerHandler;
+import org.chromium.chrome.browser.password_manager.settings.SavedPasswordEntry;
+
+import java.util.ArrayList;
+
+/** Fake implementation for the PasswordManagerHandler. */
+public final class FakePasswordManagerHandler implements PasswordManagerHandler {
+    // This class has exactly one observer, set on construction and expected to last at least as
+    // long as this object (a good candidate is the owner of this object).
+    private final PasswordListObserver mObserver;
+
+    // The faked contents of the password store to be displayed.
+    private ArrayList<SavedPasswordEntry> mSavedPasswords = new ArrayList<>();
+
+    // The faked contents of the saves password exceptions to be displayed.
+    private ArrayList<String> mSavedPasswordExeptions = new ArrayList<>();
+
+    // The following three data members are set once {@link #serializePasswords()} is called.
+    @Nullable private IntStringCallback mExportSuccessCallback;
+
+    @Nullable private Callback<String> mExportErrorCallback;
+
+    @Nullable private String mExportTargetPath;
+
+    private int mSerializationInvocationCount;
+
+    public void setSavedPasswords(ArrayList<SavedPasswordEntry> savedPasswords) {
+        mSavedPasswords = savedPasswords;
+    }
+
+    public void setSavedPasswordExceptions(ArrayList<String> savedPasswordExceptions) {
+        mSavedPasswordExeptions = savedPasswordExceptions;
+    }
+
+    public IntStringCallback getExportSuccessCallback() {
+        return mExportSuccessCallback;
+    }
+
+    public Callback<String> getExportErrorCallback() {
+        return mExportErrorCallback;
+    }
+
+    public String getExportTargetPath() {
+        return mExportTargetPath;
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param observer The only observer.
+     */
+    public FakePasswordManagerHandler(PasswordListObserver observer) {
+        mObserver = observer;
+        mSerializationInvocationCount = 0;
+    }
+
+    /**
+     * A getter for the faked contents of the password store.
+     *
+     * @return the faked contents of the password store.
+     */
+    public ArrayList<SavedPasswordEntry> getSavedPasswordEntriesForTesting() {
+        return mSavedPasswords;
+    }
+
+    @Override
+    public void insertPasswordEntryForTesting(String origin, String username, String password) {
+        mSavedPasswords.add(new SavedPasswordEntry(origin, username, password));
+    }
+
+    // Pretends that the updated lists are |mSavedPasswords| for the saved passwords and an
+    // empty list for exceptions and immediately calls the observer.
+    @Override
+    public void updatePasswordLists() {
+        mObserver.passwordListAvailable(mSavedPasswords.size());
+        mObserver.passwordExceptionListAvailable(mSavedPasswordExeptions.size());
+    }
+
+    @Override
+    public SavedPasswordEntry getSavedPasswordEntry(int index) {
+        return mSavedPasswords.get(index);
+    }
+
+    @Override
+    public String getSavedPasswordException(int index) {
+        return mSavedPasswordExeptions.get(index);
+    }
+
+    @Override
+    public void removeSavedPasswordEntry(int index) {
+        assert false : "Define this method before starting to use it in tests.";
+    }
+
+    @Override
+    public void removeSavedPasswordException(int index) {
+        assert false : "Define this method before starting to use it in tests.";
+    }
+
+    @Override
+    public void serializePasswords(
+            String targetPath, IntStringCallback successCallback, Callback<String> errorCallback) {
+        mExportSuccessCallback = successCallback;
+        mExportErrorCallback = errorCallback;
+        mExportTargetPath = targetPath;
+        mSerializationInvocationCount += 1;
+    }
+
+    @Override
+    public void showPasswordEntryEditingView(
+            Context context, int index, boolean isBlockedCredential) {
+        assert false : "Define this method before starting to use it in tests.";
+    }
+
+    @Override
+    public boolean isWaitingForPasswordStore() {
+        return false;
+    }
+
+    public int getSerializationInvocationCount() {
+        return mSerializationInvocationCount;
+    }
+}
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings.grd b/chrome/browser/ui/android/strings/android_chrome_strings.grd
index e14b83365d76a..9fb93aea9073c 100644
--- a/chrome/browser/ui/android/strings/android_chrome_strings.grd
+++ b/chrome/browser/ui/android/strings/android_chrome_strings.grd
@@ -690,6 +690,15 @@ For more settings that use data to improve your Vanadium experience, go to <ph n
       <message name="IDS_PASSWORD_SAVING_OFF_BY_ADMINISTRATOR" desc="Subtitle for the settings menu item leading to the Password Manager UI surface, shown when the device administrator set saving passwords to disabled.">
         Password saving is turned off by your administrator
       </message>
+      <message name="IDS_PASSWORD_SETTINGS_SAVE_PASSWORDS" desc="Title for the checkbox toggling whether passwords are saved or not. [CHAR_LIMIT=32]">
+        Save passwords
+      </message>
+      <message name="IDS_PASSWORDS_AUTO_SIGNIN_TITLE" desc="Title for checkbox to enable automatically signing the user in to websites">
+        Auto Sign-in
+      </message>
+      <message name="IDS_PASSWORDS_AUTO_SIGNIN_DESCRIPTION" desc="Text under 'Auto sign-in' checkbox">
+        Automatically sign in to websites using stored credentials. When the feature is off, you’ll be asked for verification every time before signing in to a website.
+      </message>
       <message name="IDS_PASSWORDS_LEAK_DETECTION_SWITCH_TITLE" desc="Title for the switch toggling whether Vanadium should check that entered credentials have been part of a leak.">
         Warn you if a password was compromised in a data breach
       </message>
@@ -699,9 +708,30 @@ For more settings that use data to improve your Vanadium experience, go to <ph n
       <message name="IDS_PASSWORDS_CHECK_TITLE" desc="Title for the check passwords button which allows to check whether the user's passwords have been compromised.">
         Check passwords
       </message>
+      <message name="IDS_PASSWORDS_CHECK_DESCRIPTION" desc="Text explaining the benefits of checking the passwords, to be displayed under the Check Passwords button title.">
+        Keep your passwords safe from data breaches and other security issues
+      </message>
+      <message name="IDS_ANDROID_TRUSTED_VAULT_BANNER_LABEL" desc="Title for the on-device encryption banner in password settings.">
+        On-device encryption
+      </message>
+      <message name="IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OFFER_OPT_IN" desc="Sub-label for the on-device encryption banner when the user is offered to opt in.">
+        For added safety, encrypt passwords on your device before they‘re saved to Google Password Manager
+      </message>
+      <message name="IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OPTED_IN" desc="Sub-label for the on-device encryption banner when the user is already opted in.">
+        Your passwords are encrypted on your device before they’re saved to Google Password Manager
+      </message>
       <message name="IDS_SECTION_SAVED_PASSWORDS_EXCEPTIONS" desc="Header for the list of websites for which user selected to never save passwords. [CHAR_LIMIT=32]">
         Never saved
       </message>
+      <message name="IDS_MANAGE_PASSWORDS_TEXT" desc="Text for link to manage passwords on Account Central.">
+        View and manage saved passwords in your <ph name="BEGIN_LINK">&lt;link&gt;</ph>Google Account<ph name="END_LINK">&lt;/link&gt;</ph>
+      </message>
+      <message name="IDS_SAVED_PASSWORDS_NONE_TEXT" desc="Text when there are no saved passwords/exceptions.">
+        Saved passwords will appear here.
+      </message>
+      <message name="IDS_PASSWORD_NO_RESULT" desc="Text when a password search returned no results.">
+        Can’t find that password. Check your spelling and try again.
+      </message>
       <message name="IDS_PASSWORD_EDIT_HINT" desc="Small hint on the editing screens that advises users to store the same password as they use on the currently edited site.">
         Make sure the password you are saving matches your password for <ph name="SITE">%1$s<ex>example.com</ex></ph>
       </message>
@@ -774,12 +804,30 @@ For more settings that use data to improve your Vanadium experience, go to <ph n
       <message name="IDS_PASSWORD_EXPORT_SET_LOCK_SCREEN" desc="Text prompting user to set device lock in order to be able to export passwords">
         Turn on screen lock in Settings to export your passwords from this device
       </message>
+      <message name="IDS_PASSWORD_SETTINGS_EXPORT_ACTION_TITLE" desc="The title of a menu item to trigger exporting passwords from the password settings.">
+        Export passwords…
+      </message>
+      <message name="IDS_PASSWORD_SETTINGS_EXPORT_ACTION_DESCRIPTION" desc="The description of a menu item to trigger exporting passwords from the password settings.">
+        Export passwords stored with Chrome
+      </message>
+      <message name="IDS_SETTINGS_PASSWORDS_PREPARING_EXPORT" desc="Text shown to the user above a progress bar, informing the user that passwords are being prepared for export.">
+        Preparing passwords…
+      </message>
       <message name="IDS_PASSWORD_SETTINGS_EXPORT_ERROR_TITLE" desc="The title of a dialog showing an error encountered during exporting passwords from the passwords settings.">
         Can’t export passwords
       </message>
+      <message name="IDS_PASSWORD_SETTINGS_EXPORT_LEARN_GOOGLE_DRIVE" desc="The label of a button in an error dialog after exporting passwords from the settings failed. The button takes the user to a help article about using Google Drive.">
+        Learn how to use Google Drive
+      </message>
+      <message name="IDS_PASSWORD_SETTINGS_EXPORT_NO_APP" desc="The explanation of the error when exporting passwords fails because the user has no Android app installed which could consume the exported data. The description is shown in the body of an alert dialog.">
+        Your device doesn’t have an app to store the passwords file.
+      </message>
       <message name="IDS_PASSWORD_SETTINGS_EXPORT_TIPS" desc="Tips on how to fix an error with exporting passwords. They are shown in the body of an alert dialog.">
         Try the following tips: make sure there is enough space on your device, try to export again.
       </message>
+      <message name="IDS_PASSWORD_SETTINGS_EXPORT_ERROR_DETAILS" desc="A short prefix to introduce a technical error message passed to the user from Android after exporting passwords through a temporary file fails. Both the prefix and the error message are shown in the body of an alert dialog.">
+        Details: <ph name="ERROR_DESCRIPTION">%1$s<ex>IOException: No space left on device</ex></ph>
+      </message>
       <message name="IDS_PASSWORDS_NOT_SECURE_FILLING" desc="The title of the dialog which is shown when the user attempts to enter obfuscated text to a regular text field.">
         Not secure
       </message>
@@ -864,6 +912,9 @@ For more settings that use data to improve your Vanadium experience, go to <ph n
       <message name="IDS_LOCKSCREEN_DESCRIPTION_EDIT" desc="When a user attempts to edit a password for a particular website in Chrome's settings, Chrome launches a lock screen to verify the user's identity and displays the following explanation.">
         Unlock to edit your password
       </message>
+      <message name="IDS_LOCKSCREEN_DESCRIPTION_EXPORT" desc="When a user attempts to export saved passwords in Vanadium's settings, Vanadium launches a lock screen to verify the user's identity and displays the following explanation.">
+        Unlock to export your passwords
+      </message>
 
       <!-- Homepage preferences -->
       <message name="IDS_OPTIONS_HOMEPAGE_EDIT_HINT" desc="Hint for the text edit on Homepage Preference setting, guiding user to enter their customized homepage setting">
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_LABEL.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_LABEL.png.sha1
new file mode 100644
index 0000000000000..8d5a058c467a7
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_LABEL.png.sha1
@@ -0,0 +1 @@
+d28d4141f2fe2ce44e78f6896cadb5ecd86d4ffe
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OFFER_OPT_IN.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OFFER_OPT_IN.png.sha1
new file mode 100644
index 0000000000000..8d5a058c467a7
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OFFER_OPT_IN.png.sha1
@@ -0,0 +1 @@
+d28d4141f2fe2ce44e78f6896cadb5ecd86d4ffe
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OPTED_IN.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OPTED_IN.png.sha1
new file mode 100644
index 0000000000000..26df889be89d0
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_ANDROID_TRUSTED_VAULT_BANNER_SUB_LABEL_OPTED_IN.png.sha1
@@ -0,0 +1 @@
+6eba108be0894a08ee8671f01afc350b282295c4
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORDS_CHECK_DESCRIPTION.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORDS_CHECK_DESCRIPTION.png.sha1
new file mode 100644
index 0000000000000..7dde38f36ac26
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORDS_CHECK_DESCRIPTION.png.sha1
@@ -0,0 +1 @@
+dde9e67e02af87bf8b25a1dff9de112432fff9cc
\ No newline at end of file
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_NO_RESULT.png.sha1 b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_NO_RESULT.png.sha1
new file mode 100644
index 0000000000000..683a14599c669
--- /dev/null
+++ b/chrome/browser/ui/android/strings/android_chrome_strings_grd/IDS_PASSWORD_NO_RESULT.png.sha1
@@ -0,0 +1 @@
+821ca2ab80b59d7b81213e77ed7efc201dbe31f6
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
index 4308450d0a0ac..5aad1326ce591 100644
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -7864,6 +7864,7 @@ test("unit_tests") {
       "../browser/page_image_service/android/image_service_bridge_unittest.cc",
       "../browser/page_load_metrics/observers/android_page_load_metrics_observer_unittest.cc",
       "../browser/partnerbookmarks/partner_bookmarks_shim_unittest.cc",
+      "../browser/password_manager/android/password_ui_view_android_unittest.cc",
       "../browser/performance_manager/policies/discard_page_with_crashed_subframe_policy_unittest.cc",
       "../browser/performance_manager/policies/process_rank_policy_android_unittest.cc",
       "../browser/policy/browser_dm_token_storage_android_unittest.cc",
diff --git a/components/browser_ui/settings/android/java/src/org/chromium/components/browser_ui/settings/SettingsNavigation.java b/components/browser_ui/settings/android/java/src/org/chromium/components/browser_ui/settings/SettingsNavigation.java
index ecac369f0b72d..4bfe76e1937b5 100644
--- a/components/browser_ui/settings/android/java/src/org/chromium/components/browser_ui/settings/SettingsNavigation.java
+++ b/components/browser_ui/settings/android/java/src/org/chromium/components/browser_ui/settings/SettingsNavigation.java
@@ -28,6 +28,7 @@ public interface SettingsNavigation {
         SettingsFragment.SAFETY_CHECK,
         SettingsFragment.SITE,
         SettingsFragment.ACCESSIBILITY,
+        SettingsFragment.PASSWORDS,
         SettingsFragment.GOOGLE_SERVICES,
         SettingsFragment.MANAGE_SYNC,
         SettingsFragment.FINANCIAL_ACCOUNTS,
@@ -47,14 +48,16 @@ public interface SettingsNavigation {
         int SITE = 4;
         /// Accessibility settings.
         int ACCESSIBILITY = 5;
+        /// Password settings.
+        int PASSWORDS = 6;
         /// Google services.
-        int GOOGLE_SERVICES = 6;
+        int GOOGLE_SERVICES = 7;
         /// Manage sync.
-        int MANAGE_SYNC = 7;
+        int MANAGE_SYNC = 8;
         /// Financial accounts.
-        int FINANCIAL_ACCOUNTS = 8;
+        int FINANCIAL_ACCOUNTS = 9;
         /// Non-card payment methods.
-        int NON_CARD_PAYMENT_METHODS = 9;
+        int NON_CARD_PAYMENT_METHODS = 10;
     }
 
     /**
